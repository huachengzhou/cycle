[{"content":"Java Theme Java技术体系 消息队列,nosql,sql,dubbo,zookeeper,nginx,springcloud,springboot,spring,jpa,mybatis\rjava语法，java多线程与并发,jdbc,设计模式\r","date":1508426775,"description":"Text about this post","lastmod":"2019-10-26T15:26:15Z","objectID":"3976528693a0108357f4928017600865","permalink":"/","publishdate":"2018-11-23T15:26:15Z","title":"Home title"},{"content":"一、编码  如果还没想清楚，就用蛮力算法。——Ken Thompson 不要使用反正弦和反余弦函数——你总能用优美的恒等式，或者是计算向量点积来更好地解决问题。—— Jim Conyngham 在存储日期中的年份的时候，请使用四位数字。—— David Martin 避免使用不对称结构。—— Andy Huber 代码写的越急，程序跑得越慢。—— Roy Carlson 你用英语都写不出来的东西就别指望用代码写了。—— Peter Halpern 如果代码和注释不一致，那很可能两者都错了。—— Norm Schryer 如果你发现特殊情况太多，那你肯定是用错方法了。—— Carig Zerouni 先把数据结构搞清楚，程序的其余部分自现。—— David Jones  二、用户界面  尽可能让用户界面风格保持一致和可预测。—— 匿名用户 计算机生成的输入通常会让一个原本设计接受手工输入的程序不堪重负。—— Dennis Ritchie 手工填写的表单里有20%都包含坏数据。—— Vic Vyssotsky 80%的表单会要你回答没有必要的问题。—— Mike Garey 不要让用户提供那些系统已经知道的信息。—— Rick Lemons 所有数据集的80%中，有95%的信息量都可以用清晰的图表示。—— William Cleveland  三、调试  在我所有的程序错误中，80%是语法错误，剩下20%里，80%是简单的逻辑错误，在剩下4%里，80%是指针错误，只有余下的0.8%才是困难的问题。—— Marc Donner 在系统测试阶段找出并修正错误，要比开发者自己完成这一工作多付出2倍的努力。而当系统已经交付使用之后找出并修正错误，要比系统测试阶段多付出9倍的努力。因此，请坚持让开发者进行单元测试吧。—— Larry Bernstain 不要站着调试程序，那会使得你的耐心减半，你需要的是全神贯注。—— Dave Storer 别在注释里陷得太深——注释很可能会误导你，你要调试的只是代码。—— Dave Storer 测试只能证明程序有错误，而不能证明程序没有错误。—— Edsger Dijkstra 新系统的每一个新用户都可能发现一类新的错误。—— Brian Kernighan 东西没坏，就别乱修。 —— Ronald Reagan 如果我们没能力修好它，我们就会告诉你它根本没坏。—— Walt Weir 修正程序错误的第一步是要重现这个错误。—— Tom Duff  四、性能  程序优化第一法则：不要优化。程序优化第二法则：还是不要优化。—— Michael Jackson 对于那些快速算法，我们总是可以拿一些速度差不多但是更容易理解的算法来替代它们。—— Douglas Jones 在一些机器上，间接寻址比基址寻址要慢，所以请把结构体或者记录中最常用的成员放在最前面。—— Mike Morton 在一个非IO密集型程序中，超过一半的运行时间是花在不足4%的代码上的。—— Don Knuth 在优化一个程序之前，请先用性能监视工具找到程序的“热点”。—— Mike Morton 当你为了加速，把一页代码变成几条简单的指令时，请不要忘了增加注释，以使源码的行数保持为一个常量。—— Mike Morton 如果程序员自己模拟实现了一个构造比编译器本身实现的那个构造还要快，那编译器的作者也太失败了。—— Guy Steele 要加速一个IO密集型程序，请首先考虑所有的IO，消除那些不必要的或冗余的IO，并使余下的部分尽可能地块。—— David Martin 最快的IO就是不IO。—— Nils-Peter Nelson 那些最便宜、最快而且可靠性最高的计算机组件压根就不存在。—— Gordon Bell 把一个本来就错了的程序变得更糟糕绝不是你的错。—— Bill McKeeman Lisp程序员知道所有东西的值，却不知道那些东西的计算成本。—— Alan Perlis  五、文档  如果一句话反过来就必然不成立，那就根本没必要把这句话放进文档。—— Bob Martin 当你试图解释一条命令、一个语言特性或者是一种硬件的时候，请首先说明它要解决什么问题。 —— David Martin 一个 { 规格说明、设计、过程、测试计划 } 如果不能在一页A4纸上写明白，那么这个东西别人就没法理解。—— Mark Ardis 纸上的工作没结束，整个工作也就还没结束。—— 匿名  六、软件管理  系统的结构反映出构建该系统的组织的结构。—— Richard Fairley 别坚持做没用的事情。—— 匿名 前90%的代码占用了90%的预定开发时间，余下的10%代码又花费了90%的预定开发时间。——Tom Cargill 只有不到10%的 …","date":1491696000,"description":"","lastmod":"2017-04-09T00:00:00Z","objectID":"6083a88ee3411b0d17ce02d738f69d47","permalink":"/about/","publishdate":"2017-04-09T00:00:00Z","title":"关于程序员"},{"content":"目录  网络体系结构 物理层 数据链路层 网络层 传输层 应用层  st=\u0026amp;gt;start: 开始\rop=\u0026amp;gt;operation: My Operation\rcond=\u0026amp;gt;condition: Yes or No?\re=\u0026amp;gt;end\rst-\u0026amp;gt;op-\u0026amp;gt;cond\rcond(yes)-\u0026amp;gt;e\rcond(no)-\u0026amp;gt;op\r\u0026amp;amp;```\r","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"cb297a4f2f51d1a7f942af59f3aa30c1","permalink":"/computer_network/","publishdate":"2021-04-15T00:00:00Z","title":"计算机网络 "},{"content":"回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"31e43c7ee446e19e0667f5ad4aec8825","permalink":"/computer_network/application_layer/","publishdate":"2021-04-15T00:00:00Z","title":"应用层 "},{"content":"回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"b834aeb617f016f80dd5e0fd70939e0f","permalink":"/computer_network/data_link_layer/","publishdate":"2021-04-15T00:00:00Z","title":"数据链路层 "},{"content":"计算机网络 概念  计算机网络是互连的、自治的计算机集合。  组成  组成部分:硬件、软件、协议 1 工作方式:边缘部分、核心部分 2 功能组成:通信子网、资源子网  分类  1 分布范围:广域网、城域网、局域网、个人区域网 2 使用者: 公用网、专用网 3 交换技术:电路交换、报文交换、分组交换 4 拓扑结构:总线型、星型、环型、网状型 5 传输技术:广播式、点对点  功能  1:数据通信 2:资源共享 3:分布式处理、提高可靠性、负载均衡  回到上一级 ","date":-62135596800,"description":"","objectID":"afa8f6ff9f945a9552b7898985de55c0","permalink":"/computer_network/network_architecture/1.1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5-%E7%BB%84%E6%88%90-%E5%8A%9F%E8%83%BD-%E5%88%86%E7%B1%BB/","title":"计算机概念 组成 功能 分类 * "},{"content":"标准的分类 法定标准  由权威机构制定的正式的、合法的标准 OSI  事实标准  某些公司的产品在竞争中占据了主流 ， TCP/IP 时间长了，这些产品中的协议和技术就成了标准  RFC   因特网标准的形式 (4个阶段)\n  1:因特网草案\n  2:建议标准\n  3:草案标准\n  4:因特网标准\n  国际标准化组织 ISO (最重要) 国际电信联盟 ITU 国际电气电子工程协会 IEEE 回到上一级 ","date":-62135596800,"description":"","objectID":"b03a7d2475945461d9f8ddeffb57fb6b","permalink":"/computer_network/network_architecture/1.1.2%E6%A0%87%E5%87%86%E5%8C%96%E5%B7%A5%E4%BD%9C%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%84%E7%BB%87/","title":"标准的分类"},{"content":"速率  速率即数据率或称数据传输率或比特率\n  速率即数据率或称数据传输率或比特率 比特 1/0 位 连接在计算机网络上的主机在数字信道上传输数据位数的速率 单位是b/s , kb/s,Gb/s,Gb/s ,Tb/s 发送端 ==\u0026amp;gt; 接收端 速率是10b/s 0101010101  宽带  \u0026amp;ldquo;带宽\u0026amp;quot;原本指某个信号具有的频道宽度，即最高频率与最低频率之差，单位是赫兹(Hz) 计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的\u0026amp;quot;最高数据率\u0026amp;rdquo;。单位是\u0026amp;quot;比特/秒\u0026amp;quot;  吞吐量  表示在单位时间内通过某个网络(或信道、接口)的数据量。单位b/s,kb/s,Mb/s 吞吐量受网络的带宽或网络的额定速率的限制   时延   时延 = 发送时延 + 传播时延 + 排队时延 + 处理时延\n  发送时延 : 从发送分组的第一个比特算起，到分组的最后一个比特发送完毕所需的时间(分组交换/路由器将数据推到信道上的时间)\n  传播时延 : 这里看什么介质来传播数据 计算机网络中是 数字信号 -\u0026amp;gt; 模拟信号 因此假如是光纤那么传播速度非常快2x⑩9 当然也有用无线电波我个人不知道无限电波是怎样模拟的无法知道速度究竟怎样,公示 传播时间 = 数据长度 / 传播速率(发送速率,带宽)\n  排队时延 : 等待输出/入链路可用\n  处理时延 : 检查找出口 (如果大陆地区还会有数据拆分与重新组合过滤检查)\n  时延带宽积 (可以理解为物理中的长度)  时延带宽积 = 传播时延 x 带宽 (时间 x 速度)  往返时延RTT   从发送方发送数据开始，到发送方收到接收方的确认\n  RTT 包括 往返传播时延 = 传播时延 * 2 ，末端处理时间\n  利用率 (信道利用率 , 网络利用率)   信道利用率 有数据通过时间 / 总体通过时间(有无数据通过时间)\n  网络利用率 信道利用率加权平均值\n  回到上一级 ","date":-62135596800,"description":"","objectID":"63f13303053a3e4b59ab6502d63c37bc","permalink":"/computer_network/network_architecture/1.1.3%E9%80%9F%E7%8E%87%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/","title":"速率"},{"content":"*[·-·]:注释内容\n计算机概念 组成 功能 分类 标准化工作及相关组织  法定标准 事实标准  分层参考模型 7层 , 4层 ,5层  计算机概念-组成-功能-分类 标准化工作及相关组织 速率相关的性能指标 分层结构 分层参考模型 模型层次详解  回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"50a32203e5a1d76d25cb849eba0b608e","permalink":"/computer_network/network_architecture/","publishdate":"2021-04-15T00:00:00Z","title":"网络体系结构"},{"content":"   名称 英文 作用     应用层 Application Layer 直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。如HTTP、SMTP、FTP、DNS等   表示层 Presentation Layer 把数据转换为能与接收者的系统格式兼容并适合传输的格式，即让两个系统可以交换信息   会话层 Session Layer 负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接   传输层 Transport Layer 负责端到端通讯，可靠传输，不可靠传输 ，流量控制，复用分用   网络层 Network Layer 负责选择路由最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)，拥塞控制   数据链路层 Data Link Layer 帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)   物理层 Physical Layer 定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快    回到上一级 ","date":-62135596800,"description":"","objectID":"8d7f7829f7ade13952cf79f864cd3cad","permalink":"/computer_network/network_architecture/%E5%88%86%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/","title":"分层参考模型"},{"content":"为什么要分层，分层要做什么  （1）发起通信的计算机必须将数据通信的通路进行激活。 （2）要告诉网络如何识别目的主机。 （3）发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。 （4）发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。 （5）确保差错和意外可以解决。  正式认识分层结构  使用 协议 ，服务， 接口 来完成分层\n 总结  网络体系结构是从功能上描述计算机网络结构 计算机网络体系结构简称网络体系结构是分层结构 每层遵循某个/多个网络协议以完成本层功能 计算机网络体系结构是计算机网络的各层及其协议的集合 上层要求服务 下层提供服务 实际是上层制定接口标准，下层实现接口标准  回到上一级 ","date":-62135596800,"description":"","objectID":"6ca6ac1cf3948fe20260a4df3bada6b7","permalink":"/computer_network/network_architecture/%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/","title":"分层结构"},{"content":"计算机网络分成结构 7层OSI参考模型 4层TCP/IP参考模型 5层体系结构 ISO/OSI模型怎么来的 ISO/OSI参考模型 ISO/OSI参考模型解释通信过程 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 OSI参考模型 与 TCP/IP参考模型 OSI参考模型与TCP/IP参考模型 相同点  1:都分层 2:基于独立的协议栈的概念 3:可以实现异构网络互联  不同点 面向连接分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。\r只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。\r而面向无连接没有这么多阶段，它直接进行数据传输。\r    ISO/OSI参考模型 TCP/IP模型     网络层 无连接 + 面向连接 无连接   传输层 面向连接 无连接 + 面向连接    五层参考模型  综合了OSI和TCP/IP的优点\n    参考层 说明     应用层 支持各种网络应用 FTP\\SMTP\\HTTP   传输层 进程-进程的数据传输 TCP\\UDP   网络层 源主机到目的主机的数据分组路由与转发 IP\\ICMP\\OSPF   数据链路层 把网络层传下来的数据报组装成帧 Ethernet ppp   物理层 比特传输    5层参考模型的数据封装与解封装 回到上一级 ","date":-62135596800,"description":"","objectID":"5423edd029372887bdb860cfc5d47ca0","permalink":"/computer_network/network_architecture/%E6%A8%A1%E5%9E%8B%E5%B1%82%E6%AC%A1%E8%AF%A6%E8%A7%A3/","title":"模型层次详解"},{"content":"回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"99e8c1515c2e9a3098ef3b8d43f7261c","permalink":"/computer_network/network_layer/","publishdate":"2021-04-15T00:00:00Z","title":"网络层 "},{"content":" 物理层基本概念 数据通信基础知识  回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"253a4629679c5a0613b021b87df3b45d","permalink":"/computer_network/physical_layer/","publishdate":"2021-04-15T00:00:00Z","title":"物理层 "},{"content":"典型的数据通信模型 数据通信相关术语  通信的目的是传送消息(消息:语音、文字、图像、视频等)。\n   信号:数据的电气/电磁的表现，是数据在传输过程中的存在形式。\n  数字信号/离散信号:代表消息的参数的取值是离散的\n   模拟信号/连续信号:代表消息的参数的取值是连续的   信源:产生和发送数据的源头。 信宿:接收数据的终点。 信道:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。   信道  按传输信号分 模拟信道(传送模拟信号) 数字信道(传送数字信号) 按传输介质分 无线信道 有线信道    设计数据通信系统要考虑的三个问题 采用单工通信(只有一个方向)/半双工通信(回合制)/全双工通信(可以同时如擂台上拳击手打击) * 采用串行通信/并行通信 采用同步通信/异步通信 串行传输\u0026amp;amp;并行传输 同步传输\u0026amp;amp;异步传输 回到上一级 ","date":-62135596800,"description":"","objectID":"3523706943daeb0b37115965b5c6b8f4","permalink":"/computer_network/physical_layer/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"数据通信基础知识 "},{"content":"物理层接口特性  物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 物理层主要任务：确定与传输媒体接口有关的一些特性 ==\u0026amp;gt; 定义标准\n  1.机械特性 定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量、排列情况  2.电器特性 规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制。 某网络在物理层规定，信号的电平用+10V~+15V表示二进制0，用-10V~-15V表示二进制1，电线长度限于15m以内 3.功能特性 指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。 描述一个物理层接口引脚处于高电平时的含义 4.过程特性 定义各条物理线路的工作规程和时序关系。  回到上一级 ","date":-62135596800,"description":"","objectID":"57771b4fcbe5c05f6a88adf791ecebf5","permalink":"/computer_network/physical_layer/%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"物理层基本概念 "},{"content":"回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"9d3228526ac4e54bf6e1766031c62a02","permalink":"/computer_network/transport_layer/","publishdate":"2021-04-15T00:00:00Z","title":"传输层 "},{"categories":["mysql","sql"],"content":" 数据库，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据进行新增、查询、更新、删除等操作。\n 目录  数据库基础  1.1-认识MySQL 1.2-轻松安装MySQL 1.3-MySQL数据库连接 1.4-SQL语言入门 1.5-认识DBA   MySQL数据库对象与应用  2.1-MySQL数据类型 2.2-MySQL数据对象 2.3-MySQL权限管理 2.4-SQL语言进阶 2.5-内置函数 2.6-触发器与存储过程 2.7-MySQL字符集 2.8程序连接MySQL 2.9-DAO框架的使用   MySQL事务与存储引擎  3.1-数据库事务 3.2-存储引擎概述 3.3-InnoDB存储引擎 3.4-InnoDB事务锁   MySQL应用优化  4.1-MySQL索引优化与设计 4.2-MySQL数据库设计 4.3-MySQL容量评估 4.4-MySQL性能测试   MySQL运维实践  5.1-MySQL日志系统 5.2-MySQL数据备份 5.3-MySQL数据恢复 5.4-MySQL线上部署 5.5-MySQL主从复制 5.6-MySQL日常运维 5.7-MySQL参数调优    ","date":1554163200,"description":"","lastmod":"2019-04-02T00:00:00Z","objectID":"a9d7e48e44765565bd2b10b66dc01682","permalink":"/databases/","publishdate":"2019-04-02T00:00:00Z","tags":["mysql","sql"],"title":" 数据库"},{"content":"网易云课堂MySQL微专业学习笔记  但愿可以不弃坑。\n 目录  数据库基础  1.1-认识MySQL 1.2-轻松安装MySQL 1.3-MySQL数据库连接 1.4-SQL语言入门 1.5-认识DBA   MySQL数据库对象与应用  2.1-MySQL数据类型 2.2-MySQL数据对象 2.3-MySQL权限管理 2.4-SQL语言进阶 2.5-内置函数 2.6-触发器与存储过程 2.7-MySQL字符集 2.8程序连接MySQL 2.9-DAO框架的使用   MySQL事务与存储引擎  3.1-数据库事务 3.2-存储引擎概述 3.3-InnoDB存储引擎 3.4-InnoDB事务锁   MySQL应用优化  4.1-MySQL索引优化与设计 4.2-MySQL数据库设计 4.3-MySQL容量评估 4.4-MySQL性能测试   MySQL运维实践  5.1-MySQL日志系统 5.2-MySQL数据备份 5.3-MySQL数据恢复 5.4-MySQL线上部署 5.5-MySQL主从复制 5.6-MySQL日常运维 5.7-MySQL参数调优    回到上一级 ","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"a0664ebdd8c2a31d98075b8a997d3c60","permalink":"/databases/mysql_163%E8%AF%BE%E5%A0%82/","publishdate":"2021-01-17T15:26:15Z","title":"网易云课堂MySQL微专业学习笔记"},{"content":"MySQL数据库基础 1.1-认识MySQL 什么是数据库  计算机处理和存储的一切信息都是数据。 计算机系统中一种用于存取数据的程序。 一种：  计算机系统中有很多种能够存取数据的程序 它们各有特征和长处，有自己的适用范围。   存取：  能够保存数据避免丢失。 能够按照需求找到符合条件的数据。    为什么要使用数据库 数据库帮助我们解决一下数据存取难题：\n 较大数据量 网络控制 并发访问 高性能要求 事务控制 持久化和数据安全 查询数据需求逻辑复杂  数据库分类   关系型数据库\n MySQL Oracle SQL Server PostgreSQL    非关系型数据库\n hadoop：存放大数据 mongoDB： 文档型数据库 redis：键值型数据库 Cassandra：分布式数据库    最显著的区别：是否使用结构化查询语句（SQL）\n为什么学习MySQL MySQL：The world\u0026amp;rsquo;s most popular open source database\n  最流行\n  开源\n  并不是最先进\n  前三强中唯一的开源数据库。\n  在互联网企业中占据绝对主流地位。\n  基于GPL协议开放源代码\n  社区版完全免费\n  代码允许自由的进行修改\n  易于学习：\n MySQL具备关系型数据库核心功能但是特性并不繁多。 架构设计上趋于精简。 非常适合新手学习关系型数据库，入门后可向其他数据库发展。    谁需要学习MySQL  应用开发者 DBA  学习目标 - 应用开发者 有助于利用MySQL开发出性能优异的应用程序\n学习目标 - DBA 为企业提供可靠的数据库技术保障\n1.2-轻松安装MySQL 轻松部署MySQL  Windows下安装MySQL  图形化工具安装， MySQL Installer   Linux（Ubuntu）下安装MySQL  包管理安装，apt-get    Windows安装时在安装中间starting server时报错解决办法是手动进入服务管理把MySQL服务的登录方式改为用本地账户且允许与桌面交互\n在Ubuntu下可以用apt-cache search mysql-server查看可用的软件包\n使用sudo apt-get install mysql-server-5.6安装MySQL5.6\n启动与停止MySQL服务：\n# 启动 sudo /etc/init.d/mysql start # 或者 sudo service mysql start # 停止 sudo /etc/init.d/mysql stop # 或者 sudo service mysql stop # 重启 sudo service mysql restart # 查看状态 sudo /etc/init.d/mysql status 1.3-MySQL数据库连接 工作中常用到的三种连接方式  Java App + JDBC client（其他语言也有，比如Python的MySQLdb） MySQL client \u0026amp;ldquo;MySQL\u0026amp;rdquo; utility  使用应用程序连接MySQL  应用程序使用驱动（connector/driver）客户端连接MySQL MySQL驱动程序涵盖各种主流语言  使用命令行连接MySQL  安装MySQL客户端软件包 设置环境变量（Linux）  如何安装MySQL-client  从软件源安装sudo apt-get install mysql-client  验证MySQL的安装 mysql -V\n命令行连接MySQL的两种方式  Socket连接（本地连接） TCP/IP连接（远程连接）  使用Socket连接 # 需要指定socket文件和用户名、密码 mysql -S/tmp/mysql.sock -uroot -p 远程连接 # 需要指定IP和端口 mysql -h127.0.0.1 -P3306 -uroot -p 本地连接VS远程连接  本地连接只能在MySQL服务器上创建，常用作为MySQL状态检查，或程序和MySQL部署在一台机器上。 远程连接在MySQL服务器内外都能生效，适合应用服务器和MySQL部署在不同机器上的场景。  在Windows下用命令行连接MySQL mysql -hlocalhost -P3306 -uroot -p 连接进入之后可以做什么 # 数据库状态 status; # 展示当前连接 show processlist; 使用命令行连接MySQL的注意事项  socket一般存储路径为：/tmp/mysql.sock  # 如果找不到文件可以通过tcp连接进来然后通过如下命令查找 show global …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"4785de9a1ac9e0cb94fbbe235141808a","permalink":"/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter1/","publishdate":"2020-01-17T15:26:15Z","title":"MySQL数据库基础"},{"content":"MySQL数据库对象与应用 2.1-MySQL数据类型 Number不止一种  整形 浮点型  整形  INT SMALLINT MEDIUMINT BIGINT     type Storage Minumun Value Maximum Value      (Bytes) (Signed/Unsigned) (Signed/Unsigned)   TINYINT 1 -128 127     0 255   SMALLINT 2 -32768 32767     0 65535   MEDIUMINT 3 -8388608 8388607     0 16777215   INT 4 -2147483648 2147483647     0 4294967295   BIGINT 8 -9223372036854775808 9223372036854775807     0 18446744073709551615    老生常谈的问题 int(11) VS int(21) 存储空间，还是存储范围有区别？\n答案是：两者完全一样，只是在显示的时候补全0的位数不一样。\n可以通过下面的例子来验证：\ncreate table t(a int(11) zerofill, b int(21) zerofill); insert into t values (1, 1); select * from t; MySQL默认是不带0补全的。\n只是在一些特殊情况下两者显示有区别，其本质完全一样。\n浮点型  FLOAT(M, D) DOUBLE(M, D)     属性 存储空间 精度 精确性     Float 4 bytes 单精度 非精确   Double 8 bytes 双精度 比Float精度高    精度丢失问题  精度丢失  一个例子：\ncreate table t(a int(11), b float(7, 4)); insert into t values (2, 123.12345); select * from t; 定点数-更精确的数字类型  DECIMAL  高精度的数据类型，常用来存储交易相关的数据 DECIMAL(M,N).M代表总精度，N代表小数点右侧的位数（标度） 1 \u0026amp;lt; M \u0026amp;lt; 254, 0 \u0026amp;lt; N \u0026amp;lt; 60; 存储空间变长    性别、省份信息 一般使用tinyint、char(1)、enum类型。\n经验之谈  存储性别、省份、类型等分类信息时选择TINYINT或者ENUM BIGINT存储空间更大，INT和BIGINT之间通常选择BIGINT 交易等高精度数据选择使用DECIMAL  存储用户名的属性  CHAR VARCHAR TEXT  CAHR与VARCHAR  CHAR和VARCHAR存储的单位都是字符 CHAR存储定长，容易造成空间的浪费 VARCHAR存储变长，节省存储空间  字符与字节的区别    编码\\输入字符串 网易 netease     gbk(双字节) varchar(2)/4 bytes varchar(7)/7 bytes   utf8(三字节) varchar(2)/6 bytes varchar(7)/7 bytes   utf8mb4(四字节) varchar(2) ? varchar(7)/7 bytes    对于utf8mb4号称占用四字节但是并不绝对。如果在utf8可以覆盖到的范围则仍然占用3字节。\nutf8mb4最有优势的应用场景是用于存储emoji表情\nemoji表情  MySQL版本 \u0026amp;gt; 5.5.3 JDBC驱动版本 \u0026amp;gt; 5.1.13 库和表的编码设为utf8mb4  TEXT与CHAR和VARCHAR的区别  CHAR和VARCHAR存储单位为字符 TEXT存储单位为字节，总大小为65535字节，约为64KB CHAR数据类型最大为255字符 VARCHAR数据类型为变长存储，可以超过255个字符 TEXT在MySQL内部大多存储格式为溢出页，效率不如CHAR  一个例子：\ncreate table t (a char(256)); create table t (a varchar(256)); 存储头像  BLOB BINARY  性能太差，不推荐\n经验之谈  CHAR与VARCHAR定义的长度是字符长度不是字节长度 存储字符串推荐使用VARCHAR(N),N尽量小 虽然数据库可以存储二进制数据，但是性能低下，不要使用数据库存储文件音频等二进制数据  存储生日信息  DATE TIME DATETIME TIMESTAMP BIGINT  时间类型的区别在哪里   存储空间上的区别\n DATE三字节， …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"0a5b181b03b73fd408490cd941df9ea6","permalink":"/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter2/","publishdate":"2020-01-17T15:26:15Z","title":"MySQL数据库对象与应用"},{"content":"MySQL事务与存储引擎 3.1-数据库事务 什么是事务  一系列有序的数据库操作：  要么全部成功 要么全部回退到操作前的状态 中间状态对其他连接不可见   事务的基本操作：    基本操作 说明     start transaction 开始事务   commit 提交(全部完成)   rollback 回滚(回到初始状态)      -- 开启一个事务 start transaction; -- 或者使用(非标准sql) begin; insert into t values (1, 1, 1); -- 事务结束，插入成功 commit; begin; insert into t values (2, 1, 1); insert into t values (3, 1, 1); insert into t values (4, 1, 1); -- 事务结束，没有插入数据 rollback; begin; insert into t values (1, 1, 1); savepoint a1; insert into t values (2, 1, 1); -- 回滚到指定的保存点 rollback to a1; commit; 自动提交  autocommit可以在session级别设置 每个DML操作都自动提交 DDL永远都是自动提交，无法通过rollback回滚  事务的四个基本属性(ACID)  原子性(Atomicity) 一致性(Consistency) 隔离性(Isolation) 持久性(Durability)  事务的原子性  包含在事务中的操作要么全部被执行，要么都不执行 中途数据库或应用发生异常，未提交的事务都应该被回滚  事务的一致性  数据的正确性，合理性，完整性 数据一致性应该符合应用需要规则：  余额不能是负数 交易对象必须先有账号 用户账号不能重复   事务的结果需要满足数据的一致性约束  事物的持久性  提交完成的事务对数据库的影响必须是永久性的  数据库异常不会丢失事务更新 通常认为成功写入磁盘的数据即为持久化成功    事务的持久化的实现  数据文件持久化  随机同步刷新(慢)   事务日志持久化与实例恢复  顺序同步刷新(快) -\u0026amp;gt; 事务日志 随机异步刷新 -\u0026amp;gt; 磁盘 事务日志 -\u0026amp;gt; 磁盘(实例恢复)    事务的隔离性  数据库事务在提交完成前，中间的任何数据变化对其他的事务都是不可见的。  数据库隔离现象    隔离现象 描述     脏读(Dirty Read) 事务B读到事务A尚未提交的数据变更   不可重复读(NonRepeatable Read) 事务B读取前后两次读取一条记录之间该记录被事务A修改并提交，于是事务B读到了不一样的结果   幻读(Phantom Read) 事务B按条件匹配到了若干行记录并修改。但是由于修改过程中事务A新插入了符合条件记录，导致B更新完成后发现仍有符合条件却未被更新的记录。    数据库隔离等级    隔离等级 脏读 不可重复读 幻读     未提交读 可能 可能 可能   已提交读 不可能 可能 可能   可重复读 不可能 不可能 可能   可串行化读 不可能 不可能 不可能    MySQL的事务隔离级别  InnoDB默认标记为可重复读 InnoDB并不是标准定义上的课重复读 InnoDB默认在可重复读的基础上避免幻读  MySQL事务隔离级别设置  可在global/session/下个事务，级别分别进行设置 建议使用Read committed(同Oracle) 或者建议使用默认的Repeatable read  set tx_isolation = \u0026amp;#39;\u0026amp;#39; -- 设置隔离级别 事务与并发写  某个正在更新的记录再提交或回滚前不能被其他事务同时更新  事务回滚的实现  回滚段(rollback segment)与数据前像  3.2-存储引擎概述 MySQL程序层次架构 MySQL存储引擎  有多种可选方案，可插拔，可修改存储引擎 基于表选择使用何种存储引擎  主要存储引擎    存储引擎 常用度 支持事务     InnoDB 主要，推荐 是   MyISAM 古老，偶尔有用，系统表 否   MEMORY 偶尔临时表有用，纯内存 否   BLACKHOLE 不用来存放数据，个别特殊用处 否   TokuDB 新颖，个别特殊场景有奇效 是   Cluster 新颖，分布式，内存，线上不要用 是    InnoDB存储引擎  索引组织表 支持事务 支持行级锁 数据块缓存 日志持久化 稳定可靠，性能好，线上尽量使用InnoDB  MyISAM存储引擎  堆表 不支持事务 只维护索引缓存池，表数据缓存交 …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"f4b0f50af8733c395529259d5253700a","permalink":"/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter3/","publishdate":"2020-01-17T15:26:15Z","title":"MySQL事务与存储引擎"},{"content":"MySQL应用优化 4.1-MySQL索引优化与设计 什么是索引  索引的意义 —— 快速定位要查找的数据  数据库索引查找  全表扫描 VS 索引查找  如何根据首字母找到所在行  二分查找 B+tree  InnoDB表聚簇索引 索引中只放着排序字段和ID\n创建索引  单列索引  create index idx_test1 on tb_student (name);  联合索引  create index idx_test2 on tb_student (name, age);  索引中先根据name排序，name相同的情况下，根据age排序  索引维护  索引维护由数据库自动完成 插入/修改/删除每一个索引行都会变成一个内部封装的事务 索引越多，事务越长，代价越高 索引越多对表的插入和索引字段修改就越慢 控制表上索引的数量，切忌胡乱添加无用索引  如何使用索引  依据WHERE查询条件建立索引  select a, b from tab_a where c=? ; idx_c (c) select a, b from tab_a where c=? and d=?; idx_cd (c, d)  排序order by, group by, distinct字段添加索引  select * from tb_a order by a; select a, count(*) from tb_a group by a; idx_a (a) select * from tb_a order by a, b; idx_a_b (a, b) select * from tb_a order where c=? by a; idx_c_a (c, a) 索引与字段选择性   某个字段其值的重复程度\n  选择性很差的字段通常不适合创建单列索引\n 男女比例相仿的列表中性别不适合创建单列索引 如果男女比例极不平衡，要查询的又是少数方(理工院校查女生)可以考虑使用索引    联合索引中选择性好的字段应该排在前面\n  select * from tab_a where gender=? and name=?; idx_a1 (name, gender) 联合索引与前缀查询  联合索引能为前缀单列，复列查询提供帮助  idx_smp (a, b, c) where a=? ; where a=? and b=? ; where a=? and c=? ;(部分ok)  合理创建联合索引，避免冗余 (a) , (a, b) , (a, b, c) X (a, b, c) ok  长字段上的索引  在非常长的字段上建立索引影响性能 InnoDB索引单字段(utf8)只能取前767 bytes 对长字段处理的方法  Email类，建立前缀索引  Mail_addr varchar(2048) idx_mailadd (Mail_addr(30)) ok  住址类，拆分字段  Home_address varchar(2048) idx_mailadd (Mail_addr(30)) ? -- 很可能前半段都是相同的省市区街道名称 Province varchar(1024), City varchar(1024), District varchar(1024), Local_address varchar(1024) ... -- 建立联合索引或单列索引   索引覆盖扫  最核心SQL考虑索引覆盖 select Name from tb_user where UserID=? Key idx_uid_name(UserID, Name)  不需要回表获取name字段，IO最小，效率最高  无法使用索引的情况  索引列进行数学运算或函数运算 where id+1=10; X where id = (10-1); ok year(col) \u0026amp;lt; 2007; X col \u0026amp;lt; \u0026amp;#39;2007-01-01\u0026amp;#39;; ok  未含符合索引的前缀字段 Idx_abc (a, b, c): where b=? and c=?; X (b, c) ok  前缀通配,\u0026#39;_\u0026amp;lsquo;和\u0026amp;rsquo;%\u0026amp;lsquo;通配符 Like \u0026amp;#39;%xxx%\u0026amp;#39;; X Like \u0026amp;#39;xxx%\u0026amp;#39;; ok  where 条件使用NOT, \u0026amp;lt;\u0026amp;gt;, != 字段类型匹配  并不绝对，但是无法预测地会造成问题，不要使用  a int(11), idx_a (a) where a = \u0026amp;#39;123\u0026amp;#39;; X where a = 123 ; ok   利用索引排序 idx_a_b (a, b)\n 能够使用索引帮助排序的查询： …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"6b55bf572b2a4c92a8e6f235c9a7b908","permalink":"/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter4/","publishdate":"2020-01-17T15:26:15Z","title":"MySQL应用优化"},{"content":"MySQL运维实践 5.1-MySQL日志系统 什么是日志  日志(log)是一种顺序记录事件流水的文件 记录计算机程序运行过程中发生了什么 多种多样的用途  帮助分析程序问题 分析服务请求的特征、流量等 判断工作是否成功执行 等等……    MySQL日志的分类  服务器日志  记录进程启动运行过程中的特殊事件，帮助分析MySQL服务遇到的问题 根据需求抓取特定的SQL语句，追踪性能可能存在的问题的业务SQL   事务日志  记录应用程序对数据的所有更改 可用于数据恢复 可用于实例间数据同步       分类 日志名称     服务器日志 服务错误日志   服务器日志 慢查询日志   服务器日志 综合查询日志   事务日志 存储引擎事务日志   事务日志 二进制日志    服务错误日志  记录实例启动运行过程中重要消息 配置参数  log_error = /data/mysql_data/node-1/mysql.log   内容并非全是错误消息 如果mysqld进程无法正常启动首先查看错误日志  慢查询日志  记录执行时间超过一定阈值的SQL语句 配置参数  slow_query_log = 1 slow_query_log_file = /data/mysql_data/node-1/mysql-slow.log long_query_time = 5  用于分析系统中可能存在性能问题的SQL  综合查询日志  如果开启将会记录系统中所有SQL语句 配置参数  general_log = 1 general_log_file = /data/mysql_data/node-1/mysql-slow.log  偶尔用于帮助分析系统问题，对性能有影响  查询日志的输出与文件切换  日志输出参数  log_output={file|table|none}\n 如果日志文件过大，可以定期截断并切换新文件  flush log;\n存储引擎事务日志  部分存储引擎拥有重做日志(redo log) 如InnoDB, TokuDB等WAL(Write Ahead Log)机制存储引擎 日志随着事务commit优先持久化，确保异常恢复不丢数据 日志顺序写性能较好  InnoDB事务日志重用机制  InnoDB事务日志采用两组文件交替重用  二进制日志binlog  binlog (binary log) 记录数据引起数据变化的SQL语句或数据逻辑变化的内容 MySQL服务层记录，无关存储引擎 binlog的主要作用：  基于备份恢复数据 数据库主从同步 挖掘分析SQL语句    开启binlog  主要参数  log_bin = c:/tmp/mylog/mysql-bin\rsql_log_bin = 1\rsync_binlog = 1\r 查看binlog  show binary logs;\nbinlog管理  主要参数  max_binlog_size = 100MB\rexpire_logs_days = 7\r  binlog始终生成新文件，不会重用\n  手工清理binlog\n  purge binary logs to \u0026#39;mysql-bin.000009\u0026#39;;\rpurge binary logs before \u0026#39;2016-4-2 21:00:40\u0026#39;\r查看binlog内容  日志  show binlog events in \u0026#39;mysql-bin.000011\u0026#39;;\rshow binlog events in \u0026#39;mysql-bin.000011\u0026#39; from 60 limit 3;\r mysqlbinlog工具  mysqlbinlog c:/tmp/mylog/mysql-bin.000001\r--start-datetime | --stop-datetime\r--start-position | --stop-position\rbinlog格式  主要参数  binlog_format = {ROW|STATEMENT|MIXED}\n 查看row模式的binlog内容  mysqlbinlog --base64-output=decode-rows -v c:/tmp/mylpg/mysql-bin.000001\n5.2-MySQL数据备份 基本指数 - 备份用途  数据备灾  应对硬件故障数据丢失 应对人为或程序bug导致数据删除   制作镜像库以供服务  需要将数据迁移、统计分析等用处 需要为线上数据建立一个镜像    基本知识 - 备份内容  数据  数据文件或文本格式数据   操作日志(binlog)  数据库变更日志    基本知识 - 冷备份与热备份  冷备份  关闭数据库服务，完整拷贝数据文件   热备份  在不影响数据库 …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"6d54e1aef6dc720c1105d25c62859bc5","permalink":"/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter5/","publishdate":"2020-01-17T15:26:15Z","title":"MySQL运维实践"},{"content":"hugo学习\n","date":1508253975,"description":"","lastmod":"2017-10-17T15:26:15Z","objectID":"5911f5f8a5a5b68eddbcbf7f91c0d34e","permalink":"/hugo%E5%AD%A6%E4%B9%A0/","publishdate":"2017-10-17T15:26:15Z","title":"hugo教程"},{"content":" 今天尝试了一下静态博客 hugo , hugo的官网本身也是使用 hugo 制作的网站。安装和运行非常简单。只有两个步骤安装和运行。运行的时候出现了一个小问题，就是由于网络的原因不能启动成功。\n 粗暴的禁用网络连接相关的操作  就是两个 短代码 给删除了 instagram, tweet。  find . -name \u0026amp;amp;quot;*.md\u0026amp;amp;quot; | xargs sed -i \u0026amp;amp;#x27;/{{\u0026amp;amp;lt; instagram/cinstagram content\u0026amp;amp;#x27;\rfind . -name \u0026amp;amp;quot;*.md\u0026amp;amp;quot; | xargs sed -i \u0026amp;amp;#x27;/{{\u0026amp;amp;lt; tweet/ctwitter content\u0026amp;amp;#x27;\rhugo server --bind \u0026amp;amp;#x27;0.0.0.0\u0026amp;amp;#x27;\r print code  ERROR 2021/03/06 09:55:20 Failed to get JSON resource \u0026amp;quot;https://api.twitter.com/1/statuses/oembed.json?id=877500564405444608\u0026amp;amp;dnt=false\u0026amp;quot;: Get \u0026amp;quot;https://api.twitter.com/1/statuses/oembed.json?id=877500564405444608\u0026amp;amp;dnt=false\u0026amp;quot;: dial tcp 31.13.91.33:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.\rIf you feel that this should not be logged as an ERROR, you can ignore it by adding this to your site config:\rignoreErrors = [\u0026amp;quot;error-remote-getjson\u0026amp;quot;]\rBuilt in 21188 ms\rError: Error building site: logged 1 error(s)\r","date":1508253975,"description":"","lastmod":"2017-10-17T15:26:15Z","objectID":"0813801ae8004f6a028099d73befde54","permalink":"/hugo%E5%AD%A6%E4%B9%A0/hugo_server_faile_-to_get_json/","publishdate":"2017-10-17T15:26:15Z","title":"hugo教程 hugo server Failed to get JSON"},{"content":"教程1 快速开始  步骤1：安装Hugo  brew install hugo\r# or\rport install hugo\r 要验证新安装  hugo version\r 步骤2：建立新网站  hugo new site quickstart\r# 上面的代码将在名为的文件夹中创建一个新的Hugo网站quickstart。\r 步骤3：添加主题  # 首先，从GitHub下载主题并将其添加到您站点的themes目录中：\rcd quickstart\rgit init\rgit submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke\r 然后，将主题添加到站点配置中：  echo \u0026#39;theme = \u0026amp;quot;ananke\u0026amp;quot;\u0026#39; \u0026amp;gt;\u0026amp;gt; config.toml\r 步骤4：添加一些内容  hugo new posts/my-first-post.md\r 如果需要，请编辑新创建的内容文件，该文件将从以下内容开始：   ---\rtitle: \u0026amp;quot;My First Post\u0026amp;quot;\rdate: 2019-03-26T08:47:11+01:00\rdraft: true\r---\r 步骤5：启动Hugo服务器  ▶ hugo server -D\r| EN\r+------------------+----+\rPages | 10\rPaginator pages | 0\rNon-page files | 0\rStatic files | 3\rProcessed images | 0\rAliases | 1\rSitemaps | 1\rCleaned | 0\rTotal in 11 ms\rWatching for changes in /Users/bep/quickstart/{content,data,layouts,static,themes}\rWatching for config changes in /Users/bep/quickstart/config.toml\rEnvironment: \u0026amp;quot;development\u0026amp;quot;\rServing pages from memory\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop\r 步骤7：建立静态页面  hugo -D\r./public/默认情况下，输出将位于目录中（-d/--destination标志进行更改，或publishdir在配置文件中设置）\r","date":1508253975,"description":"","lastmod":"2017-10-17T15:26:15Z","objectID":"1a274dc5638917043761b608e7ef5638","permalink":"/hugo%E5%AD%A6%E4%B9%A0/hugo_tutorials1/","publishdate":"2017-10-17T15:26:15Z","title":"hugo教程1"},{"content":"教程2  1、\t创建blog  hugo new site myblog_pub\rcd myblog_pub/\rgit submodule add https://github.com/chinanf-boy/gohugo-theme-yinwang.git themes/yinwang\r  2、\t修改配置\n  vi config.toml\n  root@instance-x8rtph4n:/home/go/code/hugo_dir/myblog_pub/public# more ../config.toml baseURL = \u0026amp;quot;http://ypbsyy.github.io/\u0026amp;quot;\rlanguageCode = \u0026amp;quot;en-us\u0026amp;quot;\rtitle = \u0026amp;quot;我是yaopeng\u0026amp;quot;\rtheme = \u0026amp;quot;yinwang\u0026amp;quot;\r#pygmentsCodeFences = true\r#pygmentsCodefencesGuessSyntax = false\r#pygmentsStyle = \u0026amp;quot;dracula\u0026amp;quot;\r#pygmentsOptions = [\u0026#39;linenos\u0026#39;]\r# 代码高亮/chroma，hugo默认自带\r[params]\rauthor = \u0026amp;quot;yaopeng\u0026amp;quot;\rgithub = \u0026amp;quot;yaopeng\u0026amp;quot;\r# gitlab = \u0026amp;quot;yobrave\u0026amp;quot;\r#googleAnalytics = \u0026amp;quot;****\u0026amp;quot;\r# 谷歌统计gtag\rhighlight = \u0026amp;quot;dracula\u0026amp;quot; # 默认样式 `github`\rlangs = [\u0026amp;quot;go\u0026amp;quot;]\r# 默认加载 highlight.min.js，但 一些不支持的语言, 你自己添加,\r# 其实也可以使用hugo自带的语法高亮器设置，不过我有点懒\r# single = false\r# 单页面的Home 按钮去除\r# menus = true\r# 我 想加更多目录\r# backgroundColor = \u0026amp;quot;#fbf6ec\u0026amp;quot;\r加点黄黄的背景色   3、\t创建github\n  4、\t部署到github\n  git submodule init\rgit submodule update\rhugo --buildDrafts\rcd public/\rgit init\rgit remote rm origin git remote add origin https://github.com/ypbsyy/ypbsyy.github.io.git\rgit add -A\rgit commit -m \u0026amp;quot;first commit\u0026amp;quot;\rgit push -u origin master\r这里面实际到hugo –buildDrafts 这里就ok 剩余的是把public中的html传入静态网页中\r 注意文章开头必须有这几个   ---\rtitle: \u0026amp;quot;My First Post\u0026amp;quot;\rdate: 2019-03-26T08:47:11+01:00\rdraft: true\r---\r  baseURL = \u0026amp;ldquo;https://swagcode-io.github.io/demo\u0026amp;quot;\n  这里的url是自己对应的\n  git submodule add https://github.com/chinanf-boy/gohugo-theme-yinwang.git themes/yinwang\n  下载主题\n  参考网址\n  https://www.pianshen.com/article/1216214802/\n  https://zhuanlan.zhihu.com/p/105021100?utm_source=weibo\n  https://zhuanlan.zhihu.com/p/105021100?utm_source=weibo\n  ","date":1508253975,"description":"","lastmod":"2017-10-17T15:26:15Z","objectID":"9bfba651cc29346a0f766861f387f954","permalink":"/hugo%E5%AD%A6%E4%B9%A0/hugo_tutorials2/","publishdate":"2017-10-17T15:26:15Z","title":"hugo教程2"},{"categories":["java"],"content":"目录   工具文档\n  中间件\n  groovy 脚本\n  ","date":1554163200,"description":"","lastmod":"2019-04-02T00:00:00Z","objectID":"069ba9848a8583be77448aa79158c70f","permalink":"/javadir/","publishdate":"2019-04-02T00:00:00Z","tags":["java"],"title":" Java技术栈"},{"content":"目录  jsp  回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"ebd4a9d6e060d0cd71e733536f8151ea","permalink":"/javadir/basedir/","publishdate":"2021-04-15T00:00:00Z","title":"Java基础知识 "},{"content":"目录 el表达式\n字符串el表达式\nJSTL_core标签库\nsession\n监听事件原理\n回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"02c30506c19a561ee9943348847c35c7","permalink":"/javadir/basedir/jsp_dir/","publishdate":"2021-04-15T00:00:00Z","title":"jsp 基础知识 "},{"content":"接口回调法 模拟输出监听事件 第一步先定义事件接口 public interface PrintListener {\rpublic void print();\r}\r第二步自定义输出类 public class Out {\rPrintListener listener=null;\rpublic Out() {\r}\rpublic Out(PrintListener listener) {\rthis.listener=listener;\r}\rpublic void printlen(String s) {\rSystem.out.println(s);\rif(listener!=null) {\rlistener.print();\r}\r}\r}\r第三步实现监听事件接口 public class PrintListenerDemo implements PrintListener {\r@Override\rpublic void print() {\rSystem.out.println(\u0026amp;quot;监听到输出事件\u0026amp;quot;);\r}\r}\r测试 public class Test {\rpublic static void main(String[] args) {\r//新建一个默认输出类\rOut b=new Out();\rb.printlen(\u0026amp;quot;这里不会被监听到输出事件\u0026amp;quot;);\t//新建一个输出类,为输出类添加一个输出监听事件\rOut b1=new Out(new PrintListenerDemo());\rb1.printlen(\u0026amp;quot;这里输出后会被监听到输出事件\u0026amp;quot;);\r}\r}\r结果 监听事件使用  在javaweb中,不论与ServletContext,HttpSession,ServletRequest相关的监听接口\n  开发者只需要直接实现这些监听接口事件,其他的源码别人己经写好了,我们不用关心它是如何实现\n 回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"0a9c72e6271ed6e6ad8c6bdcd937d01e","permalink":"/javadir/basedir/jsp_dir/java_%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/","publishdate":"2021-04-15T00:00:00Z","title":"java_监听事件原理 "},{"content":"EL基础教程 El标签语法  ${参数名}\n EL标签的功能   可以访问JSP中不同的域的对象    可以访问JavaBean中的属性    可以访问集合元素    支持简单的运算操作   访问JSP中不同的域的对象 \u0026amp;lt;%\rpageContext.setAttribute(\u0026amp;quot;name1\u0026amp;quot;, \u0026amp;quot;zhangsan\u0026amp;quot;);\rrequest.setAttribute(\u0026amp;quot;name2\u0026amp;quot;, \u0026amp;quot;lisi\u0026amp;quot;);\rsession.setAttribute(\u0026amp;quot;name3\u0026amp;quot;, \u0026amp;quot;wangwu\u0026amp;quot;);\rapplication.setAttribute(\u0026amp;quot;name4\u0026amp;quot;, \u0026amp;quot;liuliu\u0026amp;quot;);\r%\u0026amp;gt;\r\u0026amp;lt;!--范围.参数名 --\u0026amp;gt;\r${pageScope.name1 } ${requestScope.name2 } ${sessionScope.name3 }\r${applicationScope.name4 }\r\u0026amp;lt;br\u0026amp;gt;\r\u0026amp;lt;!-- 直接写参数名称 --\u0026amp;gt;\r${name1 } ${name2 } ${name3 } ${name4 }\r 访问JavaBean中的属性 \u0026amp;lt;%\rUser user=new User(\u0026amp;quot;zhangsan\u0026amp;quot;,20,\u0026amp;quot;北京\u0026amp;quot;);\rrequest.setAttribute(\u0026amp;quot;user\u0026amp;quot;, user);\r%\u0026amp;gt;\ruser name:${user.name }\u0026amp;lt;br\u0026amp;gt; user age:${user.age }\u0026amp;lt;br\u0026amp;gt; user address:${user.address }\r 访问集合元素 \u0026amp;lt;%\r//数组\rint[] array=new int[]{1,2,3};\r//列表\rList list=new ArrayList();\rlist.add(\u0026amp;quot;list1\u0026amp;quot;);\rlist.add(20);\rlist.add(true);\rpageContext.setAttribute(\u0026amp;quot;array\u0026amp;quot;, array);\rpageContext.setAttribute(\u0026amp;quot;list\u0026amp;quot;, list);\r%\u0026amp;gt;\r数组:${array[0] },${array[1] },${array[2] }\u0026amp;lt;br\u0026amp;gt; List列表:${list }\u0026amp;lt;br\u0026amp;gt;\r 简单的运算操作 算术运算符:\n2+3=${2+3 }\r2-3=${2-3 }\r2*3=${2*3 }\r2/3=${2/3 }\r 逻辑运算符:\ntrue\u0026amp;amp;\u0026amp;amp;false=${true\u0026amp;amp;\u0026amp;amp;false }\ttrue||false=${true||false }\t!true=${!true }\t 关系运算符:\n2==5 ${2==5 }\r2!=5 ${2!=5 }\r2\u0026amp;gt;5 ${2\u0026amp;gt;5 }\r2\u0026amp;lt;5 ${2\u0026amp;lt;5 }\r2\u0026amp;gt;=5 ${2\u0026amp;gt;=5 }\r2\u0026amp;lt;=5 ${2\u0026amp;lt;=5 }\r 其他运算符:\n\u0026amp;lt;%\rUser user=new User();\rUser user1=new User(\u0026amp;quot;zhangsan\u0026amp;quot;,20,\u0026amp;quot;北京\u0026amp;quot;);\rString arr=new String();\rString[] arr1=new String[]{\u0026amp;quot;one\u0026amp;quot;,\u0026amp;quot;two\u0026amp;quot;};\tpageContext.setAttribute(\u0026amp;quot;user\u0026amp;quot;, user);\rpageContext.setAttribute(\u0026amp;quot;user1\u0026amp;quot;, user1);\rpageContext.setAttribute(\u0026amp;quot;arr\u0026amp;quot;, arr);\tpageContext.setAttribute(\u0026amp;quot;arr1\u0026amp;quot;, arr1);\r%\u0026amp;gt;\ruser 是否为空:${empty user }\rarr 是否为空:${empty arr }\ruser1 是否为空:${empty user1 }\rarr1 是否为空:${empty arr1 }\r三元目运算符2\u0026amp;lt;5?yes:no:${2\u0026amp;lt;5?\u0026amp;quot;yes\u0026amp;quot;:\u0026amp;quot;no\u0026amp;quot; }\ruser1.address:${user1.address }\rarr1[1]:${arr1[1] }\r EL标签的隐 …","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"b05247f84f94dc4c3636c2c0f2155f5a","permalink":"/javadir/basedir/jsp_dir/jsp_el%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","publishdate":"2021-04-15T00:00:00Z","title":"EL基础教程 "},{"content":"JSTL标签库 JSTL主要有五大类标签库\n core标签库(核心标签库),包括通用标签(输出标签),流程控制和循环控制标签 fmt标签库,包括格式化,国际格式化标签等 fn标签库,函数标签库 XML标签库,关于XML操作的标签库 SQL标签库,操作数据库标签  core标签库用法 使用core标签前必须添加taglie指令\n %@ taglib prefix=\u0026amp;ldquo;c\u0026amp;rdquo; uri=\u0026amp;ldquo;http://java.sun.com/jsp/jstl/core\u0026amp;quot; %\u0026amp;gt;\n  \u0026amp;lt;c:set\u0026amp;gt;在某个范围设定某个值   \u0026amp;lt;c:set value=\u0026amp;ldquo;表达式\u0026amp;rdquo; var=\u0026amp;ldquo;varname\u0026amp;rdquo; [scope=\u0026amp;ldquo;request|page|session|application\u0026amp;rdquo;]\u0026amp;gt;\u0026amp;lt;/c:set\u0026amp;gt;\n \u0026amp;lt;c:set value=\u0026amp;quot;${1+2 }\u0026amp;quot; var=\u0026amp;quot;variable\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:set\u0026amp;gt;\r${variable }\r \u0026amp;lt;c:out\u0026amp;gt;把表达式的结构输出到页面中   \u0026amp;lt;c:out value=\u0026amp;ldquo;表达式\u0026amp;rdquo; [escapeXml=\u0026amp;ldquo;true|false\u0026amp;rdquo;]\u0026amp;gt;\u0026amp;lt;/c:out\u0026amp;gt;\n \u0026amp;lt;c:set value=\u0026amp;quot;${1+2 }\u0026amp;quot; var=\u0026amp;quot;variable\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:set\u0026amp;gt;\r\u0026amp;lt;c:out value=\u0026amp;quot;${variable }\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:out\u0026amp;gt;\r \u0026amp;lt;c:if\u0026amp;gt;条件判断   \u0026amp;lt;c:if test=\u0026amp;ldquo;判断条件\u0026amp;rdquo; [var=\u0026amp;ldquo;varname\u0026amp;rdquo;] [scope=\u0026amp;ldquo;request|page|session|application\u0026amp;rdquo;]\u0026amp;gt; 条件为真执行的语句 \u0026amp;lt;/c:if\u0026amp;gt;\n \u0026amp;lt;c:if test=\u0026amp;quot;${1\u0026amp;lt;2 }\u0026amp;quot; var=\u0026amp;quot;result\u0026amp;quot;\u0026amp;gt;\r\u0026amp;lt;c:out value=\u0026amp;quot;${result }\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:out\u0026amp;gt;\r\u0026amp;lt;/c:if\u0026amp;gt;\r \u0026amp;lt;c:choose\u0026amp;gt;,\u0026amp;lt;c:when\u0026amp;gt;,\u0026amp;lt;c:otherwise\u0026amp;gt;流程控制标签   \u0026amp;lt;c:choose\u0026amp;gt; \u0026amp;lt;c:when test=\u0026amp;ldquo;表达式\u0026amp;rdquo;\u0026amp;gt; 表达式为真执行的语句 \u0026amp;lt;/c:when\u0026amp;gt; [\u0026amp;lt;c:otherwise\u0026amp;gt; 表达式为假执行的语句 \u0026amp;lt;/c:otherwise\u0026amp;gt;] \u0026amp;lt;/c:choose\u0026amp;gt;\n  \u0026amp;lt;c:when\u0026amp;gt;必须在\u0026amp;lt;c:otherwise\u0026amp;gt;前边,\u0026amp;lt;c:choose\u0026amp;gt;可以添加多个\u0026amp;lt;c:choose\u0026amp;gt;,类似于if else if写法\n \u0026amp;lt;c:set value=\u0026amp;quot;8\u0026amp;quot; var=\u0026amp;quot;variable1\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:set\u0026amp;gt;\r\u0026amp;lt;c:set value=\u0026amp;quot;9\u0026amp;quot; var=\u0026amp;quot;variable2\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:set\u0026amp;gt;\r\u0026amp;lt;c:choose\u0026amp;gt;\r\u0026amp;lt;c:when test=\u0026amp;quot;${variable1%2==0 }\u0026amp;quot;\u0026amp;gt;\r\u0026amp;lt;c:out value=\u0026amp;quot;variable1:偶数\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:out\u0026amp;gt;\r\u0026amp;lt;c:choose\u0026amp;gt;\r\u0026amp;lt;c:when test=\u0026amp;quot;${variable2%2==0 }\u0026amp;quot;\u0026amp;gt;\r\u0026amp;lt;c:out value=\u0026amp;quot;variable2:偶数\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:out\u0026amp;gt;\r\u0026amp;lt;/c:when\u0026amp;gt;\r\u0026amp;lt;c:otherwise\u0026amp;gt;\r\u0026amp;lt;c:out value=\u0026amp;quot;variable2:奇数\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:out\u0026amp;gt;\r\u0026amp;lt;/c:otherwise\u0026amp;gt;\r\u0026amp;lt;/c:choose\u0026amp;gt;\r\u0026amp;lt;/c:when\u0026amp;gt;\r\u0026amp;lt;c:otherwise\u0026amp;gt;\r\u0026amp;lt;c:out value=\u0026amp;quot;variable1:奇 …","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"67c7354088da79774cc410db175014a0","permalink":"/javadir/basedir/jsp_dir/jsp_jstl_core%E6%A0%87%E7%AD%BE%E5%BA%93/","publishdate":"2021-04-15T00:00:00Z","title":"jsp jstl core 标签库 "},{"content":"Session  HTTP是无状态协议，这意味着每次客户端检索网页时，都要单独打开一个服务器连接，因此服务器不会记录下先前客户端请求的任何信息   会话,当用户打开一个浏览器连接到web应用或者打开某个页面,直到关闭浏览器这个过程叫做会话   Session是保存在服务器上的数据结构，用于跟踪用户的状态。此数据可以保存在群集、数据库、文件中  Session常用方法   public boolean isNew()\n返回是否为一个新的客户端，或者客户端是否拒绝加入session     public Enumeration getAttributeNames()\n返回session对象中所有的对象名称     public int getMaxInactiveInterval()\n返回最大时间间隔，以秒为单位，servlet 容器将会在这段时间内保持会话打开     public long getCreationTime()\n返回session对象被创建的时间， 以毫秒为单位，从1970年1月1号凌晨开始算起     public long getLastAccessedTime()\n返回客户端最后访问的时间，以毫秒为单位，从1970年1月1号凌晨开始算起     public Object getAttribute(String name)\n返回session对象中与指定名称绑定的对象，如果不存在则返回null     public Object getAttribute(String name)\n返回session对象中与指定名称绑定的对象，如果不存在则返回null     public String getId()\n返回session对象的ID     public void invalidate()\n将session无效化，解绑任何与该session绑定的对象     public void removeAttribute(String name)\n移除session中指定名称的对象     public void setAttribute(String name, Object value)\n使用指定的名称和值来产生一个对象并绑定到session中     public void setMaxInactiveInterval(int interval)\n用来指定时间，以秒为单位，servlet容器将会在这段时间内保持会话有效   Session应用 新建SessionDemo类 @WebServlet(\u0026amp;quot;/SessionDemo\u0026amp;quot;)\rpublic class SessionDemo extends HttpServlet {\rprivate int count=0;\rprotected void doGet(HttpServletRequest request, HttpServletResponse response)\rthrows ServletException, IOException {\rrequest.setCharacterEncoding(\u0026amp;quot;utf-8\u0026amp;quot;);\rresponse.setCharacterEncoding(\u0026amp;quot;utf-8\u0026amp;quot;);\rcount++;\rHttpSession session = request.getSession();\rString id = session.getId();\rlong startTime = session.getCreationTime();\rlong lastTime = session.getLastAccessedTime();\rlong validTime = session.getMaxInactiveInterval();\rsession.setMaxInactiveInterval(60);\rSimpleDateFormat myFormat=new SimpleDateFormat(\u0026amp;quot;yyyy/MM/dd HH:mm:ss\u0026amp;quot;);\rresponse.setContentType(\u0026amp;quot;text/html\u0026amp;quot;);\rPrintWriter out = response.getWriter();\rout.println(\u0026amp;quot;\u0026amp;lt;!DOCTYPE HTML PUBLIC \\\u0026amp;quot;-\rout.println(\u0026amp;quot;\u0026amp;lt;HTML\u0026amp;gt;\u0026amp;quot;);\rout.println(\u0026amp;quot; \u0026amp;lt;HEAD\u0026amp;gt;\u0026amp;lt;TITLE\u0026amp;gt;A Servlet\u0026amp;lt;/TITLE\u0026amp;gt;\u0026amp;lt;/HEAD\u0026amp;gt;\u0026amp;quot;); …","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"cb16942f8b6bf776215c719750ac02e5","permalink":"/javadir/basedir/jsp_dir/jsp_jstl_session/","publishdate":"2021-04-15T00:00:00Z","title":"jsp jstl session "},{"content":"字符串el表达式 fn:contains 判断字符串是否包含另外一个字符串 \u0026amp;lt;c:if test=\u0026amp;quot;${fn:contains(name, searchString)}\u0026amp;quot;\u0026amp;gt;\rfn:containsIgnoreCase 判断字符串是否包含另外一个字符串(大小写无关) \u0026amp;lt;c:if test=\u0026amp;quot;${fn:containsIgnoreCase(name, searchString)}\u0026amp;quot;\u0026amp;gt;\rfn:endsWith 判断字符串是否以另外字符串结束 \u0026amp;lt;c:if test=\u0026amp;quot;${fn:endsWith(filename, \u0026amp;quot;.txt\u0026amp;quot;)}\u0026amp;quot;\u0026amp;gt;\rfn:escapeXml 把一些字符转成XML表示，例如 \u0026amp;lt;字符应该转为\u0026amp;lt; ${fn:escapeXml(param:info)}\rfn:indexOf 子字符串在母字符串中出现的位置 ${fn:indexOf(name, \u0026amp;quot;-\u0026amp;quot;)}\rfn:join 将数组中的数据联合成一个新字符串，并使用指定字符格开 ${fn:join(array, \u0026amp;quot;;\u0026amp;quot;)}\rfn:length 获取字符串的长度，或者数组的大小 ${fn:length(shoppingCart.products)}\rfn:replace 替换字符串中指定的字符 ${fn:replace(text, \u0026amp;quot;-\u0026amp;quot;, \u0026amp;quot;?\u0026amp;quot;)}\rfn:split 把字符串按照指定字符切分 ${fn:split(customerNames, \u0026amp;quot;;\u0026amp;quot;)}\rfn:startsWith 判断字符串是否以某个子串开始 \u0026amp;lt;c:if test=\u0026amp;quot;${fn:startsWith(product.id, \u0026amp;quot;100-\u0026amp;quot;)}\u0026amp;quot;\u0026amp;gt;\rfn:substring 获取子串 ${fn:substring(zip, 6, -1)}\rfn:substringAfter 获取从某个字符所在位置开始的子串 ${fn:substringAfter(zip, \u0026amp;quot;-\u0026amp;quot;)}\rfn:substringBefore 获取从开始到某个字符所在位置的子串 ${fn:substringBefore(zip, \u0026amp;quot;-\u0026amp;quot;)}\rfn:toLowerCase 转为小写 ${fn.toLowerCase(product.name)}\rfn:toUpperCase 转为大写字符 ${fn.UpperCase(product.name)}\rfn:trim 去除字符串前后的空格 ${fn.trim(name)}\r函数 描述\rfn:contains(string, substring)\r如果参数string中包含参数substring，返回true\rfn:containsIgnoreCase(string, substring)\r如果参数string中包含参数substring（忽略大小写），返回true\rfn:endsWith(string, suffix)\r如果参数 string 以参数suffix结尾，返回true\rfn:escapeXml(string)\r将有特殊意义的XML (和HTML)转换为对应的XML character entity code，并返回\rfn:indexOf(string, substring)\r返回参数substring在参数string中第一次出现的位置\rfn:join(array, separator)\r将一个给定的数组array用给定的间隔符separator串在一起，组成一个新的字符串并返回。\rfn:length(item)\r返回参数item中包含元素的数量。参数Item类型是数组、collection或者String。如果是String类型,返回值是String中的字符数。\rfn:replace(string, before, after)\r返回一个String对象。用参数after字符串替换参数string中所有出现参数before字符串的地方，并返回替换后的结果 fn:split(string, separator)\r返回一个数组，以参数separator 为分割符分割参数string，分割后的每一部分就是数组的一个元素\rfn:startsWith(string, prefix)\r如果参数string以参数prefix开头，返回true\rfn:substring(string, begin, end)\r返回参数string部分字符串, 从参数begin开始到参数end位置，包括end位置 …","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"b3bd90bd490d6882d00aaa9202ffbdad","permalink":"/javadir/basedir/jsp_dir/jsp_%E5%AD%97%E7%AC%A6%E4%B8%B2el%E8%A1%A8%E8%BE%BE%E5%BC%8F/","publishdate":"2021-04-15T00:00:00Z","title":"字符串el表达式 "},{"content":" Groovy是一种面向对象的动态类型语言，跟Java一样运行在JVM上。\n（注：给Java静态世界带来动态能力的语言）\n 目录   groovy中对象的比较以及非空判断\n  groovy使用场景\n  groovy变量\n  groovy变量和数据类型加强\n  groovy基本概念\n  groovy学习\n  groovy数据类型\n  如何在groovy中获取以另一个变量命名的变量的值\n  回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"711870becbcd2483fa205d128bbea172","permalink":"/javadir/groovy/","publishdate":"2021-04-15T00:00:00Z","title":"groovy 学习与使用 "},{"content":"groovy 对象比较以及空判断  目前测试得知 groovy的比较貌似很多直接可以使用==来比较\n groovy对象的比较 1.字符串比较 def str1 = \u0026amp;quot;Hello World1\u0026amp;quot;\rif (\u0026amp;quot;Hello World\u0026amp;quot; == str1) {\rprintln \u0026amp;quot;Hello World\u0026amp;quot;\r} else {\rprintln \u0026amp;quot;不匹配\u0026amp;quot;\r}\r2.map集合的比较（list集合也可以这样比较） \tdef m1=[\u0026amp;quot;name\u0026amp;quot;:\u0026amp;quot;李明\u0026amp;quot;,\u0026amp;quot;age\u0026amp;quot;:20]\rdef m2=[\u0026amp;quot;name\u0026amp;quot;:\u0026amp;quot;李明\u0026amp;quot;,\u0026amp;quot;age\u0026amp;quot;:21]\rdef m3=[\u0026amp;quot;name\u0026amp;quot;:\u0026amp;quot;李明\u0026amp;quot;,\u0026amp;quot;age\u0026amp;quot;:21]\rif(m1==m2){\rprintln \u0026amp;quot;m1和m2匹配\u0026amp;quot;\r}else{\rprintln \u0026amp;quot;m1和m2不匹配\u0026amp;quot;\r}\r  特别是字符串的比较，是不是比java要简洁的多呢\n  如果要比较两个对象的引用是否相同在groovy中可以使用is\n  def list1 = []\rdef list2 = [1,2,3,4]\rboolean check = list1.is(list2) ;\rprintln(check)\rif 判断对象是否为空  groovy中判断对象是否为空，直接if(对象){}即可，这种便捷真的很强  def list1 = []\rdef list2 = [1,2,3,4]\r//直接写入 有点像C语言里面if可以直接把0,和非0作为boolean来比较\rif (!list1){\rprintln(\u0026amp;quot;list1为null\u0026amp;quot;) ;\r}\rif (list2){\rprintln(\u0026amp;quot;list2不为null\u0026amp;quot;) ;\r}\r 特殊判断法  //def m5 = [name:\u0026amp;quot;a\u0026amp;quot;];\rdef m5 = [];\rprintln \u0026amp;quot;${m5?.name}\u0026amp;quot; ;\r//注意目前我用list失败了\rprintln \u0026amp;quot;${list1?.get(0)}\u0026amp;quot; ; //报error 数组越界 因此这种写法只适合map\r回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"06a236cbba352126246fb1b6b9ec1fd0","permalink":"/javadir/groovy/groovy%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%E4%BB%A5%E5%8F%8A%E9%9D%9E%E7%A9%BA%E5%88%A4%E6%96%AD/","publishdate":"2021-04-15T00:00:00Z","title":" groovy对象比较以及空判断 "},{"content":"groovy 使用场景 Groovy可以用于多种情况。比如   1、作为shell脚本语言完成数据处理和文件操作任务。\n  2、在Java或者Java EE应用程序中嵌入Groovy，实现Java和Groovy的集成。（这样有助于编写和集中处理经常变化的业务逻辑，或者给应用程序架构提供可编程的配置管理能力。）\n  Groovy是增强Java平台的唯一的脚本语言。  它提供了类似于Java的语法，内置映射（Map）、列表（List）、方法、类、闭包（closure）以及生成器。  脚本语言与系统编程语言：  脚本语言不会替代系统编程语言，两者是相互补充的。\n 系统编程语言的目的：   开发复杂的算法或者数据结构\n  实现计算密集型应用\n  操作大型数据集\n  实现定义良好的、变更缓慢的需求\n  脚本语言应用的目的：   连接已有的组件\n  处理经常变化的多种类型的实体\n  具有图形化用户界面\n  拥有快速变化的功能\n  Java编译器会产生可以在Java虚拟机上运行的字节码。 Groovy类和Java是二进制兼容的。 Groovy编译器产生的字节码与Java编译器产生的字节码是完全一样的。 ——对于JVM而言，Groovy和Java是完全一样的。 因此，Groovy能够完全使用各种Java API。 Groovy是一门面向对象的语言。也就是说，Groovy中每一个事物最终都会被当做某些类 的一个实例对象。 回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"95b0d2fdad210ef4997b78f4754712ff","permalink":"/javadir/groovy/groovy%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","publishdate":"2021-04-15T00:00:00Z","title":" groovy使用场景 "},{"content":"Groovy 变量  Groovy中的变量可以通过两种方式定义 - 使用数据类型的本地语法，或者使用def关键字。对于变量定义，必须明确提供类型名称或在替换中使用“def”。这是Groovy解析器需要的。\n   byte - 这用于表示字节值。例如2。\n  short - 用于表示一个短数。例如10。\n  int - 这用于表示整数。 例如1234。\n  long - 这用于表示一个长数。例如10000090。\n  float - 用于表示32位浮点数。例如12.34。\n  double - 这用于表示64位浮点数。例如12.3456565。\n  char - 这定义了单个字符文字。例如\u0026amp;rsquo;a\u0026#39;。\n  Boolean - 这表示一个布尔值，可以是true或false。\n  String - 这是以字符串形式表示的文本。 例如“Hello World”。\n  Groovy还允许其他类型的变量，如数组，结构和类\n  变量声明  title: \u0026amp;quot; groovy变量 \u0026amp;quot; date: 2021-04-15 draft: false weight: 3   变量声明告诉编译器为变量创建存储的位置和大小。\n  下面是一个变量声明的例子 -\n  // x is defined as a variable String x = \u0026amp;quot;Hello\u0026amp;quot;;\r// The value of the variable is printed to the console println(x);\r 当我们运行上面的程序，我们会得到以下结果   Hello  变量命名  变量的名称可以由字母，数字和下划线字符组成。 它必须以字母或下划线开头。 大写和小写字母是不同的，因为Groovy，就像Java是一种区分大小写的编程语言。  // Defining a variable in lowercase int x = 5;\r// Defining a variable in uppercase int X = 6; // Defining a variable with the underscore in it\u0026#39;s name def _Name = \u0026amp;quot;Joe\u0026amp;quot;; println(x); println(X); println(_Name); 5\r6\rJoe\r你好,世界 !\r 除此之外 在groovy中 定义变量也是可以不加 def 或者 基本类型   a = 125;\n回到上一级 ","date":-62135596800,"description":"","objectID":"c54e650df24e4d0fc0e480f3bce6dbad","permalink":"/javadir/groovy/groovy%E5%8F%98%E9%87%8F/","title":""},{"content":"groovy 变量和数据类型 groovy类型自动推断  先看有一段代码  def a = 12;\rdef int a1 = 12;\rdef a_type = a instanceof Integer ;\rdef a1_type = a1 instanceof Integer ;\rprintln(a_type) ;\rprintln(a1_type) ;\r//打印结果如下\rtrue\rtrue\r 从上面我们可以看出a和a1实际推导出的类型是一样的,但是有哪些不同呢 接着我把上面的例子改了  def a = 12;\rdef int a1 = 12;\rdef a_type = a instanceof Integer ;\rdef a1_type = a1 instanceof Integer ;\rprintln(a_type) ;\rprintln(a1_type) ;\ra = 52253.46f ;\ra1 = 52253.46f ;\rprintln(a instanceof Integer) ;\rprintln(a1 instanceof Integer) ;\rprintln(\u0026amp;quot;a1 的值:\u0026amp;quot;+a1) ;\rprintln(\u0026amp;quot;a 的 值 :\u0026amp;quot;+a) ;\r//print result\rtrue\rtrue\rfalse\rtrue\ra1 的值:52253\ra 的 值 :52253.46\r  看吧神奇的事情出来了, a1 的 参数类型即便被赋值了浮点数但是类型并没有改变,并且精度和赋值的值相比降低了,而 a 的类型却改变了\n另外假如在idea中编辑变量 编辑器也会提示你\rAssignment is not used less... (Ctrl+F1) Inspection info: Reports on unnecessary Groovy assignment statement Possible loss of precision from \u0026#39;Float\u0026#39; to \u0026#39;int\u0026#39; less... (Ctrl+F1) Inspection info: Reports assignments with incompatible types\r  假如接着上面的例子给 a变量和a1变量分别赋值字符串类型会怎样呢 (算了还是重新写吧好看点)\n  int b = 141;\rx = 141;\rprintln(b) ;\rprintln(x) ;\rb = \u0026amp;quot;字符串b\u0026amp;quot; ;\rx = \u0026amp;quot;字符串x\u0026amp;quot; ;\rprintln(b) ;\rprintln(x) ;\r//运行会怎样呢?\r141\rCaught: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object \u0026#39;字符串b\u0026#39; with class \u0026#39;java.lang.String\u0026#39; to class \u0026#39;int\u0026#39;\r141\rorg.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object \u0026#39;字符串b\u0026#39; with class \u0026#39;java.lang.String\u0026#39; to class \u0026#39;int\u0026#39;\rat gr.h1.t4.run(t4.groovy:10)\r  以上我们可以看出在groovy中赋值的时候系统会尝试强转类型,上面的例子是转失败的情况\n  因此在定义变量的时候尽量不要去更改已经定义的变量的类型,尽量 申明变量类型\n  变量的类型检测方法\n  var_name instanceof type 如 a instanceof Integer\n  b.class == Integer 或 b.class.equals(Integer)\n  回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"13bb336a1140664d66bb48129bbc56c5","permalink":"/javadir/groovy/groovy%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8A%A0%E5%BC%BA/","publishdate":"2021-04-15T00:00:00Z","title":" groovy变量和数据类型 "},{"content":"groovy 基本概念 1、基本概念  Groovy是一种面向对象的动态类型语言，跟Java一样运行在JVM上。\n（注：给Java静态世界带来动态能力的语言）\n   与Java不同的语言特性：\n  a) 函数字面值\n  b) 对集合的一等支持\n  c) 对正则表达式的一等支持\n  d) 对XML处理的一等支持\n  （注：所谓“一等”指的是内置到语言的语法中，不需要调用类库。）\n  2:Groovy能解决包括：   快速Web开发\n  原型设计\n  脚本处理\n  等问题，这些使用Java不是解决动态层问题的理想语言。\n  例如:\nSystem.out.println(\u0026amp;quot;It\u0026#39;s a Groovy baby, yeah!\u0026amp;quot;);\rdef writer = new StringWriter();\rdef xml = new groovy.xml.MarkupBuilder(writer);\rxml.person(id:2){\rname \u0026#39;kobicc\u0026#39;\rage 1\r}\rprintln writer.toString();\r回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"9334bd0b6924c951f394cf96bb15c3da","permalink":"/javadir/groovy/groovy%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","publishdate":"2021-04-15T00:00:00Z","title":"groovy 基本概念 "},{"content":"Groovy 概述  Groovy是一种基于Java平台的面向对象语言。 Groovy 1.0于2007年1月2日发布，其中Groovy 2.4是当前的主要版本。 Groovy通过Apache License v 2.0发布。  Groovy的特点  同时支持静态和动态类型。 支持运算符重载。 本地语法列表和关联数组。 对正则表达式的本地支持。 各种标记语言，如XML和HTML原生支持。 Groovy对于Java开发人员来说很简单，因为Java和Groovy的语法非常相似。 您可以使用现有的Java库。 Groovy扩展了java.lang.Object。  groovy-脚本和类   在groovy中定义类和java中是一样的。类的方法可以是static，也可以是非static的\n  groovy中的方法可以是public, protected, private，同时也支持java中的修饰符，比如synchronized\n  groovy自动导入的包有以下这些\n   groovy.lang.* groovy.util.* java.lang.* java.util.* java.net.* java.io.* import java.math.BigInteger import java.math.BigDecimal    在groovy和java中不同的一点就是，groovy默认是public的\n  每一个groovy类，在JVM层级，都是字节码形式的java code，所以在java代码中可以调用groovy中申明的方法，反之亦然\n  你可以指定方法的参数和返回值，以便他们能够更好的和java代码相互调用。当然你也可以实现接口或者重载方法。但是需要你没有指定方法后者属性的类型的话，那么在JVM层级的字节码中，他们将会是 java.lang.Object 类型\n  例如 Callee.groovy\n  class Callee{\rvoid hello(){\rprintln \u0026amp;quot;hello, world\u0026amp;quot; ;\r}\r}\rc = new Callee() ;\rc.hello();\r 创建你的第一个 Hello World 程序  class Example1 {\rpublic static void main(String[] args) {\rprintln(\u0026amp;quot;你好,世界 !\u0026amp;quot;) ;\r}\r}\r你好,世界 !\n 当然你也可以不定义一个类 因为groovy中行得通  println(\u0026amp;quot;你好,世界 !\u0026amp;quot;) ;同样可以打印出字符串  在 Groovy 中导入语句  import 语句可以用来导入，可以让你的代码使用其他库的功能。这是通过使用在 Import 关键字完成。 下面的示例演示了如何使用 MarkupBuilder 的类，它可能是最常用的创建 HTML 或 XML 标记的类之一。  import groovy.xml.MarkupBuilder def xml = new MarkupBuilder() Groovy 令牌   令牌可以是一个关键字，一个标识符，常量，字符串文字或符号。 println(“Hello World”);\n  在上面的代码行中，有两个令牌，首先是关键词的 println 而接下来就是字符串的“Hello World”。\n  Groovy 注释  在您的代码中使用注释。Groovy 的注释可以是单行或多行。单行注释使用 // 在该行的任何位置来识别。一个例子如下所示 -  class Example {\rstatic void main(String[] args) {\r// Using a simple println statement to print output to the console\rprintln(\u0026#39;Hello World\u0026#39;);\r}\r}\r分号  就像 Java 编程语言，它需要具有分号在 Groovy 定义多个语句之间进行区分。  class Example {\rstatic void main(String[] args) {\r// One can see the use of a semi-colon after each statement\rdef x = 5;\rprintln(\u0026#39;Hello World\u0026#39;); }\r}\r身份标识  标识符被用来定义变量，函数或其他用户定义的变量。标识符以字母开头，美元或下划线。他们不能以数字开头。以下是有效标识符的一些例子  def employeename def student1 def student_name\r 其中**，DEF** 是在 Groovy 用来定义标识符的关键字。下 …","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"d3c1e29be5f1f7b207624b44db45931e","permalink":"/javadir/groovy/groovy%E5%AD%A6%E4%B9%A0/","publishdate":"2021-04-15T00:00:00Z","title":" Groovy 概述 "},{"content":"Groovy 数据类型  在任何编程语言中，需要使用各种变量来存储各种类型的信息。变量只是保留值的存储位置,这意味着，当你创建一个变量，你保留在内存中的一些空间来存储与变量相关的值。\n  您可能喜欢存储各种数据类型的信息，如字符串，字符，宽字符，整数，浮点数，布尔值等。基于变量的数据类型，操作系统分配内存并决定什么可以存储在保留的存储器中。\n 内置数据类型  byte -这是用来表示字节值。例如2。 short -这是用来表示一个短整型。例如10。 int -这是用来表示整数。例如1234。 long -这是用来表示一个长整型。例如10000090。 float -这是用来表示32位浮点数。例如12.34。 double -这是用来表示64位浮点数，这些数字是有时可能需要的更长的十进制数表示。例如12.3456565。 char -这定义了单个字符文字。例如“A”。 Boolean -这表示一个布尔值，可以是true或false。 String -这些是以字符串的形式表示的文本。例如，“Hello World”的  绑定值    类型 值     byte -128到127   short -32,768到32,767   int 2,147,483,648 到,147,483,647   long -9,223,372,036,854,775,808到+9,223,372,036,854,775,807   float 1.40129846432481707e-45到3.40282346638528860e + 38   double 4.94065645841246544e-324d 到1.79769313486231570e + 308d    包装器类型  java.lang.Byte java.lang.Short java.lang.Integer java.lang.Long java.lang.Float java.lang.Double     名称 描述 例如     java.math.BigInteger 不可变的任意精度的有符号整数数字 30克   java.math.BigDecimal 不可变的任意精度的有符号十进制数 3.5克    package gr.h1\r//Example of a int datatype\rint x = 5;\r//Example of a long datatype\rlong y = 100L;\r//Example of a floating point datatype\rfloat a = 10.56f;\r//Example of a double datatype\rdouble b = 10.5e40;\r//Example of a BigInteger datatype\rBigInteger bi = 30g;\r//Example of a BigDecimal datatype\rBigDecimal bd = 3.5g; //加上这个g也没事的 这是groovy特有的如java中的double a = 3.232d\rBigDecimal bd2 = 235.2323552;\rprintln(x);\rprintln(y);\rprintln(a);\rprintln(b);\rprintln(bi);\rprintln(bd);\rprintln(bd2);\r5\r100\r10.56\r1.05E41\r30\r3.5\r235.2323552\r回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"d972fe005bc7819fab06b5afe14effc1","permalink":"/javadir/groovy/groovy%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","publishdate":"2021-04-15T00:00:00Z","title":"groovy 数据类型 "},{"content":"groovy变量值获取 `\nhttps://www.codenong.com/34288451/\n`\n回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"894f1cb1d2331e05973f25f3af04075a","permalink":"/javadir/groovy/%E5%A6%82%E4%BD%95%E5%9C%A8groovy%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%BB%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/","publishdate":"2021-04-15T00:00:00Z","title":" groovy变量值获取 "},{"content":" Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\n 目录   linux基础命令\n  nginx学习与使用\n  host映射\n  Linux下设置和查看环境变量\n  Ubuntu清理系统垃圾\n  Notepad++安装\n  ubuntu 安装chmsee\n  ubuntu软件卸载\n  Ubuntu 16.04修改hosts\n  git命令\n  git配置\n  ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"f65239f4c33cc08efa2df4c2c7112bb7","permalink":"/javadir/linux/","publishdate":"2021-04-15T00:00:00Z","title":"linux 学习与使用 "},{"content":"git学习 git 区域概念  git分为工作区(我们自己的file)和版本库这其中版本库又包含暂存区(Stage)和分支区(master)    git add ********** 把文件添加到仓库\n  git reset README.md 取消提交到暂存区域\n  git commmit -m \u0026amp;lsquo;xxxx\u0026amp;rsquo; 提交到仓库\n  git diff 查看提交到仓库文件之后文件又被修改的变化\n  git status 查看状态\n  git rm -f gitS.md 强制删除\n  git log 显示从最近到最远的提交日志\n  git log \u0026amp;ndash;pretty=oneline 只显示版本号\n  关于版本回退问题   git reset \u0026amp;ndash;hard HEAD^ 版本重置为上一个版本\n  git 关于版本处理进行了设置\n  git reset \u0026amp;ndash;hard HEAD^　重置为上一个版本\n   这里解释下HEAD表示当前版本 如最新提交的版本号:3a451d666e6c952e1588117ef18933be489beb18 zch, 上上一个版本就是HEAD^^ 那么假如是重置为上上一个版本那么命令就是git reset \u0026amp;ndash;hard HEAD^^ 那么假如说有100个版本呢?当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 如:git reset \u0026amp;ndash;hard HEAD~50 往上５０个版本 当然了如果记得具体版本号当然更好了    git reset \u0026amp;ndash;hard 3a451d666e6c952e1588117ef18933be489beb18 这样就可以了,对了这的版本号其实可以不用写全,因为是linux嘛\n  git reflog 记录一天的命令(当天)\n  a249f45 HEAD@{0}: reset: moving to HEAD^\r545bb20 HEAD@{1}: commit: 2018年 03月 12日 星期一 10:17:56\ra249f45 HEAD@{2}: commit: append GPL\r3a451d6 HEAD@{3}: commit (initial): zch\r 你可以发现这里面包含当天所有操作的版本号(因为回退到某个版本之后那个版本号你再用git log就查找不出来了)   git log可以查看提交历史，以便确定要回退到哪个版本 git reflog查看命令历史，以便确定要回到未来的哪个版本。   (假如在工作区的内容已经做了修改与暂存区之间相比有了变化,并且你想要要丢弃这种变化,那么你可以)   git checkout \u0026amp;ndash; gitS.md 抛弃工作区所做的修改　那么工作区就被修改为与暂存区一样了 git checkout \u0026amp;ndash; file命令中的\u0026amp;ndash;很重要，没有\u0026amp;ndash;，就变成了“切换到另一个分支”的命令   关于删除文件\n  假如说你删除了当前工作区的某一个文件比如gitS.md   如进行了这个操作 rm gitS.md(linux 下) 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了(git status) 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令(git rm gitS.md) (git commit -m \u0026amp;lsquo;yes delete file\u0026amp;rsquo;) 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本 命令(git checkout \u0026amp;ndash; gitS.md)\n 分支(重点)  git checkout -b dev (创建dev分支，然后切换到dev分支)  git branch dev 创建分支dev\rgit checkout dev 切换到分支dev\r git branch命令查看当前分支   git branch命令会列出所有分支，当前分支前面会标一个*号\n * dev\rmaster\r 可以随便写点内容然后提交 git commit -m \u0026amp;lsquo;branch test\u0026amp;rsquo; 现在，dev分支的工作完成，我们就可以切换回master分支\n  git checkout master 切换到当前分支 (这时查看gitS.md刚刚随便写的内容并没有在file中)   　我们需要与当前分支合并\n  git merge dev (dev与master合并,master表示主分支)   cat gitS.md 就看到我们添加的内容了\n  再次查看当前分支 git branch …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"080e66bb8391464b894eac6d2d9d224b","permalink":"/javadir/linux/git_introduction/","publishdate":"2020-01-17T15:26:15Z","title":"git学习"},{"content":"zhou@zhou-Lenovo-Z480:~$ git version\rgit version 2.7.4\rzhou@zhou-Lenovo-Z480:~$ ssh -T git@github.com\rWarning: Permanently added the RSA host key for IP address \u0026#39;192.30.255.112\u0026#39; to the list of known hosts.\rPermission denied (publickey).\rzhou@zhou-Lenovo-Z480:~$ git config --global user.name \u0026amp;quot;zhouchenhua\u0026amp;quot;\rzhou@zhou-Lenovo-Z480:~$ git config --global user.email \u0026amp;quot;noatnu@163.com\u0026amp;quot;\rzhou@zhou-Lenovo-Z480:~$ git config --list\ruser.name=zhouchenhua\ruser.email=noatnu@163.com\rzhou@zhou-Lenovo-Z480:~$ ssh-keygen -C ‘noatnu@163.com’ -t rsa\rGenerating public/private rsa key pair.\rEnter file in which to save the key (/home/zhou/.ssh/id_rsa): america347191\rEnter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in america347191.\rYour public key has been saved in america347191.pub.\rThe key fingerprint is:\rSHA256:7WlMe5QL3eMrdG6b7BB/z66zSpwIOBRM0GTD4hK6BW4 ‘noatnu@163.com’\rThe key\u0026#39;s randomart image is:\r+---[RSA 2048]----+\r| .B* |\r|. . ..+o |\r|.o o .. |\r|.Eo .. . . . o |\r|.o . o S + = o |\r|. . = B.*.. |\r| B.Boo .|\r| . o.o+=.|\r| .=O*+|\r+----[SHA256]-----+\rroot@zhou-Lenovo-Z480:/home/zhou# cd ~/.ssh\rroot@zhou-Lenovo-Z480:~/.ssh# ls -a\r. .. id_rsa id_rsa.pub\rroot@zhou-Lenovo-Z480:~/.ssh# gedit id_rsa.pub 回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"c40b0ab5369c6dfc156a66e61b084eee","permalink":"/javadir/linux/gitub_config/","publishdate":"2020-01-17T15:26:15Z","title":"git配置"},{"content":"sudo vi hosts\n127.0.0.1\tlocalhost 127.0.1.1\tzhou-Lenovo-Z480\nThe following lines are desirable for IPv6 capable hosts ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters\n#pmcc dev 127.0.0.1 dev.pmcc.com\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"06a026ac6714c4801967cceb7a152d26","permalink":"/javadir/linux/host%E6%98%A0%E5%B0%84/","publishdate":"2020-01-17T15:26:15Z","title":"host映射"},{"content":"Linux的变量种类 按变量的生存周期来划分，Linux变量可分为两类： 1 永久的：需要修改配置文件，变量永久生效。 2 临时的：使用export命令声明即可，变量在关闭shell时失效。\n设置变量的三种方法 1 在/etc/profile文件中添加变量【对所有用户生效(永久的)】 用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。 例如：编辑/etc/profile文件，添加CLASSPATH变量\nvi /etc/profile export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib\n注：修改文件后要想马上生效还要运行# source /etc/profile不然只能在下次重进此用户时生效。\n2 在用户目录下的.bash_profile文件中增加变量【对单一用户生效(永久的)】 用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。 例如：编辑guok用户目录(/home/guok)下的.bash_profile $ vi /home/guok/.bash.profile 添加如下内容： export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib 注：修改文件后要想马上生效还要运行$ source /home/guok/.bash_profile不然只能在下次重进此用户时生效。\n3 直接运行export命令定义变量【只对当前shell(BASH)有效(临时的)】 在shell的命令行下直接使用[export 变量名=变量值] 定义变量，\n该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，\nshell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。\n环境变量的查看 1 使用echo命令查看单个环境变量。例如： echo $PATH 2 使用env查看所有环境变量。例如： env 3 使用set查看所有本地定义的环境变量。\n使用unset删除指定的环境变量 set可以设置某个环境变量的值。清除环境变量的值用unset命令。如果未指定值，则该变量值将被设为NULL。示例如下： $ export TEST=\u0026amp;ldquo;Test\u0026amp;hellip;\u0026amp;rdquo; #增加一个环境变量TEST $ env|grep TEST #此命令有输入，证明环境变量TEST已经存在了 TEST=Test\u0026amp;hellip; unset TEST #删除环境变量TEST $ env|grep TEST #此命令没有输出，证明环境变量TEST已经删除\n常用的环境变量 PATH 决定了shell将到哪些目录中寻找命令或程序 HOME 当前用户主目录 HISTSIZE　历史记录数 LOGNAME 当前用户的登录名 HOSTNAME　指主机的名称 SHELL 当前用户Shell类型 LANGUGE 语言相关的环境变量，多语言可以修改此环境变量 MAIL　当前用户的邮件存放目录 PS1　基本提示符，对于root用户是#，对于普通用户是$\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"d3d823ed64a742ac772e414fa04ba4d0","permalink":"/javadir/linux/linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","publishdate":"2020-01-17T15:26:15Z","title":"Linux下设置和查看环境变量"},{"content":"linux命令 文件管理 文件基本操作   less命令 (Q退出less命令)([pagedown]： 向下翻动一页)([pageup]： 向上翻动一页) less ss.md\n  cat命令 (cat -n ss.md \u0026amp;gt; sdfsd.txt)把 ss.md 的文档内容加上行号后输入 sdfsd.txt 这个文档里, 这要注意假如sdfsd.txt先有文档会被清空,另外(cat ss.md)可以把消息打印到输出流中,cat 软盘功能暂时不予以考虑\n  ls命令 (ls -a)显示所有文件及目录包括隐藏文件,相当于la命令,ll显示具体信息\n  touch命令 主要用作创建文件如touch ss.md,(touch -m miss,touch -a miss)可以改变文件的读取时间,另外touch miss也可以改变文件的读取时间, 当且仅当miss不存在的时候会创建miss空文件\n  mkdir命令 主要用作创建文件目录;(mkdir dd)创建一个dd目录,(mkdir -p dd/ffg)在当前目录下建立一个dd目录并且在dd下创建一个ffg目录,假如dd不存在会自动创建的\n  mv命令 (mv missA miss.txt)把missA修改为miss.txt (mv sskg /home/zhou/fontconfig/dgsd/sdfg)把sskg移到sdfg目录 (mv ss.md ~)\n  file命令 (file -c ss.md)详细显示指令执行过程(file -v ss.md)显示版本信息 (tar zcvf ss.tar ss.md,file -z ss.tar)尝试去解读压缩文件的内容\n  find命令 (find . -type f)将目前目录其其下子目录中所有一般文件列出(find . -ctime -20)将目前目录及其子目录下所有最近 20 天内更新过的文件列出 (find /home/zhou/fontconfig -name \u0026amp;lsquo;**.md\u0026amp;rsquo;)任意的以md结尾的文件,-name改为-iname会忽略大小写(find /home/zhou/fontconfig -size 0)所有文件长度为0的普通文件\n  split命令 ( split -2 sdfsd.txt) 每隔２行分割成一个文件\u0026amp;ndash;\u0026amp;gt; 分割后:xaa xab xac xad xae xaf xag\n  pwd命令 (pwd)pwd命令用于显示工作目录\n  rm命令 删除操作 (rm xaa)删除单一文件xaa文本文件,这里也是可以用正则的如rm x** ,(rm -r dgsd)递归删除文件目录dgsd下的所有文件包括其本身; (rm -rf baba)加了一个f此命令表示即使原档案属性设为唯读，亦直接删除，无需逐一确认\n  cp命令 复制或者说是拷贝命令 (cp ss.md s1)注意是在同级目录下 (cp /home/zhou/fontconfig/s1/ss.md ~),将ss.md复制到主home下,这的~可以随便换为其它目录 (cp -a s1 /home/zhou/fontconfig/s2,cp -a s1 s2)当cp的是目录时要加上-a参数,当然如果加上-p就更好了,因为-p表示把file拥有的权限也一起复制 如:(cp -ap s1 /home/zhou/fontconfig/s2),(cp -ap ./* /home/zhou/fontconfig/s3)在某个目录把所有内容都复制到s3下\n  chmod 权限命令 Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。\n  u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行\n  (chmod ugo+r miss.txt)将文件miss.txt 设为所有人皆可读取;(chmod u+x ex1.py)将 ex1.py 设定为只有该文件拥有者可以执行;(chmod 777 file)chmod也可以用数字来表示权限如\n  文本操作  假如是ubuntu则可以直接使用gedit (sudo apt-get install gedit) vi命令 切换模式(i：光标处开始插入,l：光标所在行首开始插入,a：光标所在行尾开始插入,o：光标下插入新行) 进入编辑模式,当编辑完成时,在按Esc按键退出编辑模式,保存并退 …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"e9f22fa450b59d14a7baab8e4e5218ce","permalink":"/javadir/linux/linux%E5%91%BD%E4%BB%A4/","publishdate":"2020-01-17T15:26:15Z","title":"linux命令"},{"content":"nginx学习 基础操作  start ./sbin/nginx stop ./sbin/nginx -s stop quite ./sbin/nginx -s quit   启动成功标志\n Welcome to nginx!\r 默认监听的端口是80 也就是说访问此端口就可以得到启动成功的标识符号\n  简单的负载均衡配置    http 模块中配置  #配置开始 author zhou\rupstream myproject{\rserver 127.0.0.1:8000 weight=3;\rserver 127.0.0.1:8080 weight=10;\rserver 127.0.0.1:8090;\r}\r#配置结束 author zhou\r location模块配置  proxy_pass http://myproject;\r注意:这的myproject要和上面的name一致\r测试结果 (这的测试用到了session的唯一性)\n http://localhost/nginx_test/ sessionId=8D9C4ACEE65EB24301B1C0D9E4CF3A6E\rhttp://localhost:8080/nginx_test/ sessionId=8D9C4ACEE65EB24301B1C0D9E4CF3A6E\rhttp://localhost:8090/nginx_test/ sessionId=7539B2C4AFD433ECEFAC8F2B2EBCC411\r 由于配置了权重 因此大部分是8080端口\n参数解释   1）down\n表示单前的server暂时不参与负载\n  2）Weight\n默认为1.weight越大，负载的权重就越大。\n  3）max_fails\n允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误\n  4）fail_timeout\nmax_fails 次失败后，暂停的时间。\n  5）Backup\n其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\n  service nginx start\rservice nginx stop\rnginx\r回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"dd1f5525d422d9a4bc8353655d00f622","permalink":"/javadir/linux/nginx/","publishdate":"2020-01-17T15:26:15Z","title":"nginx学习"},{"content":"Notepad++是一套非常有特色的自由软件的纯文字编辑器(许可证:GPL)。有完整的中文化接口及支持多国语言编写的功能(UTF8 技术)。 它的功能比 Windows 中的 Notepad(记事本)强大，除了可以用来制作一般的纯文字说明文件，也十分适合当作编写电脑程序的编辑器。 Notepad++ 不仅有语法高亮度显示，也有语法折叠功能，并且支持宏以及扩充基本功能的外挂模组。但是可惜的是Notepad++只能在Windows平台下使用。 工作中必须使用Windows时，Notepad++是众多程序员最喜爱的文本编辑器，在Ubuntu下是否能够使用到相同的软件呢？Notepadqq就是这样一款与Notepad++非常接近的编辑器，拥有几乎相同的功能。 如果您是一个Notepad++粉丝，我们推荐您尝试下Notepadqq。\n对于Ubuntu发行版本可以通过PPA安装，命令如下： sudo add-apt-repository ppa:notepadqq-team/notepadqq sudo apt-get update sudo apt-get install notepadqq 类似的，卸载命令如下：\nsudo apt-get remove notepadqq sudo add-apt-repository \u0026amp;ndash;remove ppa:notepadqq-team/notepadqq\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"81c82fcb8e326a6ba769be9292715a7e","permalink":"/javadir/linux/notepad++%E5%AE%89%E8%A3%85/","publishdate":"2020-01-17T15:26:15Z","title":"Notepad++ 学习与使用"},{"content":"IntelliJ IDE运行Tomcat报错解决办法的相关资料,出现“Unable to ping server at localhost:1099”错误解决方法，需要的朋友可以参考下\nsudo gedit /etc/hosts\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"84125ac3a925cbac3217a8040553d402","permalink":"/javadir/linux/ubuntu16.04%E4%BF%AE%E6%94%B9hosts/","publishdate":"2020-01-17T15:26:15Z","title":"Ubuntu 16.04修改hosts"},{"content":"垃圾的ubuntu 14.04 又一次去掉一些特别好用的软件, 官方给的解释是怕破坏他们系统. 只想说一句 我去年买了个本.\n14.04 之前的版本,如13.10, 12.04 继续能够使用 sudo apt-get install chmsee 来安装.\n14.04 需要下载安装包来安装:\nsudo apt-get install libc6 libchm1 libgcrypt11 libgdk-pixbuf2.0-0 libglib2.0-0 libgtk2.0-0 libpango1.0-0 libwebkitgtk-1.0-0 libxml2 安装依赖包\n(64位) sudo dpkg -i chmsee_1.3.0-2ubuntu2_amd64.deb 安装软件包,下载地址: http://kr.archive.ubuntu.com/ubuntu/pool/universe/c/chmsee/chmsee_1.3.0-2ubuntu2_amd64.deb Ubuntu的官方软件库放心下载.\n(32位) sudo dpkg -i chmsee_1.3.0-2ubuntu2_i386.deb 安装软件包,下载地址: http://kr.archive.ubuntu.com/ubuntu/pool/universe/c/chmsee/chmsee_1.3.0-2ubuntu2_i386.deb Ubuntu的官方软件库放心下载.\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"e65d8295751e07c0780e4d9ded4d07f1","permalink":"/javadir/linux/ubuntu%E5%AE%89%E8%A3%85chmsee/","publishdate":"2020-01-17T15:26:15Z","title":"ubuntu安装chmsee"},{"content":"1，非常有用的清理命令： sudo apt-get autoclean \u0026amp;ndash;清理旧版本的软件缓存 www.2cto.com\nsudo apt-get clean\u0026amp;ndash;清理所有软件缓存\nsudo apt-get autoremove\u0026amp;ndash;删除系统不再使用的孤立软件\n这三个命令主要清理升级缓存以及无用包的。\n2，清理opera firefox的缓存文件： ls ~/.opera/cache4 ls ~/.mozilla/firefox/*.default/Cache\n3，清理Linux下孤立的包： 图形界面下我们可以用：gtkorphan sudo apt-get install gtkorphan -y 终端命令下我们可以用：deborphan sudo apt-get install deborphan -y\n4，卸载：tracker 这个东西一般我只要安装Ubuntu就会第一删掉tracker 他不仅会产生大量的cache文件而且还会影响开机速度。所以在新得利里面删掉就行。 www.2cto.com\n5，删除多余的内核：一定不要删错哦，切记！！ 打开终端敲命令：dpkg \u0026amp;ndash;get-selections|grep linux 有image的就是内核文件 删除老的内核文件： sudo apt-get remove 内核文件名（例如：linux-image-2.6.27-2-generic） 内核删除，释放空间了，应该能释放130－140M空间。\n最后不要忘了看看当前内核：uname -a 附录： 包管理的临时文件目录: 包在 /var/cache/apt/archives 没有下载完的在 /var/cache/apt/archives/partial\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"3ae89dd38625837744248207aced4184","permalink":"/javadir/linux/ubuntu%E6%B8%85%E7%90%86%E7%B3%BB%E7%BB%9F%E5%9E%83%E5%9C%BE/","publishdate":"2020-01-17T15:26:15Z","title":"Ubuntu清理系统垃圾"},{"content":"ubuntu软件卸载\n安装Synaptic\nsudo apt-get install synaptic\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"162ab187b39df38d15beb3de5605e1f6","permalink":"/javadir/linux/ubuntu%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/","publishdate":"2020-01-17T15:26:15Z","title":"ubuntu软件卸载"},{"content":"目录  Redis 学习与使用  ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"3027933794fbb8b522a334f56fdb9b59","permalink":"/javadir/middleware/","publishdate":"2021-04-15T00:00:00Z","title":"中间件 "},{"content":"一.Redis介绍 1.1引言  1:由于用户量大，请求了随之增大，数据压力过大。 2:多台服务器之间数据不同步 3:多台服务器之间的锁已经不存在互斥性了\n  1.2 NOSQL  redis就是nosql\n  非关系数据库 \u0026amp;gt; not only sql\n 1:key-value redis 2:文档型 solr,Mongodb,ElasticSearch 3:面向列 Hbase(一般大数据) 4:图形化 Neo4j\n  1.3 redis介绍  Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 Redis是一款基于Key-Value的NOSQL，而且Redis是基于内存存储数据的,Redis还提供了多种持久化机制，Redis还提供了主从、哨兵以及集群的搭建方式，可以更方便的横向扩展以及垂直扩展\n  操作都是原子的\n 所有 Redis 的操作都是原子的，从而确保当两个客户同时访问 Redis 服务器时，得到的是更新后的值（最新值）。在需要高并发的场合可以考虑使用 Redis 的事务，处理一些需要锁的业务。\n  二.Redis安装 三.Redis命令  keys * 获取所有的key\rclear 清除屏幕\rquit ,exit 退出\rset name blake 设置值\rsetex ip 5 192.1.1.168 设置值并且设置过期时长\rget name 取出值\rdel name 删除key所对应的值\rexists key 判断是否存在key\rmset key1,key2...设置多个值\rmget key1,key2...取出多个值\rappend age 1 追加key的value\rstrlen key 获取某个key的value的长度\rselect index 选择数据库 (注意redis一共16个数据库 并且从0开始)\rmove key db或者 move key index (redis一共16个数据库 move age 7) 将某个key移动到某个数据库中\rflushdb 清除当前数据库\rflushall 清除16个数据库\rtype key 获取数据类型 (type name == \u0026amp;gt; string)\r3.1 redis存储数据结构  字符串列表 key-string 无序不重复的字符串集合 key-set 有序不重复的字符串集合 key-list 键、值都为字符串的哈希表 key-hash 有序集合 key-zset  3.2存储结构用处  key-string :最常用的，一般用于存储一个值 key-hash:存储一个对象数据的 key-list:使用list结构实现栈和队列结构 key-set: 交集、差集、并集操作 key-zset : 排行榜,积分存储  回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"8d07d0b0de1a878931eb81a6207a04cf","permalink":"/javadir/middleware/redis/","publishdate":"2020-01-17T15:26:15Z","title":"Redis 学习与使用"},{"content":"目录  Apache Commons 工具类介绍及简单使用 org.apache.commons.io.FilenameUtils 操作 dom4j 处理 xml Guava 基于java1.6的类库集合的扩展项目 常用 Console 调试命令 jsoup学习文档 spring工具 spring常用的工具类  ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"82dc811c2ca8133568eb22429dc492ae","permalink":"/javadir/tooldoc/","publishdate":"2021-04-15T00:00:00Z","title":"Java公共库文档总结 "},{"content":"Apache Commons 工具类介绍及简单使用    组件 功能介绍     BeanUtils Commons-BeanUtils 提供对 Java 反射和自省API的包装, 提供了对于JavaBean进行各种操作，克隆对象,属性等等.   Betwixt XML与Java对象之间相互转换.   Codec 处理常用的编码方法的工具类包 例如DES、SHA1、MD5、Base64等.   Collections java集合框架操作.   Compress java提供文件打包 压缩类库.   Configuration Commons-Configuration 工具对各种各式的配置和参考文件提供读取帮助,java应用程序的配置管理类库.   DBCP 提供数据库连接池服务.   DbUtils DbUtils 是一个 JDBC helper 类库，完成数据库任务的简单的资源清除代码,提供对jdbc 的操作封装来简化数据查询和记录读取操作   Email java发送邮件 对javamail的封装.   FileUpload 提供文件上传功能.   HttpClient 提供HTTP客户端与服务器的各种通讯操作. 现在已改成HttpComponents   Lang Java基本对象方法的工具类包 如：StringUtils,ArrayUtils等等.   Logging 提供的是一个Java 的日志接口.   Validator 提供了客户端和服务器端的数据验证框架.   Primitives Commons-Primitives提供了一个更小，更快和更易使用的对Java基本类型的支持。当前主要是针对基本类型的 collection。   Math Math 是一个轻量的，自包含的数学和统计组件，解决了许多非常通用但没有及时出现在Java标准语言中的实践问题   EL Commons-EL 提供在JSP2.0规范中定义的EL表达式的解释器.   Discovery Commons-Discovery 提供工具来定位资源 (包括类) ，通过使用各种模式来映射服务/引用名称和资源名称。   Digester Commons-Digester 是一个 XML-Java对象的映射工具，用于解析 XML配置文件.   Chain Chain 提供实现组织复杂的处理流程的“责任链模式”   Modeler Commons-Modeler 提供了建模兼容JMX规范的Mbean的机制.   Net Net 是一个网络工具集，基于 NetComponents 代码，包括 FTP 客户端等等    一:org.apache.commons.lang  ArrayUtils – 用于对数组的操作，如添加、查找、删除、子数组、倒序、元素类型转换等；  ArrayUtils类\rArrayUtils.toString(array) 将数组转为为字符串，格式如：{2,4,8,16}\rArrayUtils.contains(array,8) 判断数组中是否包含数字8，（一维数组）\rArrayUtils.indexOf(array,8) 判断数组中第一个8的位置（一维数组）\rArrayUtils.lastIndexOf(array,8) 判断数组中最后一个8的位置。（一维数组）\rArrayUtils.clone(array) 给一个一维数组来个拷贝\rArrayUtils.reverse(array); 翻转该一维数组\rArrayUtils.toMap(array); 将一个二维数组转换为map，二维数组中至少与两列，第一列为key第二列为value == \u0026amp;gt;注意的是传入toMap()中的二维数组必须是对象如Integer\r  BitField – 用于操作位元，提供了一些方便而安全的方法；\n  BooleanUtils – 用于操作和转换 boolean 或者 Boolean 及相应的数组；\n   boolean[] booleans = new boolean[]{true, false, true};\r//和，并且\rSystem.out.println(BooleanUtils.and(booleans));//false\r//或者\rSystem.out.println(BooleanUtils.or(booleans));//true\rProjectInfo projectInfo = null;\rif (projectInfo != null \u0026amp;amp;\u0026amp;amp; projectInfo.getId() != 0);\r//可以用上面的改为\rBooleanUtils.and(new boolean[]{projectInfo != …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"3bf98c92cc09e1399afcf0ba2543280d","permalink":"/javadir/tooldoc/apache-common%E5%B7%A5%E5%85%B7%E5%8C%85/","publishdate":"2020-01-17T15:26:15Z","title":"Apache Commons 工具类介绍及简单使用"},{"content":"org.apache.commons.io.FilenameUtils 文件名称操作   FilenameUtils.getExtension(fileName) 获取文件后缀 //text\n  FilenameUtils.getName(fileName) 获取文件完整名称 //c.text\n  FilenameUtils.getBaseName(fileName) 获取文件名称 //c\n  FilenameUtils.getFullPath(fileName) 获取文件的完整路径 //D:\\data\\\n  String path = \u0026amp;quot;D:\\\\data\\\\假设开发法土地模板.docx\u0026amp;quot; ;\rString fullPath = FilenameUtils.getFullPath(path);\rSystem.out.println(\u0026amp;quot;fullPath:\u0026amp;quot;+fullPath);//D:\\data\\\rString name = FilenameUtils.getName(path);\rSystem.out.println(\u0026amp;quot;name:\u0026amp;quot;+name); //假设开发法土地模板.docx\rString prefix = FilenameUtils.getPrefix(path);\rSystem.out.println(\u0026amp;quot;prefix:\u0026amp;quot;+prefix); //D:\\\rint prefixLength = FilenameUtils.getPrefixLength(path);\rSystem.out.println(\u0026amp;quot;prefixLength:\u0026amp;quot;+prefixLength); //3\rString path1 = FilenameUtils.getPath(path);\rSystem.out.println(\u0026amp;quot;path:\u0026amp;quot;+path1); //data\\\rString baseName = FilenameUtils.getBaseName(path);\rSystem.out.println(\u0026amp;quot;baseName:\u0026amp;quot;+baseName); //假设开发法土地模板\rString extension = FilenameUtils.getExtension(path);\rSystem.out.println(\u0026amp;quot;extension:\u0026amp;quot;+extension); //docx\rFileUtils：提供文件操作（移动文件，读取文件，检查文件是否存在等等） String path = \u0026amp;quot;D:\\\\data\\\\test\u0026amp;quot;;\rString fileSize = FileUtils.byteCountToDisplaySize(1024 * 1024);\r// 转换文件长度单位\rAssert.assertEquals(\u0026amp;quot;1 MB\u0026amp;quot;, fileSize);\r// 清空某目录下的所有目录,含文件夹和文件,注意是目录下,不包含父目录\rFileUtils.cleanDirectory(new File(path));\r// copy URL中文件到參數2\rFileUtils.copyURLToFile(new URL(\u0026amp;quot;https://v3.bootcss.com/\u0026amp;quot;), new File(\u0026amp;quot;D:\\\\data\\\\test1\\\\a1.txt\u0026amp;quot;));//a1.txt 里面拷贝下来是一个网页\r// 强制删除文件\rFileUtils.forceDelete(new File(\u0026amp;quot;D:\\\\data\\\\test1\\\\a1.txt\u0026amp;quot;));\r// 将文件转为 InputStream\rFileUtils.openInputStream(new File(\u0026amp;quot;D:\\\\data\\\\aac.pptx\u0026amp;quot;));\r//openOutStream\rFileUtils.openOutputStream(new File(\u0026amp;quot;D:\\\\data\\\\aac.pptx\u0026amp;quot;));\r// 读取文件转为字节数组\rbyte[] bytes = FileUtils.readFileToByteArray(new File(\u0026amp;quot;D:\\\\data\\\\aab.pptx\u0026amp;quot;));\r// 读取文件转换为String类型,方便文本读取\rFileUtils.readFileToString(new File(\u0026amp;quot;D:\\\\data\\\\aab.pptx\u0026amp;quot;),\u0026amp;quot;UTF-8\u0026amp;quot;);\r// …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"10d2e736c379dda829b4354b72cd1c26","permalink":"/javadir/tooldoc/commons_io/","publishdate":"2020-01-17T15:26:15Z","title":"apache FilenameUtils 文件名称操作"},{"content":"dom4j  选取节点\n   nodename 选取当前节点的所有子节点\n  / 从根节点选取\n  // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置\n  . 选取当前节点\n  .. 选取当前节点的父节点\n  @ 选取属性\n   实例\n   路径表达式 结果\n  bookstore 选取 bookstore 元素的所有子节点\n  /bookstore 选取根元素 bookstore\n  bookstore/book 选取bookstore 下名字为 book的所有子元素。\n  //book 选取所有 book 子元素，而不管它们在文档中的位置。\n  bookstore//book 选取bookstore 下名字为 book的所有后代元素，而不管它们位于 bookstore 之下的什么位置。\n  //@lang 选取所有名为 lang 的属性。\n   常见的谓语的一些路径表达式\n  /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()\u0026amp;lt;3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 //title[@lang=\u0026amp;lsquo;eng\u0026amp;rsquo;] 选取所有 title 元素，要求这些元素拥有值为 eng 的 lang 属性。 /bookstore/book[price\u0026amp;gt;35.00] 选取所有 bookstore 元素的 book 元素，要求book元素的子元素 price 元素的值须大于 35.00。 /bookstore/book[price\u0026amp;gt;35.00]/title 选取所有 bookstore 元素中的 book 元素的 title 元素，要求book元素的子元素 price 元素的值须大于 35.00   选取未知节点\n  通配符 描述   匹配任何元素节点   @* 匹配任何属性节点 node() 匹配任何类型的节点 路径表达式 结果 //book/title | //book/price 选取所有 book 元素的 title 和 price 元素。 //title | //price 选取所有文档中的 title 和 price 元素。 /bookstore/book/title|//price 选取所有属于 bookstore 元素的 book 元素的title 元素，以及文档中所有的 price 元素。  回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"ebfe9650f4e8a331e3f30c5b79b7fd72","permalink":"/javadir/tooldoc/dom4j/","publishdate":"2020-01-17T15:26:15Z","title":"dom4j"},{"content":"Guava 基于java1.6的类库集合的扩展项目  com.google.common.annotations：普通注解类型。 com.google.common.base：基本工具类库和接口。 com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存。 com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类，这里你会发现很多好玩的集合。 com.google.common.eventbus：发布订阅风格的事件总线。 com.google.common.hash： 哈希工具包。 com.google.common.io：I/O工具包。 com.google.common.math：原始算术类型和超大数的运算工具包。 com.google.common.net：网络工具包。 com.google.common.primitives：八种原始类型和无符号类型的静态工具包。 com.google.common.reflect：反射工具包。 com.google.common.util.concurrent：多线程工具包。\r 常见Object方法   hashCode compare/compareTo 实现一个比较器[Comparator]，或者直接实现Comparable接口有时也伤不起\n public class ProjectInfo implements Serializable,Comparable\u0026amp;lt;ProjectInfo\u0026amp;gt; {\rprivate int id;\rprivate String name;\rpublic int getId() {\rreturn id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setId(int id) {\rthis.id = id;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r@Override\rpublic int compareTo(ProjectInfo o) {\rreturn ComparisonChain.start().compare(this.getName(),o.getName()).compare(this.getId(),o.getId()).result();\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hashCode(getId(),getName());\r}\r}\r 当一个对象中的字段可以为null时，实现Object.equals方法会很痛苦，因为不得不分别对它们进行null检查。 使用Objects.equal帮助你执行null敏感的equals判断，从而避免抛出NullPointerException\n public void testA(){\rSystem.out.println(Objects.equal(\u0026amp;quot;a\u0026amp;quot;,\u0026amp;quot;a\u0026amp;quot;));// --\u0026amp;gt;true\rSystem.out.println(Objects.equal(\u0026amp;quot;a\u0026amp;quot;,\u0026amp;quot;\u0026amp;quot;));// --\u0026amp;gt;false\rSystem.out.println(Objects.equal(\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;\u0026amp;quot;));// --\u0026amp;gt;true\rSystem.out.println(Objects.equal(\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;w\u0026amp;quot;));// --\u0026amp;gt;false\rSystem.out.println(Objects.equal(null,null));// --\u0026amp;gt;true\rSystem.out.println(Objects.equal(null,\u0026amp;quot;\u0026amp;quot;));// --\u0026amp;gt;false\r}\r toString 好的toString方法在调试时是无价之宝，但是编写toString方法有时候却很痛苦。使用MoreObjects(低版本还是Objects)\n System.out.println(MoreObjects.toStringHelper(this).add(\u0026amp;quot;x\u0026amp;quot;,2).\radd(\u0026amp;quot;y\u0026amp;quot;,Math.round(Math.random()*10)).toString());\r/*console : ObjectsDemo{x=2, y=9}*/\r Preconditions   前置条件Preconditions提供静态方法来 …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"9bf953792b2140fd24036c14cbb52ca1","permalink":"/javadir/tooldoc/guava-common/","publishdate":"2020-01-17T15:26:15Z","title":"Guava 基于java1.6的类库集合的扩展项目"},{"content":"Console 对象方法   常用 Console 调试命令\n  console.log(\u0026#39;hello\u0026#39;);\rconsole.info(\u0026#39;信息\u0026#39;);\rconsole.error(\u0026#39;错误\u0026#39;);\rconsole.warn(\u0026#39;警告\u0026#39;);\rassert()  ssert方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。  // 实例\rconsole.assert(true === false, \u0026amp;quot;判断条件不成立\u0026amp;quot;)\r// Assertion failed: 判断条件不成立\rclear()  清除当前控制台的所有输出，将光标回置到第一行。  console.clear()\rcount()  用于计数，输出它被调用了多少次。  (function() {\rfor (var i = 0; i \u0026amp;lt; 5; i++) { console.count(\u0026#39;count\u0026#39;); }\r})()\rerror()  输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈。  console.error(\u0026amp;quot;Error: %s (%i)\u0026amp;quot;, \u0026amp;quot;Server is not responding\u0026amp;quot;,500)\rgroup()  用于将显示的信息分组，可以把信息进行折叠和展开。  console.group(\u0026#39;第一层\u0026#39;);\rconsole.group(\u0026#39;第二层\u0026#39;);\rconsole.log(\u0026#39;error\u0026#39;);\rconsole.error(\u0026#39;error\u0026#39;);\rconsole.warn(\u0026#39;error\u0026#39;);\rconsole.groupEnd(); console.groupEnd();\rinfo()  console.log 别名，输出信息  console.info(\u0026amp;quot;runoob\u0026amp;quot;)\rlog()  输出信息  console.log(\u0026amp;quot;runoob\u0026amp;quot;)\rtable()  将复合类型的数据转为表格显示。  var arr= [ { num: \u0026amp;quot;1\u0026amp;quot;},\r{ num: \u0026amp;quot;2\u0026amp;quot;}, { num: \u0026amp;quot;3\u0026amp;quot; }\r];\rconsole.table(arr);\rvar obj= {\ra:{ num: \u0026amp;quot;1\u0026amp;quot;},\rb:{ num: \u0026amp;quot;2\u0026amp;quot;},\rc:{ num: \u0026amp;quot;3\u0026amp;quot; }\r};\rconsole.table(obj);\rtime() ++ 计时开始\nconsole.time(\u0026#39;计时器1\u0026#39;);\rfor (var i = 0; i \u0026amp;lt; 100; i++) {\rfor (var j = 0; j \u0026amp;lt; 100; j++) {}\r}\rconsole.timeEnd(\u0026#39;计时器1\u0026#39;);\rconsole.time(\u0026#39;计时器2\u0026#39;);\rfor (var i = 0; i \u0026amp;lt; 1000; i++) {\rfor (var j = 0; j \u0026amp;lt; 1000; j++) {}\r}\rconsole.timeEnd(\u0026#39;计时器2\u0026#39;);\rtimeEnd()  计时结束  console.time(\u0026#39;计时器1\u0026#39;);\rfor (var i = 0; i \u0026amp;lt; 100; i++) {\rfor (var j = 0; j \u0026amp;lt; 100; j++) {}\r}\rconsole.timeEnd(\u0026#39;计时器1\u0026#39;);\rconsole.time(\u0026#39;计时器2\u0026#39;);\rfor (var i = 0; i \u0026amp;lt; 1000; i++) {\rfor (var j = 0; j \u0026amp;lt; 1000; j++) {}\r}\rconsole.timeEnd(\u0026#39;计时器2\u0026#39;);\rwarn()  输出警告信息  console.warn(\u0026amp;quot;警告\u0026amp;quot;)\r 最常用的就是 console.log 了。 console上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）:   占位符\t作用\r%s\t字符串\r%d or %i\t整数\r%f\t浮点数\r%o\t可展开的DOM\r%O\t列出DOM的属性\r%c\t根据提供的css样式格式化字符串\r实例:\rconsole.log(\u0026amp;quot;%d年%d月%d日\u0026amp;quot;,2011,3,26);\r回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"9c3aa5929a7aa84305a0eaf1f06d1c1c","permalink":"/javadir/tooldoc/js_console%E7%94%A8%E6%B3%95/","publishdate":"2020-01-17T15:26:15Z","title":"常用 Console 调试命令"},{"content":"jsoup学习文档 简介  Jsoup是用于解析HTML，就类似XML解析器用于解析XML。 Jsoup它解析HTML成为真实世界的HTML。 它与jquery选择器的语法非常相似，并且非常灵活容易使用以获得所需的结果\n +jsoup api 6个包提供用于开发jsoup应用程序的类和接口。\norg.jsoup\rorg.jsoup.examples\rorg.jsoup.helper\rorg.jsoup.nodes\rorg.jsoup.parser\rorg.jsoup.safety\rorg.jsoup.salect\r引入 //大多数情况使用jsoup\rorg.jsoup.nodes.Document document = Jsoup.parse(html);\rDocument doc = Jsoup.parse(new URL(\u0026amp;quot;http://www.funi.com/\u0026amp;quot;),7000);\r//少数情况使用httpUnit\rWebClient webClient = new WebClient() ;\rHtmlPage htmlPage = webClient.getPage(\u0026amp;quot;http://www.89ip.cn/\u0026amp;quot;);\rhtmlPage.asXml()//html\r使用(maven) \u0026amp;lt;dependency\u0026amp;gt;\r\u0026amp;lt;!-- jsoup HTML parser library @ http://jsoup.org/ --\u0026amp;gt;\r\u0026amp;lt;groupId\u0026amp;gt;org.jsoup\u0026amp;lt;/groupId\u0026amp;gt;\r\u0026amp;lt;artifactId\u0026amp;gt;jsoup\u0026amp;lt;/artifactId\u0026amp;gt;\r\u0026amp;lt;version\u0026amp;gt;1.10.2\u0026amp;lt;/version\u0026amp;gt;\r\u0026amp;lt;/dependency\u0026amp;gt;\r\u0026amp;lt;!-- httpclient --\u0026amp;gt;\r\u0026amp;lt;dependency\u0026amp;gt;\r\u0026amp;lt;groupId\u0026amp;gt;org.apache.httpcomponents\u0026amp;lt;/groupId\u0026amp;gt;\r\u0026amp;lt;artifactId\u0026amp;gt;httpclient\u0026amp;lt;/artifactId\u0026amp;gt;\r\u0026amp;lt;version\u0026amp;gt;4.5.6\u0026amp;lt;/version\u0026amp;gt;\r\u0026amp;lt;/dependency\u0026amp;gt;\r\u0026amp;lt;dependency\u0026amp;gt;\r\u0026amp;lt;groupId\u0026amp;gt;net.sourceforge.htmlunit\u0026amp;lt;/groupId\u0026amp;gt;\r\u0026amp;lt;artifactId\u0026amp;gt;htmlunit\u0026amp;lt;/artifactId\u0026amp;gt;\r\u0026amp;lt;version\u0026amp;gt;2.26\u0026amp;lt;/version\u0026amp;gt;\r\u0026amp;lt;/dependency\u0026amp;gt;\r解析一个body片断  假如你有一个HTML片断 (比如. 一个 div 包含一对 p 标签; 一个不完整的HTML文档) 想对它进行解析。这个HTML片断可以是用户提交的一条评论或在一个CMS页面中编辑body部分。\n 办法:使用Jsoup.parseBodyFragment(String html) ,Document.body() 方法能够取得文档body元素的所有子元素，与 doc.getElementsByTag(\u0026amp;ldquo;body\u0026amp;rdquo;)相同\nString html = \u0026amp;quot;\u0026amp;lt;div\u0026amp;gt;\u0026amp;lt;p\u0026amp;gt;Lorem ipsum.\u0026amp;lt;/p\u0026amp;gt;\u0026amp;quot;;\rDocument doc = Jsoup.parseBodyFragment(html);\rSystem.out.println(doc.html());//可以看到我们的html片段被包裹了一个body\rElement body = doc.body();\rSystem.out.println(body.html());\r/*\r\u0026amp;lt;html\u0026amp;gt;\r\u0026amp;lt;head\u0026amp;gt;\u0026amp;lt;/head\u0026amp;gt;\r\u0026amp;lt;body\u0026amp;gt;\r\u0026amp;lt;div\u0026amp;gt;\r\u0026amp;lt;p\u0026amp;gt;Lorem ipsum.\u0026amp;lt;/p\u0026amp;gt;\r\u0026amp;lt;/div\u0026amp;gt;\r\u0026amp;lt;/body\u0026amp;gt;\r\u0026amp;lt;/html\u0026amp;gt;\r*/\r/**\r\u0026amp;lt;div\u0026amp;gt;\r\u0026amp;lt;p\u0026amp;gt;Lorem ipsum.\u0026amp;lt;/p\u0026amp;gt;\r\u0026amp;lt;/div\u0026amp;gt;\r*/\r从一个URL加载一个Document  你需要从一个网站获取和解析一个HTML文档，并查找其中的相关数据。你可以使用下面解决方法\n 办法:使用 Jsoup.connect(String url)方法\nDocument doc = Jsoup.parse(new …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"8a05d801c2fc457812309e703bfbe6c1","permalink":"/javadir/tooldoc/jsoup/","publishdate":"2020-01-17T15:26:15Z","title":"jsoup学习文档"},{"content":"spring工具类  Spring-core中提供了大量的工具类，常用的有StringUtils、ObjectUtils、NumberUtils、Base64Utils等，Spring工具类在spring-core.jar中的org.springframework.util包下。\n  1:StringUtils  方法名\t返回值类型\t作用\t备注\risEmpty(Object str)\tboolean\t判断字符串是否为Null或者空字符串\tnull和\u0026#39;\u0026#39;都为true\rhasLength(CharSequence str)\tboolean\t判断字符串长度是否大于1\tnull和\u0026#39;\u0026#39;都为false\rhasText(CharSequence str)\tboolean\t判断字符串中是否有字符\tnull和空字白符都为false\rcontainsWhitespace(CharSequence str)\tboolean\t字符串中是否含有空白字符\ttrimWhitespace(CharSequence str)\tString\t去掉字符串中首尾的空白字符\ttrimAllWhitespace(String str)\tString\t去 掉字符串中所有的空白字符\ttrimLeadingWhitespace(String str)\tString\t去掉字符串左边的空白字符\ttrimTrailingWhitespace(String str)\tString\t去掉字符串右边边的空白字符\tstartsWithIgnoreCase(String str, String prefix)\tString\t判断字符串是否以xx开头，并且忽略大小写\tgetFilename(String path)\tString\t获取文件名\t“mypath/myfile.txt” -\u0026amp;gt; “myfile.txt”\rgetFilenameExtension(String path)\tString\t获取文件扩展名\t“mypath/myfile.txt” -\u0026amp;gt; “txt”\rstripFilenameExtension(String path)\tString\t去掉文件扩展名\t“mypath/myfile.txt” -\u0026amp;gt; “mypath/myfile”\rreplace(String inString, String oldPattern, String newPattern)\tString\t替换字符串\tdelete(String inString, String pattern)\tString\t从给定的字符串中删除所有匹配的字符\tdeleteAny(String inString, String charsToDelete)\tString\t删除所有指定字符\t“az\\n” will delete ‘a’s, ‘z’s and new lines\rSystem.out.println(org.springframework.util.StringUtils.containsWhitespace(\u0026amp;quot;sfas\u0026amp;quot;));//是否有空白 false\rSystem.out.println(org.springframework.util.StringUtils.trimWhitespace(\u0026amp;quot; - dfasd- \u0026amp;quot;));//去除前后空格\rSystem.out.println(org.springframework.util.StringUtils.trimAllWhitespace(\u0026amp;quot; - - - - fshjk s j - -\u0026amp;quot;));//去除所有空格\rSystem.out.println(org.springframework.util.StringUtils.trimLeadingWhitespace(\u0026amp;quot; - - - - fshjk s j - - \u0026amp;quot;));//去除第字符串开头的空格\rSystem.out.println(org.springframework.util.StringUtils.trimTrailingWhitespace(\u0026amp;quot; - - - - fshjk s j - - \u0026amp;quot;));//去除第字符串结尾的空格\rSystem.out.println(org.springframework.util.StringUtils.substringMatch(\u0026amp;quot;f sdfc\u0026amp;quot;,2,\u0026amp;quot;sd\u0026amp;quot;));// …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"6d74d0159835112bb8cf7b5922c2959a","permalink":"/javadir/tooldoc/spring%E5%B7%A5%E5%85%B7/","publishdate":"2020-01-17T15:26:15Z","title":"spring工具类"},{"content":"spring常用的工具类 内置的resouce类型 UrlResource\rClassPathResource\rFileSystemResource\rServletContextResource\rInputStreamResource\rByteArrayResource\rEncodedResource 也就是Resource加上encoding, 可以认为是有编码的资源\rVfsResource(在jboss里经常用到, 相应还有 工具类 VfsUtils)\rorg.springframework.util.xml.ResourceUtils 用于处理表达资源字符串前缀描述资源的工具. 如: \u0026amp;amp;quot;classpath:\u0026amp;amp;quot;. 有 getURL, getFile, isFileURL, isJarURL, extractJarFileURL 工具类 org.springframework.core.annotation.AnnotationUtils 处理注解\rorg.springframework.core.io.support.PathMatchingResourcePatternResolver 用 于处理 ant 匹配风格(com/*.jsp, com/**/*.jsp),找出所有的资源, 结合上面的resource的概念一起使用,对于遍历文件很有用. 具体请详细查看javadoc\rorg.springframework.core.io.support.PropertiesLoaderUtils 加载Properties资源工具类,和Resource结合\rorg.springframework.core.BridgeMethodResolver 桥接方法分析器. 关于桥接方法请参考: http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.12.4.5\rorg.springframework.core.GenericTypeResolver 范型分析器, 在用于对范型方法, 参数分析.\rorg.springframework.core.NestedExceptionUtils\rxml工具 org.springframework.util.xml.AbstractStaxContentHandler\rorg.springframework.util.xml.AbstractStaxXMLReader\rorg.springframework.util.xml.AbstractXMLReader\rorg.springframework.util.xml.AbstractXMLStreamReader\rorg.springframework.util.xml.DomUtils\rorg.springframework.util.xml.SimpleNamespaceContext\rorg.springframework.util.xml.SimpleSaxErrorHandler\rorg.springframework.util.xml.SimpleTransformErrorListener\rorg.springframework.util.xml.StaxUtils\rorg.springframework.util.xml.TransformerUtils\r其它工具集 org.springframework.util.xml.AntPathMatcherant风格的处理\rorg.springframework.util.xml.AntPathStringMatcher\rorg.springframework.util.xml.Assert断言,在我们的参数判断时应该经常用\rorg.springframework.util.xml.CachingMapDecorator\rorg.springframework.util.xml.ClassUtils用于Class的处理\rorg.springframework.util.xml.CollectionUtils用于处理集合的工具\rorg.springframework.util.xml.CommonsLogWriter\rorg.springframework.util.xml.CompositeIterator\rorg.springframework.util.xml.ConcurrencyThrottleSupport\rorg.springframework.util.xml.CustomizableThreadCreator …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"e1d615349881cde66f66470c0f93e063","permalink":"/javadir/tooldoc/spring%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/","publishdate":"2020-01-17T15:26:15Z","title":"spring常用的工具类"},{"content":"自己整理的日常开发参考网址    在线工具 链接     web工具 web工具   在线超级转换工具 在线超级转换工具   程序员在线工具 在线超级转换工具   图片转base64工具 图片转base64工具       算法 链接     算法网址 leetcode 国内 算法网址 leetcode 国内   算法网址 牛课网 国内 算法网址 牛课网 国内   算法网址 codility 国外 算法网址 codility 国外       bootstrap 链接     bootstrap 重要参考例子 bootstrap 重要参考例子   bootstrap table api(csdn) bootstrap table api(csdn)   bootstrap table api(官方) bootstrap table api(官方)       图标 链接     阿里巴巴icon 阿里巴巴icon   easy icon easy icon        Java学习 链接     ibm java example ibm java example   Java并发参考 Java并发参考   csdn csdn   Java分享网 Java分享网   java fx api java fx api       教程 链接     www.w3cschoo 国内 www.w3cschoo 国内   www.w3cschoo 国外 www.w3cschoo 国外   菜鸟教程 菜鸟教程   nginx api nginx api   vue 学习 vue 学习   幕课网 幕课网   我要自学网 我要自学网       网站 链接     站长之家 站长之家   脚本之家 脚本之家   源码之家 源码之家       考试网 链接     中国人事考试网 中国人事考试网   计算机技术与软件专业技术资格 计算机技术与软件专业技术资格   中国计算机职业资格网 中国计算机职业资格网       例子 链接     淘宝如何处理分布式请求的 博客网 淘宝如何处理分布式请求的 博客网   [淘宝如何处理分布式请求的 微信公众号 [淘宝如何处理分布式请求的 微信公众号   Java程序员必学知识点整理 Java程序员必学知识点整理   程序员必须掌握哪些算法？ 程序员必须掌握哪些算法？   12个模块 150 道 java 必考面试题 12个模块 150 道 java 必考面试题   优化代码中大量的if/else，你有什么方案? 优化代码中大量的if/else，你有什么方案?   短时间如何过java面试？ 短时间如何过java面试？   如何学习Java的NIO？ 如何学习Java的NIO？   16个小众却很实用的网站（程序员方向） 16个小众却很实用的网站（程序员方向）   如何判断 Java 工程师的基础知识是否扎实？ 如何判断 Java 工程师的基础知识是否扎实？   JAVA的多态用几句话能直观的解释一下吗？ JAVA的多态用几句话能直观的解释一下吗？    计算机在职研究生招生学校    学校 层次     西南交通大学 211   中国人民大学 教育部直属   自考参考网站 教育部直属    收集的杂七杂八得网址    学校     Java程序员掉发系列——程序员的成长之路   史上最全的程序员常用英语词汇   Java程序员掉发系列——程序员必须认识的英文单词（汇总）   每个程序员必须掌握的常用英语词汇   程序员必知1700英语单词   这70个Java必背英语单词不会，就别说你是Java程序员！   java代理机制   国内有哪些质量高的JAVA社区？   hutool-all 介绍 ==\u0026amp;gt; Hutool是一个小而全的Java工具类库   GitHub Pages 绑定来自阿里云的域名   Spring Boot 学习    面试背题网站    名称 链接     javaguide javaguide   pdai.tech pdai.tech    面试网 面试网    1-3年应该掌握的知识与技能 1：基本语法 这包括static、final、transient等关键字的作用，foreach循环的原理等等。今天面试我问你static关键字有哪些作用，如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满意，因为能看出你非常热衷研究技术。\n2、集合 非常重要，也是必问的内容。基本上就是List、Map、Set，问的是各种实现类的底层实现原理，实现类的优缺点。\n集合要掌握的 …","date":1554163200,"description":"经验,规律,总结,宁静","lastmod":"2019-04-02T00:00:00Z","objectID":"588dd4868be77ba7452cb18b95e1878f","permalink":"/post/website/","publishdate":"2019-04-02T00:00:00Z","title":"网站链接"},{"categories":["Development","golang"],"content":"一、 编译程序   1、 编译器是一种翻译程序，它用于将源语言（即用某种程序设计语言写成的）程序翻译为目标语言（即用二进制数表示的伪机器代码写成的）程序。后者在windows操作系统平台下，其文件的扩展名通常为.obj。该文件通常还要经过进一步的连接，生成可执行文件（机器代码写成的程序，文件扩展名为.exe）。通常有两种方式进行这种翻译，一种是编译，另一种是解释。后者并不生成可执行文件，只是翻译一条语句、执行一条语句。这两种方式相编译比解释运行的速度要快得多。\n  2、 编译过程的5个阶段：词法分析；语法分析；语义分析与中间代码产生；优化；目标代码生成。\n  3、 在这五个阶段中，词法分析的任务是识别源程序中的单词是否有误，编译程序中实现这种功能的部分一般称为词法分析器。在编译器中，词法分析器通常仅作为语法分析程序的一个子程序以便在它需要单词符号时调用。在这一编译阶段中发现的源程序错误，称为词法错误。\n  4、 语法分析阶段的目的是识别出源程序的语法结构（即语句或句子）是否错误，所以有时又常为句子分析。编译程序中负责这一功能的程序称为语法分析器或语法分析程序。在这一阶段中发现的错误称为语法错误。\n  5、 C语言的（源）程序必须经过编译才能生成目标代码，再经过链接才能运行。PASCAL语言、FORTRAN语言的源程序也要经过这样的过程。通常将C、PASCAL、FORTRAN这样的语言统称为高级语言。而将最终的可执行程序称为机器语言程序。\n  6、 在编译C语言程序的过程中，发现源程序中的一个标识符过长，超过了编译程序允许的范围，这个错误应在词法分析阶段发现，这种错误通常被称作词法错误。\n 词法分析器的任务是以词法规则为依据对输入的源程序进行单词及其属性的识别，识别出一个个单词符号。\n 词法分析的输入是源程序，输出是一个个单词的特殊符号，称为Token（标记或符号）。\n 语法分析器的类型有:自下而上、自上而下。常用的语法分析器有：递归下降分析方法是一种自上而下分析方法, 算符优先分析法属于自下而上分析方法，LR分析法属于自下而上分析方法等等。\n 通常用正规文法或正规式来描述程序设计语言的词法规则，而使用上下文无关文法来描述程序设计语言的语法规则。\n 语法分析阶段中，处理的输入数据是来自词法分析阶段的单词符号。它们是词法分析阶段的终结符。\n  7、 编译程序总框\n  8、 在计算机发展的早期阶段，内存较小的不能一次完成程序的编译。这时通常将编译过程分成若干遍来完成。每一遍完成一部分功能，称为多遍编译。 与采用高级程序设计语言写的词法分析器相比，用汇编语言写的词法分析通常分析速度要快些。\n  二. 词法与语法   1、 程序语言主要由语法和语义两个方面来定义。\n  2、 任何语言的程序都可看成是某字符集上的一个长字符串。\n  3、 语言的语法：是指这样的一组规则（即产生式），用它可以生成和产生一个良定的程序。这些规则的一部分称为词法规则，另一部分称为语法规则。\n  4、 词法规则：单词符号的形成规则；语法规则：语法单位（句子）的形成规则。语义规则：定义程序句子的意义。\n  5、 一个程序语言的基本功能是描述数据和对数据的运算。\n  6、 高级语言的分类：强制式语言；应用式语言；基于规则的语言；面向对象的语言。\n  7、 一个语言的字母表为{a,b}，则字符串ab的前缀有a、ε，其中ε不是真前缀。\n  8、 字符串的连接运算一般不满足交换率。\n  9、 文法G是一个四元组，或者说由四个元素构成，即非终结符集合VN、非终结符号集合VT 、开始符号S、产生式集合P，它可以形式化地表示成G =（VN，VT，S，P）。 按照文法的定义，这4个元素中终结符号集合是这个文法所规定的语言的字母表，产生式集合代表文法所规定的语言语法实体的集合。对上下文无关文法，通常我们只需要写出这个文法的产生式集合就可以确定这个文法的其他所有元素。其中，第一条产生式的左部符号为开始符号，而所有产生式的左部符号构成的集合就是该文法的非终结符集合。\n   文法的例子： 设文法G=（VN，VT， S，P），其中P为产生式集合，它的每个元素的形式为产生式。\n  10、如果文法G的一个句子存在两棵不同的最左语法分析树，则这个文法是无二义的。\n  11、如果文法G的一个句子存在两棵不同的最右语法分析树，则这个文法是无二义的。\n  12、如果文法G的一个句子存在两棵不同的语法分析树，则这个文法是无法判断是否是二义的。\n  13、A为非终结符，如果文法存在产生式 ，则称 可以推导出 ；反之，称 可归约为 。\n  14、乔姆斯基（Chomsky）将文法分为四类，即0型文法、1文法、2文法、3文法。 按照乔姆斯基对方法的分类，上下文无关文法是2型文法，2型文法的描述能力最 …","date":1396396800,"description":"","lastmod":"2014-04-02T00:00:00Z","objectID":"804ccadd98489d5ab35b54ff21dd5313","permalink":"/post/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","publishdate":"2014-04-02T00:00:00Z","tags":["go","golang","hugo","development"],"title":"编译原理"},{"categories":["Development","golang"],"content":"一、计算机的组成及学习大纲 1. 计算机的组成 计算机的三大件 ：CPU、内存、主板 （1）CPU，中央处理器，计算机最核心的配件，负责所有的计算。\n（2）内存，你编写的程序、运行的游戏、打开的浏览器都要加载到内存中才能运行，程序读取的数据、计算的结果也都在内存中，内存的大小决定了你能加载的东西的多少。\n（3）主板，存放在内存中数据需要被CPU读取，CPU计算完成后，还要把数据写入到内存中，然而CPU不能直接插在内存上，这就需要主板出马了，主板上很多个插槽，CPU和内存都是插在主板上，主板的芯片组和总线解决了CPU和内存之间的通讯问题，芯片组控制数据传输的流转，决定数据从哪里流向哪里，总线是实际数据传输的告诉公里，总线速度决定了数据的传输速度。\n（4）输入/输出设备，其实有了以上三大件之后，计算机就可以跑起来了。我们日常使用的话还需要键盘、鼠标、显示器等输入/输出设备，而很多云服务器通过SSH远程登录就可以访问，就不需要配显示器、鼠标、键盘这些东西，节省成本且方便维护。\n（5）硬盘，有了硬盘数据才能长久的保存下来，大部分还会给自己的机器配上机箱和风扇，解决灰尘和散热问题，不过这些也不是必须的，用纸板和电风扇替代也一样可以用。\n（6）显卡，显卡里有GPU图形处理器，主要负责图形渲染，使用图形界面操作系统的计算机，显卡是必不可少的。现在的主板都带了内置的显卡，如果想玩游戏、做图形渲染，一般需要一张单独的显卡，插在主板上。\n2. 冯·诺依曼体系 现代计算机的硬件基础架构都是依赖于冯诺依曼提出的冯诺依曼体系结构，现代计算机的核心架构可以抽象为五个基础组件：运算器、控制器、存储器、输入设备和输出设备。\n具体到现代计算机，运算器和控制器组成了现代计算机的CPU，存储器对应着内存和硬盘，主板控制着CPU、内存、硬盘、输出/输出设备之间的通讯。\n冯诺依曼体系结构也叫做存储程序计算机，即可编程、可存储的计算机。\n任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的。\n冯诺依曼体系结构确立了我们现代计算机的硬件基础架构，学习计算机组成原理，就是学习和拆解冯诺依曼体系。\n学习组成原理，就是学习以下内容：\n CPU（运算器+控制器）怎么工作，为什么这么设计； 内存和硬盘的工作原理； CPU是怎么和内存、硬盘、输入设备、输出设备通讯的； 从电路这样的硬件到最终开发给软件的接口是怎么运作的，为什么要这么设计，以及在软件开发层面怎么尽可能的用好它；  3. 计算机组成原理学习大纲 计算机组成原理知识地图\n学习大纲：  计算机的基本组成：冯诺依曼体系结构的五大基本组件：运算器、控制器、存储器、输入设备和输出设备；计算机的两个核心指标：性能和功耗。 计算机的指令和计算：高级语言是怎么跑起来的，怎么通过编译器和汇编器变成机器指令的；操作系统怎么链接、装载、执行程序的；指令的执行是怎么控制的（控制器）。 运算器，数据在计算机中的表示（二进制和编码）；计算机是怎么实现加法、乘法等基本运算功能的。 CPU的设计：我们为什么需要CPU时钟；寄存器和内存怎么组成的；整个计算机的数据通路是如何构造的；CPU的流水线设计；数据和控制冒险；分支预测；CPU的异常和中断机制；指令的并行执行；CPU怎么通过SIMD来支持并行计算。 存储器的原理：CPU高速缓存、内存、SSD硬盘和机械硬盘的工作原理，及它们之间的性能差异；CPU和存储器之间怎么通讯的；什么是IO_WAIT；如何通过DMA提升程序性能；如何保证存储器里的数据不丢失；如何通过RAID、Erasure Code、ECC、HDFS，这些不同的技术来确保数据的完整性和访问性能。  总结：计算机组成原理是整个计算机科学的纲要，这门课程的很多知识点深挖下去都会变成一个核心课程。\n例如：\n 计算是怎么实现的，对应着数字电路课程。 CPU和存储器系统的优化，对应着计算机体系结构课程。 程序通过编译器和汇编器变成机器指令的编译过程，对应着编译原理课程。 操作系统是怎么链接、装载、执行程序的，对应着操作系统课程。  二、下面我们根据课程大纲，大致过一遍组成原理 1. 性能 衡量计算机的性能，主要有两个指标：响应时间和吞吐率。\n 响应时间，就是执行一个程序花费的时间，花的时间越短，性能就越好。 吞吐率，就是一定时间内，到底能处理多少数据和指令，处理的越多，性能就越好。  我们一般把性能定义为响应时间的倒数，也就是：性能 = 1 / 响应时间\n响应时间也就是CPU执行我们程序的时间，我们对时间这个指标进行拆解，把程序的CPU执行时间变成CPU时钟周期数和时钟周期时间的乘积。\n程序的CPU执行时间 = CPU时钟周期数 x 时钟周期时间\n程序的CPU执行时间 = …","date":1396396800,"description":"","lastmod":"2014-04-02T00:00:00Z","objectID":"c2e7dfeab5fdbf6988b3b3921a6b32ea","permalink":"/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","publishdate":"2014-04-02T00:00:00Z","tags":["go","golang","templates","themes","development"],"title":"计算机组成原理"},{"content":" dos,lua,sheel,python,js\n   dos 可以使用VisualBat编辑器编写以及调试\n  lua 可以运行在redis ,dos,Java,c++等里面另外还可以用来写触屏精灵 http://www.touchsprite.com/docs/5362 ==\u0026amp;gt; https://www.zybuluo.com/miniknife/note/317045#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\n  sheel脚本 运行在linux或者unix上相当于windows上的dos\n  python 胶水语言 可以直接在linux当成sheel使用,也是人工智能的一种使用工具\n  js 浏览器脚本\n  ","date":1508253975,"description":"","lastmod":"2017-10-17T15:26:15Z","objectID":"644b8093b79ae2990e7f40fda0864d85","permalink":"/%E8%84%9A%E6%9C%AC/","publishdate":"2017-10-17T15:26:15Z","title":"脚本"},{"content":"  Java 消息中间件 RabbitMq 和 kafka (建议学习RabbitMq)\n  web socket or spring socket\n  springboot (spring cloud考虑)\n  redis (深入使用)\n  mysql 这次复习以往 突破 存储和锁 如行锁\n  java 并发(深入)\n  nio netty\n  ","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"1016eb8c2f3da52b81070f7ac850077a","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/2021-04%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/","publishdate":"2021-01-17T15:26:15Z","title":"学习计划"},{"content":"时间管理、精力管理、情绪管理 1、时间管理 改变自己从认识自己开始，管理时间也是从认识时间开始。 一开始，最好的方法就是记录时间，把每天花费的时间记录下来。 就像理财一样，先记录钱花在哪里，才知道哪些钱不该花，或者少花。记事本或者手写都行，怎么方便怎么来。\n第一阶段 可以这样简单记录，看看大块时间用在哪里。开会（0.5）吃饭（1.0）写作（2.0）刷抖音（3.0）写代码（4.0）你看，明显是刷抖音时间长，这个可以尽量减少或避免。\n第二阶段 记录具体时间和具体事件。 6:00 ~ 7:00 晨练 7:00 ~ 8:00 读书写作 8:00 ~ 9:00 去上班 9:00 ~ 11:00 工作 12:00 ~ 14:00 午休 14:00 ~ 16:00 梳理积分商城 16:00 ~ 16:30 休息 16:30 ~ 19:00 综合分析竞品商场 19:30 ~ 整理主要目的，看看哪个时间做了哪些事，具体花费多少时间，后边有大用。\n第三阶段 清晨安排三件事很多人不喜欢记录，太麻烦，记来记去也没什么改变。任何工具如果使用起来太复杂，就会有90%的人放弃。 清晨三件事，非常简单，也是我一直在用的。每天早晨起来，就按照重要程度，把当天最需要干完的三件事完成。 我今天最需要做完的三件事： 1.工作报告整理，各个项目组进度把控，协调资源。 2.跟客户谈具体合作事项。 3.公众号文章一篇，知乎问答一篇。工作时间，把前两项搞定，业余时间把最后一项搞定。 如果还剩下时间，我就会做一些长期规划的事，明天、后天，以及未来一个月需要准备做的事。做好以上这些，就能极大提升工作效率吗，不能。 你一定遇到过这种情况，时间很充足，坐在那里，啥也干不进去。比如，一下午过去了，报告一个字没有写，有时间，没状态。遇到这种情况，不是时间出了问题，而是你的精力出了问题。\n2、精力管理 有一本书《精力管理》，讲了精力来源的四个方面：体能、思维、情感、意志。我跟进自己的实践和观察，体能和思维对我影响很大。 体能也是精力最基本的来源。我记得上高中那会，早上为了节省饭钱，只吃馒头和方便面。那几天上早自习感觉特别累，总爱打瞌睡。 后来，吃了两个星期实在扛不住了，又去食堂吃饭了。那时候感觉特别饿，没精神，没有想过饮食这么重要。刚刚工作那会也是，早上不吃饭，死磕一上午，中午吃得又多犯困。 整个人一天的工作状态不是特别好，还好那会年轻，用精神力扛着。现在作息规律，早上跑步、读书，吃早饭。上午一般脑子清楚，一般做一些分析类工作。 午餐之后，会溜达一会，消消食，然后午睡。下午脑子不那么灵光，有一些疲倦，会做一些总结和整理工作。 晚上吃完饭，也有一个不错的状态，会做一些有创意的工作。一句话，你一定要在状态最好的时候，做最难最复杂的事。注意自己的精神状态，太疲惫了就休息一会，磨刀不误砍柴工。死磕的状态不能持续，要养成固定的习惯。\n3、情绪管理 做到以上两点，已经可以称为高手了。能够利用自己的情绪，高效率完成工作更是高手中的高手。有时间、精力充沛，但还是遇到一些工作，干不下去。 人人有七情六欲，当你发现自己不喜欢一项工作的时候，怎么都干不下去。这时候心里一直抵触，然后开始怀疑自己，是不是不适合做这个；欺骗自己，明天做也没关系。如果这件事对你很重要，就一定要逼自己做下去。 有一个小技巧：给自己1个小时的放空时间，在这个时间不带着情绪做事，不考虑要做的事有没有意义，有没有帮助，能够得到什么结果。把情绪放在做事上，不放在心里，在这一刻你可以把自己暂时当作没有情感的机器。 先不要急着否定我，你可以去试试，如果真的不好用，你可以来找我。我最开始写作的时候，最多能写500字，我看别人的文章动辄几千，心态直接就不好了。坐在椅子上，一直在想1000字太长了，根本写不出来，完不成。 没有把情绪用在内容上，而是用在否定自己上，情绪低落，心态消极。\n","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"0c8ea2d36a18136b45b64b471dcc363d","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/","publishdate":"2021-01-17T15:26:15Z","title":"自我提升"},{"content":"冥想 呼吸冥想法   1:坐好，后背挺直，然后闭上眼睛\n  2:关注你自己呼吸时的感觉,吸气，吸气，选择一个感受突出的地方，通常是你的鼻子或者耳朵、腹部然后集中注意力，关注你自己呼吸时的感觉。吸气，吸气，用嘴呼吸（最好关注腹部，因为我们大部分人都是腹部呼吸法）\n  3:一旦你开始这样做了脑子会乱想,你需要关注你到什么时候走神的，那么走神后重新调整后重新开始集中注意力开始冥想。\n  ","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"1ec5a38549993737d286bfe2468d38df","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E5%86%A5%E6%83%B3/","publishdate":"2021-01-17T15:26:15Z","title":"冥想"},{"content":"","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"ae5aa9025c234c1de9e72ee43a6cae40","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/","publishdate":"2021-01-17T15:26:15Z","title":"学习方法"},{"content":"","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"bd136bf7d0ab95b2a6308dcd051e3711","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%8E%B7%E5%8F%96%E9%87%91%E9%92%B1/","publishdate":"2021-01-17T15:26:15Z","title":"获取金钱"},{"content":"如何在油管YouTube开通收益赚钱？ 如果想在YouTube创业赚取美金，建议关注【YouTube运营笔记】，少走弯路，不被忽悠\n本篇主要由3个常见问题详细展开：  如何在油管上开通获利？ 油管广告收益情况如何？ 油管除了广告还能怎么赚钱？  一、如何在YouTube开通获利？ 第1步：你得有一个Gmail账号  YouTube账号是跟谷歌邮箱账号是关联的。想创建频道然后上传视频的基础条件就是，注册并登陆谷歌账号，目前一些国内手机注册会失败。   注：Gmail能登录就行，手机号码归属和注册地对后期收益不存在影响。\n 第2步：你得有一个YouTube频道  一般而言只要你有了谷歌账号，就默认有一个YouTube频道了，但那个频道名称头像是跟谷歌邮箱是挂钩的，建议单独创建频道。此外，一个谷歌账号是创建多个频道的。   注：创建频道前，要想清楚频道的内容定位；频道创建后，还要对频道进行装修。\n 第3步：你得有策略地上传视频  这一步非常重要，YouTube运营是一个技术活，不是随随便便发几个视频就有人看，也不是坚持发布就能做起来。有志要做的建议查看本专栏的其它文章，这里不细讲。   注：做YouTube成功的条件是「优质的内容+正确的方法」，缺一不可\n 第4步（重点）：你须达到获利门槛/申请开通  想开通获利，必须满足以下条件：   1:选择支持YouTube合作伙伴计划的国家或地区。 2:12 个月内的有效观看时长累计超过4000小时。 3:频道拥有至少1000订阅。 4:拥有可关联的 AdSense 帐号。   其中，最为关键的同时最难的条件是4000小时和1000名订阅；「国家/地区」后台设置支持的国家/地区即可；「AdSense」是在频道达到获利门槛后显示注册入口，看似简单却最容易出错，资料要仔细填写，一旦填错后续非常麻烦。《YouTube运营新手最常踩5大坑，最后1个最坑人！》 除了订阅者数量和观看次数要求外，还有内容要求。获利申请的审核是官方人工审核，如果审核者认为频道或视频不符合条件，也是容易无法通过的，审核时间快则一两天，慢的一个多月也有。《YouTube获利政策：这11类内容没有收益》  二、油管广告收益情况如何？  YouTube将部分广告收入（55%）分给相应的Youtuber，就能构成一个良性循环的三赢局面：广告商得到宣传，Youtuber赚钱，油管平台赚钱同时有源源不断的优质内容创作出来。平台把55%的广告收益分给视频创作者，这对自媒体从业者而言，真不算低。    YouTube的千次播放（CPM）的收益差距略大，一般在1-10美元不等。影响视频收益主要因素包括：\n  1:观看地区：发达国家cpm远高于发展中国家，如果你的观众主要来自发达国家收益则更高。\n  2:频道领域：某些领域的内容有更高的CPM，比如数码、经济类就相对高。\n  3:视频时长：超过8分钟的视频，可以无限插入广告，收益更多。\n  4:频道/视频：频道或者某个视频比较优质的，会获得更多优质广告展示。\n  另外，还会受其他重大事件影响，比如2020年受疫情影响，大部分频道的CPM大幅下跌。《新冠疫情对YouTube影响有多大？2020多数频道单价下跌20%以上》\n  三、油管除了广告还能怎么赚钱？   在油管做内容，广告收益是基本的收入保障，不过大部分YouTuber不会满足于只要广告收入。\n  油管除了一般广告收益方式，还有其他的变现方式。官方提供的变现方法还有：频道会员、商品搁架、超级留言和超级贴纸、YouTube Premium。这些功能需要较高的条件，同时收益不算太高。但自媒体变现总的而言离不开3大变现方式：广告、带货和打赏。\n    此外，国内常用的一些变现方法，在油管也是通用的，常见的有：\n  亚马逊联盟行销：类似国内的淘宝联盟，你帮商家带货后获取一定的佣金。\n  品牌合作推广：频道内容做得好，流量也够多，总会有商家来邀请你合作，这种方式的收益是比较高的。\n  电商带货：不同于联盟行销，联盟行销是帮别人卖自己拿佣金，而自己开店就可以获得更高的利润，当然也得投入更多的资源。\n  粉丝经济：如果你频道的粉丝粘度比较高，可以考虑做依靠粉丝赞助或者粉丝付费，此外目前兴起的直播打赏也是不错的变现方法。\n    这些是比较常见的变现方法，其实变现方法远不止这些。但是能否变现，能否获得更多的收益，其实核心还是靠内容：内容优质，流量多，那怎么变现都可以。\n  最后还想说，如果想在油管创业，最好把眼光放长远同时专心做好内容。做内容是一方面，油管还有很多旁门左道，赚大钱的自媒体团队往往不走寻常路，在此就不宜公开了。\n  如果想在YouTube创业赚钱，建议关注专栏【YouTube运营笔记】，少走弯路，不被忽悠。\n  YouTube闭坑指南：\n   …","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"19481ca06902e50c9fed0a4f406cb05d","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%8E%B7%E5%8F%96%E9%87%91%E9%92%B1/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B2%B9%E7%AE%A1youtube%E5%BC%80%E9%80%9A%E6%94%B6%E7%9B%8A%E8%B5%9A%E9%92%B1/","publishdate":"2021-01-17T15:26:15Z","title":"如何在油管YouTube开通收益赚钱"},{"content":"  原教程但是由于他使用的github的用户名做的域名映射器,这样不好的地方是有可能你使用自定义的方式建立github仓库名比如 English study,还有一个是他使用的阿里云的域名映射解析这些是老版本的\n  GitHub Pages 绑定来自阿里云的域名==原博客教程\n  我的使用 github url ==\u0026amp;gt; https://github.com/noatnu/studyDoc , 买的域名 http://www.zhouchenghua.com/  解析第一个设置   创建A记录，请将您的顶点域指向GitHub Pages的IP地址 https 解析ip,上面的192.30.252.153是http解析方式现在官方已经宣布过时了,选择下面任意一个都可以  185.199.108.153\r185.199.109.153\r185.199.110.153\r185.199.111.153\r 解析第二个设置    github 要做的事\n  创建 CNAME文件,写入www.zhouchenghua.com\n   这个是我设置github project 设置截图   ping 地址  C:\\Users\\noatn\u0026amp;gt;ping www.github.com\r正在 Ping github.com [13.250.177.223] 具有 32 字节的数据:\r请求超时。\r请求超时。\r请求超时。\r请求超时。\r13.250.177.223 的 Ping 统计信息:\r数据包: 已发送 = 4，已接收 = 0，丢失 = 4 (100% 丢失)，\rC:\\Users\\noatn\u0026amp;gt;ping www.github.com.noatnu.studyDoc\r正在 Ping www.github.com.noatnu.studyDoc [223.87.179.156] 具有 32 字节的数据:\r来自 223.87.179.156 的回复: 字节=32 时间=872ms TTL=54\r来自 223.87.179.156 的回复: 字节=32 时间=10ms TTL=54\r来自 223.87.179.156 的回复: 字节=32 时间=7ms TTL=54\r来自 223.87.179.156 的回复: 字节=32 时间=8ms TTL=54\r223.87.179.156 的 Ping 统计信息:\r数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\r往返行程的估计时间(以毫秒为单位):\r最短 = 7ms，最长 = 872ms，平均 = 224ms\r  223.87.179.156这是我的静态博客地址 223.87.179.156\n  192.30.252.153 还可以改为223.87.179.156 ,不过不建议改 因为我们自己查出的ip不是固定ip 而 92.30.252.153是Github Pages服务器指定的IP地址，访问该IP地址即表示访问Github Pages\n  现在ipv4已经分配完了,虽然北美，日本，欧洲，韩国，香港等地的企业商 还有ipv4申请但是其实是他们以前申请保留下来的\n  按照我上面的截图设置即可 ,然后把我的github project url 下载下来看一下\n  所以设置完毕会等一段时间,大概至少会超过1个小时,因为这里面牵扯到阿里云的解析是否解析了你的域名映射,当然这不包括你的域名购买时间，注册以及实名认证这些时间,虽然官方说的时间是挺短的,当你做这些才会一声叹息啊\n  ","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"7519bc5adc6ce85f64076c2963252e3b","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/githubpages%E7%BB%91%E5%AE%9A%E6%9D%A5%E8%87%AA%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%9F%9F%E5%90%8D/","publishdate":"2021-01-17T15:26:15Z","title":"GitHubPages绑定来自阿里云的域名"},{"content":"学习的最好方式是解决问题\n","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"44e34411eff083cdb0d0357aa50e4279","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/","publishdate":"2021-01-17T15:26:15Z","title":"解决问题"},{"content":"中国国内访问 GitHub 为什么很慢很卡甚至访问不了？如何加速访问 GitHub 网站？ 个人总结：强扭的瓜不甜，修改 hosts 也就片刻好光景，要不了多久就变得比没改 hosts 之前更慢。所以还是顺其自然就好，不要白费力气去修改 hosts。   摘要\n  网站分发加速网络的域名遭到 DNS 污染，DNS 不能直接找到那个最快的 IP！ 通过修改系统 hosts 文件的办法，绕过国内 DNS 解析，直接访问 GitHub 的 CDN 节点，从而达到加速的目的！\n  如何检验效果\n  操作之前先 ping 一下 github.com，两个请求超时，两个 93ms。\n  操作之后再 ping 一下 github.com，没有丢失，四个 287ms。\n  一、国内访问 GitHub 为什么很慢？  GitHub 的 CDN 域名遭到 DNS 污染，导致无法连接使用 GitHub 的加速分发服务器，才使得国内访问速度很慢。  二、如何解决 DNS 污染？  通过修改 Hosts 文件，将域名解析直接指向 IP 地址来绕过 DNS 的解析，以此解决污染问题。  三、具体操作步骤   1、打开 https://www.ipaddress.com/ 这个全球最好的 IP 地址查询工具网站来查询出域名当前对应的最优 IP。（不要用 ip168.com 这类国内的 IP 探针，其获取的国外域名的 ip 也是被 DNS 污染过的）\n  查询下面 3 个网址对应的 IP 地址\n  github.com : 140.82.113.4\n  assets-cdn.github.com : 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153\n  github.global.ssl.fastly.net : 199.232.69.194\n  2、修改本地电脑系统 hosts 文件\n  Windows 系统中的文件路径： C:\\WINDOWS\\system32\\drivers\\etc\n  Linux 系统中的文件路径 /etc/hosts\n  直接在最后面加入以下代码\n  192.30.253.112 github.com\r140.82.113.4 github.com\r185.199.108.153 assets-cdn.github.com\r199.232.69.194 github.global.ssl.fastly.net\r 说明：在 Windows 系统中，包括 XP、Win7、Win8 、Win10 系统中，hosts 文件的位置都是一样的。如果 etc 文件夹中并没有 hosts 文件，那么可能是该文件隐藏了，可以设置一下，让其显示出来即可。\n   3、 更新dns缓存\n  修改后会直接生效，无需刷新 DNS 缓存，因为 hosts 的优先级大于 DNS 域名解析，添加完 hosts 之后，再访问对应的域名，已经就与 DNS 没关系了。如果未生效，重启操作系统或用命令刷新。\n  Windows 系统：ipconfig /flushdns\n  Linux 系统：systemctl restart nscd\n  Mac 系统：sudo dscacheutil -flushcache或sudo killall -HUP mDNSResponder\n  ","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"3a711cccf67a6121aae0f8a51b6f7d74","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/dnf%E6%B1%A1%E6%9F%93/","publishdate":"2021-01-17T15:26:15Z","title":"DNS 污染"},{"content":"收集 git 出现的问题\n","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"9eda75bb1cb1cb57cf27b855c60044e6","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/git_andsower/","publishdate":"2021-01-17T15:26:15Z","title":"git出现的问题"},{"content":" Push master to origin/master was rejected by remote  有三种原因\r1:push的这个工程是其他人新建的，找她开通master权限后，再次push\r2:git 工程错误\rgit pull\rgit pull origin master\rgit pull origin master --allow-unrelated-histories\r3:github 设置原因\r勾选了Keep my email addresses private\r解决办法2种\r第一种 通知账户人员取消勾选\r第二种\r重新设置你的全局用户E-mail\rgit config --list 查看这个时候一定不对\r因此重新设置全局email\r重置上次提交的作者信息 git commit --amend --reset-author\rgit config --global user.name \u0026amp;quot;zch\u0026amp;quot;\rgit config --global user.email \u0026amp;quot;sdhshd@163.com\u0026amp;quot;\rok\r对了你如果使用的不是idea而是git\r那么抛出的错误非常明显\r如果抛出\rgit报错--\u0026amp;gt;! [remote rejected] master -\u0026amp;gt; master (push declined due to email privacy restrictions)\r那么一定是这个原因\r git clone时报RPC failed; curl 18 transfer closed with outstanding read data remaining 错误  原因1：缓存区溢出\rgit config http.postBuffer 524288000\r执行上面命令如果依旧clone失败，考虑可能原因2：网络下载速度缓慢\r解决方法：命令行输入\rgit config --global http.lowSpeedLimit 0\rgit config --global http.lowSpeedTime 999999\r如果依旧clone失败，则首先浅层clone，然后更新远程库到本地\rgit clone --depth=1 http://gitlab.xxx.cn/yyy/zzz.git\rgit fetch --unshallow\r error: RPC failed； curl 28 OpenSSL SSL_read: Connection was reset, errno 10054 fatal: expected  git config --global http.sslVerify \u0026amp;quot;false\u0026amp;quot;\r  Failed to connect to 127.0.0.1 port 1080: Connection refused\n  这是由于设置了动态代理(最好下面方法都试一遍\u0026amp;hellip;因为可能设置了不只一次o(╥﹏╥)o);\n  git查看\n  查询动态代理\rgit config --global http.proxy\rgit config --global https.proxy\r 若是有返回值  取消代理\rgit config --global --unset http.proxy\rgit config --global --unset httpx.proxy\r  git配置文件查看 打开c:\\Users\\当前用户里的.gitconfig文件(这个默认是隐藏文件), 将里面关于proxy的行删掉\n  环境变量查看 打开环境变量,查看查看用户变量和系统变量(两个都要看\u0026amp;hellip;.我就是两个都设置了o(╥﹏╥)o),将里面的http_proxy(也可能不是这个名字,但是看值是127.0.0.1:1080这种的就是了,或者有proxy),把这一行删掉就行\n  Failed to connect to github.com port 443: Timed out\n  D:\\IdeaProjects\\motorcycle\u0026amp;gt;git config --global --unset http.proxy\rD:\\IdeaProjects\\motorcycle\u0026amp;gt;git config --global --unset https.proxy\rD:\\IdeaProjects\\motorcycle\u0026amp;gt;\r  remote: HTTP Basic:Access denied fatal:Authentication failed for\n  最终解决方法，控制面板 \u0026amp;gt; 用户账户\n   然后找到 凭据管理器 选择Windows凭据   如图删除掉之前使 …","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"f52f8e90e6035a935e0f9a67c19e28bf","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/git_andsower/git%E5%A4%84%E7%90%86/","publishdate":"2021-01-17T15:26:15Z","title":"git处理网络和权限问题"},{"content":"收集 idea出现的问题\n","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"1f5ad62586c7aba0a4f23f10e5ce5d18","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/idea/","publishdate":"2021-01-17T15:26:15Z","title":"idea出现的问题"},{"content":" idea 解决working directory 设置到 target  test ng D:\\IdeaProjects\\java-se-study\rrun config $MODULE_DIR$\r","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"9f07a9b01f872aa336c0ec9e2532af25","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/idea/idea/","publishdate":"2021-01-17T15:26:15Z","title":"idea 解决working directory 设置到 target"},{"content":"收集 maven出现的问题\n","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"c7599f022e1bd153aced41729c84ebcb","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/maven/","publishdate":"2021-01-17T15:26:15Z","title":"maven出现的问题"},{"content":" idea导入项目出现Unable to import maven project: See logs for details提示\n 第一种解决办法   删除项目根目录下.idea文件夹\n  关闭idea工具，重新打开选择File-\u0026amp;gt;New-\u0026amp;gt;Project from the existing source ,选择刚才的项目根目，下一步：\n  一直点next，最后点击主工程的pom.xml 完成！\n  第二种   打开idea 的日志文件如果发现【Error】com.google.inject.CreationException: Unable to create injector\n  那么自定义配置Maven3.6.2报错 或者更高版本maven\n  原因：Maven3.6.2的版本兼容问题。\n  解决方法：重新下载较低版本Maven3.6.1及以下版本可以顺利解决。\n  用maven无论是新建项目还是导入没有下载到本地仓库的jar。出现了Unable to import maven project\n  打开cmd，ping localhost，显示一般故障\n  在左边控制栏，关闭防火墙，再开启防火墙 再次ping localhost，成功\n  对了 假如出现文件权限问题 那么更改maven的本地仓库地址\n  ","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"8317da47b8270ccc521881af4918de70","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/maven/idea%E8%A7%A3%E5%86%B3/","publishdate":"2021-01-17T15:26:15Z","title":"idea 问题解决"},{"content":"Visual Studio Code 过滤文件 不显示某些文件 效果  过滤工程中显示的文件 不显示某些类型的文件或文件夹  菜单  File/Preferences/ 搜索file exclude 选中workspack页签 添加一个过滤规则 如图:   ","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"8989a1ab1651a4f3a15c897c4448968a","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/visual_studio_code/visualstudiocode%E9%97%AE%E9%A2%98/","publishdate":"2021-01-17T15:26:15Z","title":"Visual Studio Code 问题解决方案"},{"content":"visual studio code\n","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"bc1b54c52c06b0d8ef66d413570701a7","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/visual_studio_code/","publishdate":"2021-01-17T15:26:15Z","title":"visual_studio_code"},{"content":"记忆方法  提高记忆的关键，在于想象和创意 编故事有助于提高记忆力  通过编故事，再加上逻辑或地点（后者更多一些）;\r编故事是加强了记忆桩之间的联系\r记忆和创造力  记忆本身与创造力密不可分 ， 训练记忆力在很大程度上取决于你的创造力  要想记住毫不相关的信息和扑克牌，\r首先就要把它们变成图像。\r通过这种方式，\r那些零散的信息才可能会建立某种联系\r联想 利用事物间的联系通过联想进行记忆的方法。\r联想是由当前感知或思考的事物想起有关的另一事物，\r或者由头脑中想起的一件事物，又引起想到另一件事物。\r由于客观事物是相互联系的，各种知识也是相互联系的，因而在思维中，\r联想是一种基本的思维形式，是记忆的一种方法。\r联想，就是当人脑接受某一剌激时，浮现出与该刺激有关的事物形象的心理过程。\r一般来说，互相接近的事物、相反的事物、相似的事物之间容易产生联想。\r用联想来增强记忆是一种很常用的方法。\r记忆的一种主要机能就是在有关经验中建立联系，思维中的联想越活跃，经验的联系就越牢固。\r如能经常形成联想和运用联想，就可增强记忆的效果。\r联想是有规律可循的，联想的规律有接近律、类似律、对比律、因果律等，有接近联想、类似联想、对比联想、因果联想。\r  联想不仅快速，而且它还不是一个简单、一维的东西。首先，你在联想中会加入一些情感因素，甚至还没回想起一段经历，就已经产生了某种情绪。\n  一旦学会动用感情和感官，还有逻辑和创造力，来与不同事物间建立联系，你的记忆能力就会大大提高。除此之外，你还会慢慢习惯放松大脑，以最快的速度在不同事物之间建立联系。瞬间联想之所以对提高记忆力如此重要，是因为一个人在瞬间建立的联系往往是最牢靠的\n  如何在两个并无联系的单词之间建立联系\u0026amp;ndash;记忆的关键，就在于将二者结合到一起。\n  如果没有过去的某些参照物作为参考，你就不能在两个概念( 包括单词、物体、活动等)之间建立联系。你的过去为你提供了某种经验，而正是这种经验可以帮助你由一个概念想到另一件概念。你的生活中发生的一切都像是积木中的模块，正是这一个个模块帮助你搭建了自己的人生大厦。要想在两个模块之间尽快建立联系，你需要用尽可能少的连接物来实现过渡。也就是说，要想从一件事情想到另外一件事情，最快的方式就是直接找到二者之间的联系\n   比如说我想记住两个单词：墙壁和小鸡。\r每个单词都能激发我丰富的联想，我必须找到某种连接物将两个单词连接起来。\r比如说：\r墙壁会让我想到一个相册，想找到我小时候放学后经常爬的墙等。\r随着联想越来越细致、快速，我突然想到了一个最明显的连接：一首叫\u0026amp;lt;\u0026amp;lt;小胖鸡\u0026amp;gt;\u0026amp;gt;的儿歌。\r好极了！小胖鸡坐着墙壁上，它是一个鸡蛋----而鸡蛋又是小鸡下的。\r这时我就会展开联想，想象一只小鸡坐在墙下下蛋。\r为了让这个联想更加生动，我想起了小时候我在唱歌时的样子，\r然后自然而然地想到了自己看着小鸡下蛋时吃吃发笑的情形。\r虽然我并不记得发生过这件事，但它却足以激发我的联想。\r这个过程听起来可能有些复杂、繁琐，但事实上，这在大脑中只是一瞬间发生的事情。\r链条法  如何使用链条法记住5个单词 小提琴、武士、箱子、项链、雪球  首先想想你突然听到小提琴发出的悠扬乐声。\r然后看到一个武士在演奏小提琴，\r你甚至可以清楚地看到他把小提琴放到下巴下面--这武士满副盔甲，很是搞笑。\r然后你看到他脚边放了一个箱子，可能颜色很鲜艳，也可能已经很破旧了。\r你打开箱子，发现里面有一挂价值连城的钻石项链，钻石反射阳光，分外耀眼。\r最后你转过头去，突然一个雪球砸中你的脸颊，你甚至感觉到右脸有些发疼。\r记住，你越练习动用五官来加强想象，你的大脑就会越熟悉这种练习，你也就越容易记住自己想象的场景。\r  要要记住五个单词以及单词之间的顺序，需要在单词之间建立联系\n  使用链条法，关键在于上下文，我们可以把本来毫不关联的信息连接起来，将其放到一个场景中，这样它们就会变得很容易记住了。\n  你想象的东西一定要合理，或者至少应该符合逻辑。它们可以有些出奇，甚至古怪，但从理论上一定是合理或可能的。\n  在使用链条法记忆时，一定要注意你所想象的故事顺序。最简单的办法是按照顺序用这些单词编一个故事，故事本身应当有一定的逻辑性，只有这样，你才能记住单词的顺序。在回忆时忘记任何一个单词，都说明你编的故事不够清晰。如果真是这样，建议换个故事试试。\n  路径记忆法   例子\n  第一个记忆桩：前门\n  第二个记忆桩：隔壁邻居家的房子\n  第三个记忆桩：公共汽车站\n  第四个记忆桩：商店\n  第五个记忆桩：停车场\n  在设计了固定的路径，并为每张扑克设定了一个具体的物体代码之后，我要做的就是把扑克放在路径中适当的记忆桩。\r比如说翻开的前5张牌是:方块6、黑桃3、梅花5、红桃8、方块4。记忆方式如下:\r …","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"c4e0038c92a2dde396f83e1a3ef9a2df","permalink":"/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/%E8%AE%B0%E5%BF%86/","publishdate":"2021-01-17T15:26:15Z","title":"记忆方法"}]
