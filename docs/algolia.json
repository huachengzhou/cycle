[{"content":"Java Theme Java技术体系 消息队列,nosql,sql,dubbo,zookeeper,nginx,springcloud,springboot,spring,jpa,mybatis\rjava语法，java多线程与并发,jdbc,设计模式\r","date":1508426775,"description":"Text about this post","lastmod":"2019-10-26T15:26:15Z","objectID":"3976528693a0108357f4928017600865","permalink":"https://huachengzhou.github.io/cycle/","publishdate":"2018-11-23T15:26:15Z","title":"Home title"},{"content":"一、编码  如果还没想清楚，就用蛮力算法。——Ken Thompson 不要使用反正弦和反余弦函数——你总能用优美的恒等式，或者是计算向量点积来更好地解决问题。—— Jim Conyngham 在存储日期中的年份的时候，请使用四位数字。—— David Martin 避免使用不对称结构。—— Andy Huber 代码写的越急，程序跑得越慢。—— Roy Carlson 你用英语都写不出来的东西就别指望用代码写了。—— Peter Halpern 如果代码和注释不一致，那很可能两者都错了。—— Norm Schryer 如果你发现特殊情况太多，那你肯定是用错方法了。—— Carig Zerouni 先把数据结构搞清楚，程序的其余部分自现。—— David Jones  二、用户界面  尽可能让用户界面风格保持一致和可预测。—— 匿名用户 计算机生成的输入通常会让一个原本设计接受手工输入的程序不堪重负。—— Dennis Ritchie 手工填写的表单里有20%都包含坏数据。—— Vic Vyssotsky 80%的表单会要你回答没有必要的问题。—— Mike Garey 不要让用户提供那些系统已经知道的信息。—— Rick Lemons 所有数据集的80%中，有95%的信息量都可以用清晰的图表示。—— William Cleveland  三、调试  在我所有的程序错误中，80%是语法错误，剩下20%里，80%是简单的逻辑错误，在剩下4%里，80%是指针错误，只有余下的0.8%才是困难的问题。—— Marc Donner 在系统测试阶段找出并修正错误，要比开发者自己完成这一工作多付出2倍的努力。而当系统已经交付使用之后找出并修正错误，要比系统测试阶段多付出9倍的努力。因此，请坚持让开发者进行单元测试吧。—— Larry Bernstain 不要站着调试程序，那会使得你的耐心减半，你需要的是全神贯注。—— Dave Storer 别在注释里陷得太深——注释很可能会误导你，你要调试的只是代码。—— Dave Storer 测试只能证明程序有错误，而不能证明程序没有错误。—— Edsger Dijkstra 新系统的每一个新用户都可能发现一类新的错误。—— Brian Kernighan 东西没坏，就别乱修。 —— Ronald Reagan 如果我们没能力修好它，我们就会告诉你它根本没坏。—— Walt Weir 修正程序错误的第一步是要重现这个错误。—— Tom Duff  四、性能  程序优化第一法则：不要优化。程序优化第二法则：还是不要优化。—— Michael Jackson 对于那些快速算法，我们总是可以拿一些速度差不多但是更容易理解的算法来替代它们。—— Douglas Jones 在一些机器上，间接寻址比基址寻址要慢，所以请把结构体或者记录中最常用的成员放在最前面。—— Mike Morton 在一个非IO密集型程序中，超过一半的运行时间是花在不足4%的代码上的。—— Don Knuth 在优化一个程序之前，请先用性能监视工具找到程序的“热点”。—— Mike Morton 当你为了加速，把一页代码变成几条简单的指令时，请不要忘了增加注释，以使源码的行数保持为一个常量。—— Mike Morton 如果程序员自己模拟实现了一个构造比编译器本身实现的那个构造还要快，那编译器的作者也太失败了。—— Guy Steele 要加速一个IO密集型程序，请首先考虑所有的IO，消除那些不必要的或冗余的IO，并使余下的部分尽可能地块。—— David Martin 最快的IO就是不IO。—— Nils-Peter Nelson 那些最便宜、最快而且可靠性最高的计算机组件压根就不存在。—— Gordon Bell 把一个本来就错了的程序变得更糟糕绝不是你的错。—— Bill McKeeman Lisp程序员知道所有东西的值，却不知道那些东西的计算成本。—— Alan Perlis  五、文档  如果一句话反过来就必然不成立，那就根本没必要把这句话放进文档。—— Bob Martin 当你试图解释一条命令、一个语言特性或者是一种硬件的时候，请首先说明它要解决什么问题。 —— David Martin 一个 { 规格说明、设计、过程、测试计划 } 如果不能在一页A4纸上写明白，那么这个东西别人就没法理解。—— Mark Ardis 纸上的工作没结束，整个工作也就还没结束。—— 匿名  六、软件管理  系统的结构反映出构建该系统的组织的结构。—— Richard Fairley 别坚持做没用的事情。—— 匿名 前90%的代码占用了90%的预定开发时间，余下的10%代码又花费了90%的预定开发时间。——Tom Cargill 只有不到10%的 …","date":1491696000,"description":"","lastmod":"2017-04-09T00:00:00Z","objectID":"6083a88ee3411b0d17ce02d738f69d47","permalink":"https://huachengzhou.github.io/cycle/about/","publishdate":"2017-04-09T00:00:00Z","title":"关于程序员"},{"content":"目录  网络体系结构 物理层 数据链路层 网络层 传输层 应用层  st=\u0026amp;gt;start: 开始\rop=\u0026amp;gt;operation: My Operation\rcond=\u0026amp;gt;condition: Yes or No?\re=\u0026amp;gt;end\rst-\u0026amp;gt;op-\u0026amp;gt;cond\rcond(yes)-\u0026amp;gt;e\rcond(no)-\u0026amp;gt;op\r\u0026amp;amp;```\r","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"cb297a4f2f51d1a7f942af59f3aa30c1","permalink":"https://huachengzhou.github.io/cycle/computer_network/","publishdate":"2021-04-15T00:00:00Z","title":"计算机网络 "},{"content":"回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"31e43c7ee446e19e0667f5ad4aec8825","permalink":"https://huachengzhou.github.io/cycle/computer_network/application_layer/","publishdate":"2021-04-15T00:00:00Z","title":"应用层 "},{"content":"回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"b834aeb617f016f80dd5e0fd70939e0f","permalink":"https://huachengzhou.github.io/cycle/computer_network/data_link_layer/","publishdate":"2021-04-15T00:00:00Z","title":"数据链路层 "},{"content":"计算机网络 概念  计算机网络是互连的、自治的计算机集合。  组成  组成部分:硬件、软件、协议 1 工作方式:边缘部分、核心部分 2 功能组成:通信子网、资源子网  分类  1 分布范围:广域网、城域网、局域网、个人区域网 2 使用者: 公用网、专用网 3 交换技术:电路交换、报文交换、分组交换 4 拓扑结构:总线型、星型、环型、网状型 5 传输技术:广播式、点对点  功能  1:数据通信 2:资源共享 3:分布式处理、提高可靠性、负载均衡  回到上一级 ","date":-62135596800,"description":"","objectID":"afa8f6ff9f945a9552b7898985de55c0","permalink":"https://huachengzhou.github.io/cycle/computer_network/network_architecture/1.1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E5%BF%B5-%E7%BB%84%E6%88%90-%E5%8A%9F%E8%83%BD-%E5%88%86%E7%B1%BB/","title":"计算机概念 组成 功能 分类 * "},{"content":"标准的分类 法定标准  由权威机构制定的正式的、合法的标准 OSI  事实标准  某些公司的产品在竞争中占据了主流 ， TCP/IP 时间长了，这些产品中的协议和技术就成了标准  RFC   因特网标准的形式 (4个阶段)\n  1:因特网草案\n  2:建议标准\n  3:草案标准\n  4:因特网标准\n  国际标准化组织 ISO (最重要) 国际电信联盟 ITU 国际电气电子工程协会 IEEE 回到上一级 ","date":-62135596800,"description":"","objectID":"b03a7d2475945461d9f8ddeffb57fb6b","permalink":"https://huachengzhou.github.io/cycle/computer_network/network_architecture/1.1.2%E6%A0%87%E5%87%86%E5%8C%96%E5%B7%A5%E4%BD%9C%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%84%E7%BB%87/","title":"标准的分类"},{"content":"速率  速率即数据率或称数据传输率或比特率\n  速率即数据率或称数据传输率或比特率 比特 1/0 位 连接在计算机网络上的主机在数字信道上传输数据位数的速率 单位是b/s , kb/s,Gb/s,Gb/s ,Tb/s 发送端 ==\u0026amp;gt; 接收端 速率是10b/s 0101010101  宽带  \u0026amp;ldquo;带宽\u0026amp;quot;原本指某个信号具有的频道宽度，即最高频率与最低频率之差，单位是赫兹(Hz) 计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的\u0026amp;quot;最高数据率\u0026amp;rdquo;。单位是\u0026amp;quot;比特/秒\u0026amp;quot;  吞吐量  表示在单位时间内通过某个网络(或信道、接口)的数据量。单位b/s,kb/s,Mb/s 吞吐量受网络的带宽或网络的额定速率的限制   时延   时延 = 发送时延 + 传播时延 + 排队时延 + 处理时延\n  发送时延 : 从发送分组的第一个比特算起，到分组的最后一个比特发送完毕所需的时间(分组交换/路由器将数据推到信道上的时间)\n  传播时延 : 这里看什么介质来传播数据 计算机网络中是 数字信号 -\u0026amp;gt; 模拟信号 因此假如是光纤那么传播速度非常快2x⑩9 当然也有用无线电波我个人不知道无限电波是怎样模拟的无法知道速度究竟怎样,公示 传播时间 = 数据长度 / 传播速率(发送速率,带宽)\n  排队时延 : 等待输出/入链路可用\n  处理时延 : 检查找出口 (如果大陆地区还会有数据拆分与重新组合过滤检查)\n  时延带宽积 (可以理解为物理中的长度)  时延带宽积 = 传播时延 x 带宽 (时间 x 速度)  往返时延RTT   从发送方发送数据开始，到发送方收到接收方的确认\n  RTT 包括 往返传播时延 = 传播时延 * 2 ，末端处理时间\n  利用率 (信道利用率 , 网络利用率)   信道利用率 有数据通过时间 / 总体通过时间(有无数据通过时间)\n  网络利用率 信道利用率加权平均值\n  回到上一级 ","date":-62135596800,"description":"","objectID":"63f13303053a3e4b59ab6502d63c37bc","permalink":"https://huachengzhou.github.io/cycle/computer_network/network_architecture/1.1.3%E9%80%9F%E7%8E%87%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/","title":"速率"},{"content":"*[·-·]:注释内容\n计算机概念 组成 功能 分类 标准化工作及相关组织  法定标准 事实标准  分层参考模型 7层 , 4层 ,5层  计算机概念-组成-功能-分类 标准化工作及相关组织 速率相关的性能指标 分层结构 分层参考模型 模型层次详解  回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"50a32203e5a1d76d25cb849eba0b608e","permalink":"https://huachengzhou.github.io/cycle/computer_network/network_architecture/","publishdate":"2021-04-15T00:00:00Z","title":"网络体系结构"},{"content":"   名称 英文 作用     应用层 Application Layer 直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。如HTTP、SMTP、FTP、DNS等   表示层 Presentation Layer 把数据转换为能与接收者的系统格式兼容并适合传输的格式，即让两个系统可以交换信息   会话层 Session Layer 负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接   传输层 Transport Layer 负责端到端通讯，可靠传输，不可靠传输 ，流量控制，复用分用   网络层 Network Layer 负责选择路由最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)，拥塞控制   数据链路层 Data Link Layer 帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)   物理层 Physical Layer 定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快    回到上一级 ","date":-62135596800,"description":"","objectID":"8d7f7829f7ade13952cf79f864cd3cad","permalink":"https://huachengzhou.github.io/cycle/computer_network/network_architecture/%E5%88%86%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/","title":"分层参考模型"},{"content":"为什么要分层，分层要做什么  （1）发起通信的计算机必须将数据通信的通路进行激活。 （2）要告诉网络如何识别目的主机。 （3）发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。 （4）发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。 （5）确保差错和意外可以解决。  正式认识分层结构  使用 协议 ，服务， 接口 来完成分层\n 总结  网络体系结构是从功能上描述计算机网络结构 计算机网络体系结构简称网络体系结构是分层结构 每层遵循某个/多个网络协议以完成本层功能 计算机网络体系结构是计算机网络的各层及其协议的集合 上层要求服务 下层提供服务 实际是上层制定接口标准，下层实现接口标准  回到上一级 ","date":-62135596800,"description":"","objectID":"6ca6ac1cf3948fe20260a4df3bada6b7","permalink":"https://huachengzhou.github.io/cycle/computer_network/network_architecture/%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/","title":"分层结构"},{"content":"计算机网络分成结构 7层OSI参考模型 4层TCP/IP参考模型 5层体系结构 ISO/OSI模型怎么来的 ISO/OSI参考模型 ISO/OSI参考模型解释通信过程 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 OSI参考模型 与 TCP/IP参考模型 OSI参考模型与TCP/IP参考模型 相同点  1:都分层 2:基于独立的协议栈的概念 3:可以实现异构网络互联  不同点 面向连接分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。\r只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。\r而面向无连接没有这么多阶段，它直接进行数据传输。\r    ISO/OSI参考模型 TCP/IP模型     网络层 无连接 + 面向连接 无连接   传输层 面向连接 无连接 + 面向连接    五层参考模型  综合了OSI和TCP/IP的优点\n    参考层 说明     应用层 支持各种网络应用 FTP\\SMTP\\HTTP   传输层 进程-进程的数据传输 TCP\\UDP   网络层 源主机到目的主机的数据分组路由与转发 IP\\ICMP\\OSPF   数据链路层 把网络层传下来的数据报组装成帧 Ethernet ppp   物理层 比特传输    5层参考模型的数据封装与解封装 回到上一级 ","date":-62135596800,"description":"","objectID":"5423edd029372887bdb860cfc5d47ca0","permalink":"https://huachengzhou.github.io/cycle/computer_network/network_architecture/%E6%A8%A1%E5%9E%8B%E5%B1%82%E6%AC%A1%E8%AF%A6%E8%A7%A3/","title":"模型层次详解"},{"content":"回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"99e8c1515c2e9a3098ef3b8d43f7261c","permalink":"https://huachengzhou.github.io/cycle/computer_network/network_layer/","publishdate":"2021-04-15T00:00:00Z","title":"网络层 "},{"content":" 物理层基本概念 数据通信基础知识  回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"253a4629679c5a0613b021b87df3b45d","permalink":"https://huachengzhou.github.io/cycle/computer_network/physical_layer/","publishdate":"2021-04-15T00:00:00Z","title":"物理层 "},{"content":"典型的数据通信模型 数据通信相关术语  通信的目的是传送消息(消息:语音、文字、图像、视频等)。\n   信号:数据的电气/电磁的表现，是数据在传输过程中的存在形式。\n  数字信号/离散信号:代表消息的参数的取值是离散的\n   模拟信号/连续信号:代表消息的参数的取值是连续的   信源:产生和发送数据的源头。 信宿:接收数据的终点。 信道:信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。   信道  按传输信号分 模拟信道(传送模拟信号) 数字信道(传送数字信号) 按传输介质分 无线信道 有线信道    设计数据通信系统要考虑的三个问题 采用单工通信(只有一个方向)/半双工通信(回合制)/全双工通信(可以同时如擂台上拳击手打击) * 采用串行通信/并行通信 采用同步通信/异步通信 串行传输\u0026amp;amp;并行传输 同步传输\u0026amp;amp;异步传输 回到上一级 ","date":-62135596800,"description":"","objectID":"3523706943daeb0b37115965b5c6b8f4","permalink":"https://huachengzhou.github.io/cycle/computer_network/physical_layer/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"数据通信基础知识 "},{"content":"物理层接口特性  物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 物理层主要任务：确定与传输媒体接口有关的一些特性 ==\u0026amp;gt; 定义标准\n  1.机械特性 定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量、排列情况  2.电器特性 规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制。 某网络在物理层规定，信号的电平用+10V~+15V表示二进制0，用-10V~-15V表示二进制1，电线长度限于15m以内 3.功能特性 指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。 描述一个物理层接口引脚处于高电平时的含义 4.过程特性 定义各条物理线路的工作规程和时序关系。  回到上一级 ","date":-62135596800,"description":"","objectID":"57771b4fcbe5c05f6a88adf791ecebf5","permalink":"https://huachengzhou.github.io/cycle/computer_network/physical_layer/%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"物理层基本概念 "},{"content":"回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"9d3228526ac4e54bf6e1766031c62a02","permalink":"https://huachengzhou.github.io/cycle/computer_network/transport_layer/","publishdate":"2021-04-15T00:00:00Z","title":"传输层 "},{"categories":["mysql","sql"],"content":" 数据库，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据进行新增、查询、更新、删除等操作。\n 目录  数据库基础  1.1-认识MySQL 1.2-轻松安装MySQL 1.3-MySQL数据库连接 1.4-SQL语言入门 1.5-认识DBA   MySQL数据库对象与应用  2.1-MySQL数据类型 2.2-MySQL数据对象 2.3-MySQL权限管理 2.4-SQL语言进阶 2.5-内置函数 2.6-触发器与存储过程 2.7-MySQL字符集 2.8程序连接MySQL 2.9-DAO框架的使用   MySQL事务与存储引擎  3.1-数据库事务 3.2-存储引擎概述 3.3-InnoDB存储引擎 3.4-InnoDB事务锁   MySQL应用优化  4.1-MySQL索引优化与设计 4.2-MySQL数据库设计 4.3-MySQL容量评估 4.4-MySQL性能测试   MySQL运维实践  5.1-MySQL日志系统 5.2-MySQL数据备份 5.3-MySQL数据恢复 5.4-MySQL线上部署 5.5-MySQL主从复制 5.6-MySQL日常运维 5.7-MySQL参数调优    ","date":1554163200,"description":"","lastmod":"2019-04-02T00:00:00Z","objectID":"a9d7e48e44765565bd2b10b66dc01682","permalink":"https://huachengzhou.github.io/cycle/databases/","publishdate":"2019-04-02T00:00:00Z","tags":["mysql","sql"],"title":" 数据库"},{"content":"mysql学习笔记 windows下 Mysql安装 windows下 Mysql安装的一些问题解决方法 mysql查询数据准备 mysql事务 mysql函数 mysql存储引擎 mysql查询 mysql用户与权限 开发规范 数据库设计三范式 mysql索引 MySQL分库分表原理 回到上一级 ","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"458a630ac86a8d13c66326bd2ee1c878","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/","publishdate":"2021-01-17T15:26:15Z","title":"mysql学习笔记"},{"content":"  停止命令：net stop mysql\n  启动命令：net start mysql\n  登陆 mysql -u 用户名 -p\n  查看数据库版本: mysql \u0026amp;ndash;version：用于在未登录情况下，查看本机mysql版本,select version();：登录情况下，查看链接的库版本\n  显示所有数据库：show databases;\n  进入指定的库：use 库名;\n  显示当前库中所有的表：show tables;\n  查看其他库中所有的表：show tables from 库名;\n  查看表的创建语句：show create table 表名;\n  查看表结构：desc 表名;\n  SQL的语言分类 DQL（Data Query Language）：数据查询语言\rselect 相关语句\rDML（Data Manipulate Language）：数据操作语言\rinsert 、update、delete 语句\rDDL（Data Define Languge）：数据定义语言\rcreate、drop、alter 语句\rTCL（Transaction Control Language）：事务控制语言\rset autocommit=0、start transaction、savepoint、commit、rollback\rmysql语法规范 不区分大小写，但建议关键字大写，表名、列名小写\r每条命令最好用英文分号结尾\r每条命令根据需要，可以进行缩进或换行\r注释\r单行注释：#注释文字\r单行注释：-- 注释文字 ，注意， 这里需要加空格\r多行注释：/* 注释文字 */\rMySQL删除数据库中的所有表 SELECT CONCAT(\u0026#39;drop table \u0026#39;,table_name,\u0026#39;;\u0026#39;) FROM information_schema.`TABLES` WHERE table_schema=\u0026#39;数据库名\u0026#39;;\r# 然后复制结果 然后重新执行\r回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"84bd63b05f13307c70ec812bfa50339c","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/mysql_basis/","publishdate":"2020-01-17T15:26:15Z","title":"基本命令"},{"content":" 数据准备  数据准备\ndrop datbase ch10;\rcreate database ch10;\ruse ch10;\rCREATE TABLE fruits\r(\rf_id char(10) NOT NULL,\rs_id INT NOT NULL,\rf_name char(255) NOT NULL,\rf_price decimal(8,2) NOT NULL,\rPRIMARY KEY(f_id) );\rINSERT INTO fruits (f_id, s_id, f_name, f_price)\rVALUES(\u0026#39;a1\u0026#39;, 101,\u0026#39;apple\u0026#39;,5.2),\r(\u0026#39;b1\u0026#39;,101,\u0026#39;blackberry\u0026#39;, 10.2),\r(\u0026#39;bs1\u0026#39;,102,\u0026#39;orange\u0026#39;, 11.2),\r(\u0026#39;bs2\u0026#39;,105,\u0026#39;melon\u0026#39;,8.2),\r(\u0026#39;t1\u0026#39;,102,\u0026#39;banana\u0026#39;, 10.3),\r(\u0026#39;t2\u0026#39;,102,\u0026#39;grape\u0026#39;, 5.3),\r(\u0026#39;o2\u0026#39;,103,\u0026#39;coconut\u0026#39;, 9.2),\r(\u0026#39;c0\u0026#39;,101,\u0026#39;cherry\u0026#39;, 3.2),\r(\u0026#39;a2\u0026#39;,103, \u0026#39;apricot\u0026#39;,2.2),\r(\u0026#39;l2\u0026#39;,104,\u0026#39;lemon\u0026#39;, 6.4),\r(\u0026#39;b2\u0026#39;,104,\u0026#39;berry\u0026#39;, 7.6),\r(\u0026#39;m1\u0026#39;,106,\u0026#39;mango\u0026#39;, 15.6),\r(\u0026#39;m2\u0026#39;,105,\u0026#39;xbabay\u0026#39;, 2.6),\r(\u0026#39;t4\u0026#39;,107,\u0026#39;xbababa\u0026#39;, 3.6),\r(\u0026#39;m3\u0026#39;,105,\u0026#39;xxtt\u0026#39;, 11.6),\r(\u0026#39;b5\u0026#39;,107,\u0026#39;xxxx\u0026#39;, 3.6);\rCREATE TABLE customers\r(\rc_id int NOT NULL AUTO_INCREMENT,\rc_name char(50) NOT NULL,\rc_address char(50) NULL,\rc_city char(50) NULL,\rc_zip char(10) NULL,\rc_contact char(50) NULL,\rc_email char(255) NULL,\rPRIMARY KEY (c_id)\r);\rINSERT INTO customers(c_id, c_name, c_address, c_city, c_zip, c_contact, c_email) VALUES(10001, \u0026#39;RedHook\u0026#39;, \u0026#39;200 Street \u0026#39;, \u0026#39;Tianjin\u0026#39;, \u0026#39;300000\u0026#39;, \u0026#39;LiMing\u0026#39;, \u0026#39;LMing@163.com\u0026#39;),\r(10002, \u0026#39;Stars\u0026#39;, \u0026#39;333 Fromage Lane\u0026#39;,\r\u0026#39;Dalian\u0026#39;, \u0026#39;116000\u0026#39;, \u0026#39;Zhangbo\u0026#39;,\u0026#39;Jerry@hotmail.com\u0026#39;),\r(10003, \u0026#39;Netbhood\u0026#39;, \u0026#39;1 Sunny Place\u0026#39;, \u0026#39;Qingdao\u0026#39;, \u0026#39;266000\u0026#39;,\r\u0026#39;LuoCong\u0026#39;, NULL),\r(10004, \u0026#39;JOTO\u0026#39;, \u0026#39;829 Riverside Drive\u0026#39;, \u0026#39;Haikou\u0026#39;, \u0026#39;570000\u0026#39;, \u0026#39;YangShan\u0026#39;, \u0026#39;sam@hotmail.com\u0026#39;);\rCREATE TABLE orderitems\r(\ro_num int NOT NULL,\ro_item int NOT NULL,\rf_id char(10) NOT NULL,\rquantity int NOT NULL,\ritem_price decimal(8,2) NOT NULL,\rPRIMARY KEY (o_num,o_item)\r) ;\rINSERT INTO orderitems(o_num, o_item, f_id, quantity, item_price)\rVALUES(30001, 1, \u0026#39;a1\u0026#39;, 10, 5.2),\r(30001, 2, \u0026#39;b2\u0026#39;, 3, 7.6),\r(30001, 3, \u0026#39;bs1\u0026#39;, 5, 11.2),\r(30001, 4, \u0026#39;bs2\u0026#39;, 15, 9.2),\r(30002, 1, \u0026#39;b3\u0026#39;, 2, 20.0),\r(30003, 1, \u0026#39;c0\u0026#39;, 100, 10),\r(30004, 1, \u0026#39;o2\u0026#39;, 50, 2.50),\r(30005, 1, \u0026#39;c0\u0026#39;, 5, 10),\r(30005, 2, \u0026#39;b1\u0026#39;, 10, 8.99),\r(30005, 3, \u0026#39;a2\u0026#39;, 10, 2.2),\r(30005, 4, \u0026#39;m1\u0026#39;, 5, 14.99);\rCREATE TABLE suppliers\r(\rs_id int NOT NULL AUTO_INCREMENT,\rs_name char(50) NOT NULL,\rs_city char(50) NULL,\rs_zip …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"9cc32df3e1fe5a008b4e80c45f61345a","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/mysql_data/","publishdate":"2020-01-17T15:26:15Z","title":"数据准备"},{"content":"前言 在互联网还未崛起的时代,我们的传统应用都有这样一个特点：访问量、数据量都比较小，单库单表都完全可以支撑整个业务。\r随着互联网的发展和用户规模的迅速扩大,对系统的要求也越来越高。因此传统的MySQL单库单表架构的性能问题就暴露出来了。而有下面几个因素会影响数据库性能:\r 数据量  MySQL单库数据量在5000万以内性能比较好,超过阈值后性能会随着数据量的增大而变弱。\rMySQL单表的数据量是500w-1000w之间性能比较好,超过1000w性能也会下降。\r 磁盘  因为单个服务的磁盘空间是有限制的,如果并发压力下,所有的请求都访问同一个节点,肯定会对磁盘IO造成非常大的影响。\r 数据库连接  数据库连接是非常稀少的资源,如果一个库里既有用户、商品、订单相关的数据,当海量用户同时操作时,数据库连接就很可能成为瓶颈。\r为了提升性能,所以我们必须要解决上述几个问题,那就有必要引进分库分表。\r垂直拆分 or 水平拆分？ 当我们单个库太大时,我们先要看一下是因为表太多还是数据量太大，如果是表太多,则应该将部分表进行迁移(可以按业务区分),这就是所谓的垂直切分。\r如果是数据量太大,则需要将表拆成更多的小表,来减少单表的数据量,这就是所谓的水平拆分。\r垂直拆分  垂直分库  垂直分库针对的是一个系统中的不同业务进行拆分,比如用户一个库,商品一个库,订单一个库。 一个购物网站对外提供服务时,会同时对用户、商品、订单表进行操作。没拆分之前, 全部都是落到单一的库上的,这会让数据库的单库处理能力成为瓶颈。如果垂直分库后还是将用户、商品、订单放到同一个服务器上,只是分到了不同的库,这样虽然会减少单库的压力,但是随着用户量增大,这会让整个数据库的处理能力成为瓶颈,还有单个服务器的磁盘空间、内存也会受非常大的影响。 所以我们要将其拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。\r 垂直分表  也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。\r水平拆分  水平分表  和垂直分表有一点类似,不过垂直分表是基于列的,而水平分表是基于全表的。水平拆分可以大大减少单表数据量,提升查询效率。\r 水平分库分表  将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。\r几种常用的分库分表的策略  HASH取模  假设有用户表user,将其分成3个表user0,user1,user2.路由规则是对3取模,当uid=1时,对应到的是user1,uid=2时,对应的是user2。\r 范围分片  从1-10000一个表,10001-20000一个表。\r 地理位置分片  华南区一个表,华北一个表。\r 时间分片  按月分片，按季度分片等等,可以做到冷热数据。\r分库分表后引入的问题  分布式事务问题  如果我们做了垂直分库或者水平分库以后,就必然会涉及到跨库执行SQL的问题,这样就引发了互联网界的老大难问题-\u0026amp;quot;分布式事务\u0026amp;quot;。那要如何解决这个问题呢？\r1.使用分布式事务中间件 2.使用MySQL自带的针对跨库的事务一致性方案(XA),不过性能要比单库的慢10倍左右。3.能否避免掉跨库操作(比如将用户和商品放在同一个库中)\r 跨库join的问题  分库分表后表之间的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表， 结果原本一次查询能够完成的业务，可能需要多次查询才能完成。粗略的解决方法： 全局表：基础数据，所有库都拷贝一份。 字段冗余：这样有些字段就不用join去查询了。 系统层组装：分别查询出所有，然后组装起来，较复杂。\r 横向扩容的问题  当我们使用HASH取模做分表的时候,针对数据量的递增,可能需要动态的增加表,此时就需要考虑因为reHash导致数据迁移的问题。\r 结果集合并、排序的问题  因为我们是将数据分散存储到不同的库、表里的,当我们查询指定数据列表时,数据来源于不同的子库或者子表,就必然会引发结果集合并、排序的问题。如果每次查询都需要排序、合并等操作,性能肯定会受非常大的影响。走缓存可能一条路!\r使用分库分表中间件  Mycat  Mycat发展到现在，适用的场景已经很丰富，而且不断有新用户给出新的创新性的方案，以下是几个典型的应用场景：\r单纯的读写分离，此时配置最为简单，支持读写分离，主从切换\r分表分库，对于超过1000万的表进行分片，最大支持1000亿的单表分片\r多租户应用，每个应用一个库，但应用程序 …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"f8d39a067fbb3318c9d10c60318f5407","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/mysql_distinguish/","publishdate":"2020-01-17T15:26:15Z","title":"MySQL分库分表原理"},{"content":"mysql安装  这里我们不再采用exe的安装的方式,我们使用压缩包的方式安装\n   地址 https://downloads.mysql.com/archives/community/\n  将页面拉到最下面选择选择操作系统后，选择要下载的版本点击 Downloads\n  我选择安装的版本为8.0.13。如果不想要最新的版本也可以进Archives页面选择其他版本\n  选择压缩包的版本哦\n  一:配置环境变量   因为下载的mysql数据库包的格式是zip的，下载完成后直接解压就可以用，但解压后需要进行配置。\n  首先进行环境变量的配置：右击计算机-\u0026amp;gt;属性-\u0026amp;gt;高级系统设置-\u0026amp;gt;环境变量，选择双击Path，在最后面添加你的mysql bin文件夹的路径\n  我的目录是：D:\\databases\\mysql-8.0.13-winx64\n   必须设置这个才行,因为后面我们要在控制台运行命令,假如你不设置这个环境变量那么在控制台根本识别不了,exe安装会自动在环境中设置,而压缩包没有设置  二:在 D:\\databases\\mysql-8.0.13-winx64 目录下新建一个my.ini的文件 [mysqld]\r# skip-grant-tables 暂时注释了 容易引起 mysql服务启动后立马关闭 这个错误\r# 设置3306端口\rport=3306\r# 自定义设置mysql的安装目录，即解压mysql压缩包的目录\r# 切记此处一定要用双斜杠\\\\，单斜杠这里会出错。\rbasedir=D:\\\\databases\\\\mysql-8.0.13-winx64\r# 自定义设置mysql数据库的数据存放目录\rdatadir=D:\\\\databases\\\\mysql-8.0.13-winx64\\\\data\r# 允许最大连接数\rmax_connections=200\r# 允许连接失败的次数，这是为了防止有人从该主机试图攻击数据库系统\rmax_connect_errors=10\r# 服务端使用的字符集默认为UTF8\rcharacter-set-server=utf8mb4\r# 创建新表时将使用的默认存储引擎\rdefault-storage-engine=INNODB\r# 默认使用“mysql_native_password”插件认证\rdefault_authentication_plugin=mysql_native_password\r[mysql]\r# 设置mysql客户端默认字符集\rdefault-character-set=utf8mb4\r[client]\r# 设置mysql客户端连接服务端时默认使用的端口和默认字符集\rport=3306\rdefault-character-set=utf8mb4\r三:windows下运行控制台程序  进入 C:\\Windows\\System32 中搜索   右键用管理员权限执行  四:初始化mysql  mysqld \u0026amp;ndash;initialize \u0026amp;ndash;console，等待一会出现几行代码，root@localhost：后面的是随机生成的数据库初始密码，将初始密码记下来后面会用到。 没记住初始密码的话，删掉初始化的 data目录，再执行一遍初始化命令又会重新生成  D:\\databases\\mysql-8.0.13-winx64\\bin\u0026amp;gt;mysqld --initialize --console\r2020-04-06T07:51:43.421098Z 0 [System] [MY-013169] [Server] D:\\databases\\mysql-8.0.13-winx64\\bin\\mysqld.exe (mysqld 8.0.13) initializing of server in progress as process 21400\r2020-04-06T07:52:04.903297Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: gMmik3IyFW!D\r2020-04-06T07:52:19.868074Z 0 [System] [MY-013170] [Server] D:\\databases\\mysql-8.0.13-winx64\\bin\\mysqld.exe (mysqld 8.0.13) initializing of server has completed\r五:mysql执行核心插件服务 D:\\databases\\mysql-8.0.13-winx64\\bin\u0026amp;gt;mysqld --install\rService …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"50fcde2abe3de87ed76d79833d9479f1","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/mysql_install/","publishdate":"2020-01-17T15:26:15Z","title":"mysql安装"},{"content":"windows下 Mysql安装的一些问题解决方法 1: The service already exists   在mysql安装的时候要执行 mysqld \u0026amp;ndash;install 这个命令,假如你已经安装完之后觉得不对，但是mysql服务已经生成(windows注册服务已经有mysql了),你不删除此服务为报一个错误\n  The service already exists\n  决绝方法就是 删除mysql相关的服务\n  首先查询下是否存在mysql服务\n  sc query mysql\rSERVICE_NAME: mysql\rTYPE : 10 WIN32_OWN_PROCESS\rSTATE : 4 RUNNING\r(STOPPABLE, PAUSABLE, ACCEPTS_SHUTDOWN)\rWIN32_EXIT_CODE : 0 (0x0)\rSERVICE_EXIT_CODE : 0 (0x0)\rCHECKPOINT : 0x0\rWAIT_HINT : 0x0\r# 这种情况就是mysql 没有删除干净\r 删除该mysql  sc delete mysql\r Please consider using UTF8MB4 in order to be unambiguous.  utf 的别名是 UTF8MB4\r这里在my.ini 的文件中最好是设置 default-character-set=utf8mb4  windows系统下Mysql服务启动后立即关闭问题-排查及解决方法  查看 my.ini 中 多了这个 skip-grant-tables ,这个的原意思是跳过检查,但是在不同版本有些命令是不能使用的\r然后就是目前我暂时发现我自己使用的这个版本出了这个问题,在不同版本下最好是仔细查看配置和日志才是解决之道\r回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"4531605042b7b9ec288db897d020bc9c","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/mysql_install_problem/","publishdate":"2020-01-17T15:26:15Z","title":"windows下 Mysql安装的一些问题解决方法"},{"content":"数据库设计的规范  数据库表和字段都大写 表都要加业务后缀，例如_C客户表 _B基础表 _P权限表 必须有主键，主键是表名去掉业务后缀，加_ID，大多表的主键使用UUID 字段多个单词时，全大写，用下划线隔开 类型INT/LONG/DOUBLE/TIMESTAMP/CHAR/VARCHAR2 尽量化在这几个类型中，这样数据库设计相当简单 排序号定死名称ORDER_NO 权限两个字段CREATE_BY创建人，CREATE_DEPT创建部门 记录创建时间CREATE_TIME  回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"6ee897604bf75049b16483db12b66705","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/mysql_%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","publishdate":"2020-01-17T15:26:15Z","title":"数据库设计的规范"},{"content":" 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。\n  目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。\n 数据库三范式 第一范式（1NF）  所谓第一范式（1NF）是指在关系模型中，对域添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。 说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。  第二范式（2NF）  在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖） 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复，无法区分出实体时，设计辟如ID等不重复的编号以实现区分，被添加的编号或ID选作主键。（该主键的添加是在ER设计时添加，不是建库时随意添加） 第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。  第三范式（3NF）  在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。  巴斯-科德范式（BCNF）  Boyce-Codd Normal Form（巴斯-科德范式）\n  在3NF基础上，任何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖） 巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足巴斯-科德范式（BCNF）必须满足第三范式（3NF）。通常情况下，巴斯-科德范式被认为没有新的设计规范加入，只是对第二范式与第三范式中设计规范要求更强，因而被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，使数据库冗余度更小。这也是BCNF不被称为第四范式的原因。某些书上，根据范式要求的递增性将其称之为第四范式是不规范，也是更让人不容易理解的地方。而真正的第四范式，则是在设计规范中添加了对多值及依赖的要求。 定义：关系模式R\u0026amp;lt;U,F\u0026amp;gt;∈1FNF,若X→Y且Y不是X的子集时X必含有码，则R\u0026amp;lt;U,F\u0026amp;gt;∈BCNF。也就是说，关系模式R\u0026amp;lt;U,F\u0026amp;gt;中，若每一个决定因素都包含码，则R\u0026amp;lt;U,F\u0026amp;gt;∈BCNF。   由BCNF的定义可以得到结论，一个满足BCNF的关系模式有：\n  -所有非主属性对每一个码都是完全函数依赖。 -所有主属性对每一个不包含它的码也是完全函数依赖。 -没有任何属性完全函数依赖于非码的任何一组属性。 若R∈BCNF，按定义排除了任何属性对码的传递依赖与部分依赖，所以R∈3NF。[1] 一般关系型数据库设计中，达到BCNF就可以了！  #【数据库五大约束】 …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"3cde61fe6b803e96d9dde13c8ca13c77","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/mysql_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F/","publishdate":"2020-01-17T15:26:15Z","title":"mysql_数据库设计三范式"},{"content":"回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"fe667b902c202e2c915346ea18bf136d","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/mysql%E4%BA%8B%E5%8A%A1/","publishdate":"2020-01-17T15:26:15Z","title":"mysql事务"},{"content":"日期函数   返回当前日期，只包含年月日 select curdate()\n  返回当前时间，只包含时分秒 select curtime()\n  返回当前的日期和时间，年月日时分秒全都包含 select now()\n  提取具体日期类型  year() yearweek() ,hour(),month()等等   select year(now()) as \u0026amp;lsquo;年\u0026amp;rsquo;,yearweek(now()) as \u0026amp;lsquo;年,周\u0026amp;rsquo;,hour(now()) as \u0026amp;lsquo;周\u0026amp;rsquo;,minute(now()) as \u0026amp;lsquo;小时\u0026amp;rsquo;,month(now()) \u0026amp;lsquo;月\u0026amp;rsquo;,monthname(now()) \u0026amp;lsquo;月名字\u0026amp;rsquo;,dayofmonth(now()) as \u0026amp;lsquo;当月多少日\u0026amp;rsquo;   EXTRACT() 函数用于返回日期/时间的单独部分，比如年、月、日、小时、分钟等等。   (select extract(year from now()),extract(month from now()),extract(day from now()),extract(hour from now()),extract(minute from now()))  日期格式  DATE_FORMAT(date,fmt)函数：按字符串 fmt 格式化日期 date 值 (select date_format(now(),\u0026#39;%Y-%m-%d\u0026#39;))  日期运算   date_add(date,interval number dateType) example (select date_add(now(),interval 2 year) as \u0026amp;lsquo;add 2 year date\u0026amp;rsquo;) (select date_add(now(),interval -2 hour) as \u0026amp;lsquo;add 2\u0026amp;rsquo;)也可以传入负数即回到过去某个时间\n  date_sub(date,interval number dateType) example (select date_sub(now(),interval 2 year))\n  datediff(date,date) 计算两个日期之间相差的天数 (select datediff(now(),date_add(now(),interval 2 month)) as \u0026amp;lsquo;计算两个日期之间相差天数\u0026amp;rsquo;)\n  流程函数  if 函数  create table salary (userid int,salary decimal(9,2));\rinsert into salary values(1,1000),(2,2000), (3,3000),(4,4000),(5,5000), (1,null);\r (select if(s.salary\u0026amp;gt;2000,\u0026amp;lsquo;high\u0026amp;rsquo;,\u0026amp;lsquo;low\u0026amp;rsquo;),s.salary from salary s)   IFNULL(value1,value2)函数：这个函数一般用来替换 NULL 值的，我们知道 NULL 值是不能参与数值运算的   (select ifnull(s.salary,0),s.salary from salary s)当检测到值的时候用0代替  数值函数  ABS(x)函数：返回 x 的绝对值   select abs(-56),abs(round(rand()*10))   cell(x)函数 返回大于 x 的最大整数值 相当于向上取   SELECT ceil(0.6),ceiling(0.3),ceil(round(rand()))   floor()返回小于 x 的最大整数值 相当于向下取   SELECT floor(0.6),floor(0.3),floor(round(rand()))   mod(x,y) 返回 x/y 的模   SELECT mod(5,3)   rand() 返回 0 到 1 内的随机值 ROUND(x,y) 返回参数 x 的四舍五入的有 y 位小数的值   SELECT round(2.5,3)   sum()函数   select sum(f.f_price) as \u0026amp;lsquo;总价格\u0026amp;rsquo; from fruits f  字符串函数  CANCAT(S1,S2,…Sn) 连接 S1,S2,…Sn 为一个字符串   SELECT …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"e9b36d16e4b2ba91145d3382c2c0887d","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/mysql%E5%87%BD%E6%95%B0/","publishdate":"2020-01-17T15:26:15Z","title":"mysql函数"},{"content":"MySQL 存储引擎概述  MySQL 5.0 支持的存储引擎包括 MyISAM、 InnoDB、 BDB、 MEMORY、 MERGE、 EXAMPLE、 NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED 等，其中 InnoDB 和 BDB 提供事务安 全表，其他存储引擎都是非事务安全表。\n  查看当前引擎 show ENGINES  MyISAM存储引擎  不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表\n  支持3种不同的存储格式，分别是：静态表；动态表；压缩表   静态表：表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。 动态表：记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能 压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支\n  动态表：记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能\n  压缩表：因为每个记录是被单独压缩的，所以只有非常小的访问开支\n InnoDB存储引擎  nnoDB 存储表和索引有两种方式\n  使用共享表空间存储，这种方式创建的表的表结构保存在.frm 文件中，数据和索引 保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是 多个文件。 使用多表空间存储，这种方式创建的表的表结构仍然保存在.frm 文件中，但是每个 表的数据和索引单独保存在.ibd 中。如果是个分区表，则每个分区对应单独的.ibd 文件，文件名是“表名+分区名” ，可以在创建分区的时候指定每个分区的数据文件 的位置，以此来将表的 IO 均匀分布在多个磁盘 多表空间的数据文件没有大小限制，不需要设置初始大小，也不需要设置文件的最大限 制、扩展大小等参数。 对于使用多表空间特性的表，可以比较方便地进行单表备份和恢复操作，但是直接复 制.ibd 文件是不行的，因为没有共享表空间的数据字典信息，直接复制的.ibd 文件和.frm 文 件恢复时是不能被正确识别的，但可以通过以下命令：  ALTER TABLE tbl_name DISCARD TABLESPACE;\rALTER TABLE tbl_name IMPORT TABLESPACE;\rMEMORY存储引擎  Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。 memory类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。 MEMORY存储引擎的表可以选择使用BTREE索引或者HASH索引，两种不同类型的索引有其不同的使用范围\n  Hash索引优点： Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 Hash索引缺点： 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；\n  Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。 对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。\n MERGE存储引擎  Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。\n 回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"1d063f2542115b7f3d23f60d7dca45f1","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","publishdate":"2020-01-17T15:26:15Z","title":"mysql存储引擎"},{"content":"mysql学习(下面所有都是针对mysql而言) sql排序语句  升序   (select f.* from fruits f WHERE s_id IN (101,102) order by f_name)==(select f.* from fruits f WHERE s_id IN (101,102) order by f_name asc)   对于sql的升序而言,当使用了order by之后如果不添加desc那么默认是升序 order by f_name 和 order by f_name ASC 效果一致 降序   (select f.* from fruits f WHERE s_id not IN (101,102) order by f_name DESC )   order by之后加上DESC结果集就是降序   上面结合了 关键字in可以看到 in (101,102)和not in (101,102)\n 带between and 的范围查询  (select f.* from fruits f WHERE f.f_price between 2.00 and 14.00)查询价格在2.00元到14.00元之间的数据,这样也可以(select f.* from fruits f WHERE f.f_price\u0026amp;gt;2.00 and f.f_price\u0026amp;lt;12.67)  带like的字符串匹配查询  (select f.* from fruits f WHERE f.f_name like \u0026amp;lsquo;%g%\u0026#39;)查询f_name包含g的记录 (select f.* from fruits f WHERE f.f_name like \u0026amp;lsquo;b%\u0026#39;)查询以b开头的记录,同理结尾的字符也是一样原理  查询null值  (select c.* from customers c WHERE c.c_email is null)查询email为null的数据  带and 的多条件查询  (select f.* from fruits f WHERE f.s_id=\u0026amp;lsquo;101\u0026amp;rsquo; and f.f_price\u0026amp;gt;=5)  带or 的多条件查询  (select f.* from fruits f WHERE f.s_id=\u0026amp;lsquo;101\u0026amp;rsquo; or f.s_id=\u0026amp;lsquo;102\u0026amp;rsquo;)  查询结果不重复  (select distinct f.* from fruits f)添加了过滤字段distinct  分组查询  (select f.s_id,count(*) as total from fruits f group by f.s_id) (select f.s_id,count(*) as total,group_concat(f.f_name) as g_name from fruits f group by f.s_id) 这里使用了一个函数group_concat (select f.s_id,count(*) as total,group_concat(f.f_name) as g_name,sum(f.f_price) as price from fruits f group by f.s_id)  HAVING  [在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用]   (select f.s_id,count(*) as total,group_concat(f.f_name) as g_name,sum(f.f_price) as price from fruits f group by f.s_id having sum(f.f_price)\u0026amp;gt;20)  分页查询  (select f.* from fruits f LIMIT 10,5) ||(3-1)*5,5  连接查询(多表)  (select c.,o. from customers c,orders o where c.c_id=o.c_id)普通查询 (select c.,o. from customers c inner join orders o on o.c_id=c.c_id)内连接查询,这里需要注意的是内连接查询的是公共部分,必须是两者都有相同的记录 外连接包括左外连接和右外连接 (select c.,o. from customers c right join orders o on o.c_id=c.c_id)右连接是orders table和customers table的公共部分+orders …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"671a67abb1c1c6cbcf77b07b455779fb","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/mysql%E6%9F%A5%E8%AF%A2/","publishdate":"2020-01-17T15:26:15Z","title":"mysql查询"},{"content":" mysql.version=5.7 (必须注意版本)\n 创建用户  ( CREATE USER \u0026amp;lsquo;bob\u0026amp;rsquo;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026amp;lsquo;07fa533360d9\u0026amp;rsquo;; ) 创建bob用户 密码:07fa533360d9 ( CREATE USER \u0026amp;ldquo;test\u0026amp;rdquo;@\u0026amp;ldquo;localhost\u0026amp;rdquo; IDENTIFIED BY \u0026amp;lsquo;123456\u0026amp;rsquo; )创建test用户　密码123456 ( CREATE USER \u0026amp;ldquo;test\u0026amp;rdquo;@\u0026amp;ldquo;192.168.87.26\u0026amp;rdquo; IDENTIFIED BY \u0026amp;lsquo;123456\u0026amp;rsquo; )创建test用户　密码123456   参数说明:\u0026#39;%\u0026amp;lsquo;表示所有情况都能访问;\u0026amp;lsquo;localhost\u0026amp;rsquo;表示本机才能访问;\u0026amp;lsquo;192.168.87.26\u0026amp;rsquo; 某个具体 ip 才能访问\n 授权命令 (GRANT privileges ON databasename.tablename TO \u0026amp;lsquo;username\u0026amp;rsquo;@\u0026amp;lsquo;host\u0026amp;rsquo; ) GRANT SELECT,INSERT privileges on spring.* to \u0026amp;lsquo;alice\u0026amp;rsquo;@\u0026amp;lsquo;localhost\u0026amp;rsquo; identified by \u0026amp;lsquo;123456\u0026amp;rsquo;\n 参数说明:databasename表示数据库名字;tablename数据库表的名字;username用户名;host表示链接地址如本机localhost,远程任意%,具体ip192.168.87.26\n 授权test用户拥有testDB数据库的所有权限 create database testDB;\rgrant all privileges on testDB.* to \u0026amp;quot;test\u0026amp;quot;@\u0026amp;quot;localhost\u0026amp;quot; identified by \u0026#39;123456\u0026#39;\r指定部分权限给用户 grant select,update on testDB.* to \u0026amp;quot;blake\u0026amp;quot;@\u0026amp;quot;localhost\u0026amp;quot; identified by \u0026#39;123456\u0026#39;;\rGRANT SELECT, INSERT ON spring.user TO \u0026#39;alice\u0026#39;@\u0026#39;localhost\u0026#39;; 撤销权限 REVOKE privilege ON databasename.tablename FROM \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39;; #撤销\rREVOKE grant option ON databasename.tablename FROM \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39;; #收回\r修改用户密码 update mysql.user set authentication_string=password(\u0026#39;123456\u0026#39;) where User=\u0026#39;blake\u0026#39; and Host=\u0026#39;localhost\u0026#39;;\r 关于修改密码也可以这样 1:select password(\u0026amp;lsquo;1234\u0026amp;rsquo;); 得到string 如1234==\u0026amp;gt;*A4B6157319038724E3560894F7F932C8886EBFCF\n update mysql.user set authentication_string=\u0026amp;quot;*A4B6157319038724E3560894F7F932C8886EBFCF\u0026amp;quot; where User=\u0026#39;bob\u0026#39; and Host=\u0026#39;localhost\u0026#39;;\r 关于远程访问修改\n UPDATE user SET Host=\u0026#39;%\u0026#39; WHERE User=\u0026#39;alice\u0026#39; AND Host=\u0026#39;localhost\u0026#39; LIMIT 1;\rUPDATE user SET Host=\u0026#39;192.168.87.26\u0026#39; WHERE User=\u0026#39;alice\u0026#39; AND Host=\u0026#39;%\u0026#39; LIMIT 1;\r删除用户bob delete from user WHERE User=\u0026#39;bob\u0026#39;\r刷新系统权限表 flush privileges; 查看权限 show grants for \u0026#39;blake\u0026#39;@\u0026#39;localhost\u0026#39;;\r回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"acbcaad34c42e8a500b819a9265b3750","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/mysql%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90/","publishdate":"2020-01-17T15:26:15Z","title":"mysql用户与权限"},{"content":"索引  所有 MySQL 列类型都可以被索引，对相关列使用索引是提高 SELECT 操作性能的最佳途 径.根据存储引擎可以定义每个表的最大索引数和最大索引长度， 每种存储引擎 （如 MyISAM、 InnoDB、BDB、MEMORY 等）对每个表至少支持 16 个索引，总索引长度至少为 256 字节。 大多数存储引擎有更高的限制。\n  MyISAM 和 InnoDB 存储引擎的表默认创建的都是 BTREE 索引。MySQL 目前还不支持函 数索引，但是支持前缀索引，即对索引字段的前 N 个字符创建索引。前缀索引的长度跟存 储引擎相关，对于 MyISAM 存储引擎的表，索引的前缀长度可以达到 1000 字节长，而对于 InnoDB 存储引擎的表，索引的前缀长度最长是 767 字节。请注意前缀的限制应以字节为单 位进行测量，而 CREATE TABLE 语句中的前缀长度解释为字符数。\n  MySQL 中还支持全文本（FULLTEXT）索引，该索引可以用于全文搜索。但是当前最新版 本中（5.0）只有 MyISAM 存储引擎支持 FULLTEXT 索引，并且只限于 CHAR、 VARCHAR 和 TEXT 列。索引总是对整个列进行的，不支持局部（前缀）索引\n  默认情况下，MEMORY 存储引擎使用 HASH 索引，但也支持 BTREE 索引\n 回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"40e4e24ec0eb7262cde66b22a429d1fd","permalink":"https://huachengzhou.github.io/cycle/databases/mysql/mysql%E7%B4%A2%E5%BC%95/","publishdate":"2020-01-17T15:26:15Z","title":"mysql索引"},{"content":"网易云课堂MySQL微专业学习笔记  但愿可以不弃坑。\n 目录  数据库基础  1.1-认识MySQL 1.2-轻松安装MySQL 1.3-MySQL数据库连接 1.4-SQL语言入门 1.5-认识DBA   MySQL数据库对象与应用  2.1-MySQL数据类型 2.2-MySQL数据对象 2.3-MySQL权限管理 2.4-SQL语言进阶 2.5-内置函数 2.6-触发器与存储过程 2.7-MySQL字符集 2.8程序连接MySQL 2.9-DAO框架的使用   MySQL事务与存储引擎  3.1-数据库事务 3.2-存储引擎概述 3.3-InnoDB存储引擎 3.4-InnoDB事务锁   MySQL应用优化  4.1-MySQL索引优化与设计 4.2-MySQL数据库设计 4.3-MySQL容量评估 4.4-MySQL性能测试   MySQL运维实践  5.1-MySQL日志系统 5.2-MySQL数据备份 5.3-MySQL数据恢复 5.4-MySQL线上部署 5.5-MySQL主从复制 5.6-MySQL日常运维 5.7-MySQL参数调优    回到上一级 ","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"a0664ebdd8c2a31d98075b8a997d3c60","permalink":"https://huachengzhou.github.io/cycle/databases/mysql_163%E8%AF%BE%E5%A0%82/","publishdate":"2021-01-17T15:26:15Z","title":"网易云课堂MySQL微专业学习笔记"},{"content":"MySQL数据库基础 1.1-认识MySQL 什么是数据库  计算机处理和存储的一切信息都是数据。 计算机系统中一种用于存取数据的程序。 一种：  计算机系统中有很多种能够存取数据的程序 它们各有特征和长处，有自己的适用范围。   存取：  能够保存数据避免丢失。 能够按照需求找到符合条件的数据。    为什么要使用数据库 数据库帮助我们解决一下数据存取难题：\n 较大数据量 网络控制 并发访问 高性能要求 事务控制 持久化和数据安全 查询数据需求逻辑复杂  数据库分类   关系型数据库\n MySQL Oracle SQL Server PostgreSQL    非关系型数据库\n hadoop：存放大数据 mongoDB： 文档型数据库 redis：键值型数据库 Cassandra：分布式数据库    最显著的区别：是否使用结构化查询语句（SQL）\n为什么学习MySQL MySQL：The world\u0026amp;rsquo;s most popular open source database\n  最流行\n  开源\n  并不是最先进\n  前三强中唯一的开源数据库。\n  在互联网企业中占据绝对主流地位。\n  基于GPL协议开放源代码\n  社区版完全免费\n  代码允许自由的进行修改\n  易于学习：\n MySQL具备关系型数据库核心功能但是特性并不繁多。 架构设计上趋于精简。 非常适合新手学习关系型数据库，入门后可向其他数据库发展。    谁需要学习MySQL  应用开发者 DBA  学习目标 - 应用开发者 有助于利用MySQL开发出性能优异的应用程序\n学习目标 - DBA 为企业提供可靠的数据库技术保障\n1.2-轻松安装MySQL 轻松部署MySQL  Windows下安装MySQL  图形化工具安装， MySQL Installer   Linux（Ubuntu）下安装MySQL  包管理安装，apt-get    Windows安装时在安装中间starting server时报错解决办法是手动进入服务管理把MySQL服务的登录方式改为用本地账户且允许与桌面交互\n在Ubuntu下可以用apt-cache search mysql-server查看可用的软件包\n使用sudo apt-get install mysql-server-5.6安装MySQL5.6\n启动与停止MySQL服务：\n# 启动 sudo /etc/init.d/mysql start # 或者 sudo service mysql start # 停止 sudo /etc/init.d/mysql stop # 或者 sudo service mysql stop # 重启 sudo service mysql restart # 查看状态 sudo /etc/init.d/mysql status 1.3-MySQL数据库连接 工作中常用到的三种连接方式  Java App + JDBC client（其他语言也有，比如Python的MySQLdb） MySQL client \u0026amp;ldquo;MySQL\u0026amp;rdquo; utility  使用应用程序连接MySQL  应用程序使用驱动（connector/driver）客户端连接MySQL MySQL驱动程序涵盖各种主流语言  使用命令行连接MySQL  安装MySQL客户端软件包 设置环境变量（Linux）  如何安装MySQL-client  从软件源安装sudo apt-get install mysql-client  验证MySQL的安装 mysql -V\n命令行连接MySQL的两种方式  Socket连接（本地连接） TCP/IP连接（远程连接）  使用Socket连接 # 需要指定socket文件和用户名、密码 mysql -S/tmp/mysql.sock -uroot -p 远程连接 # 需要指定IP和端口 mysql -h127.0.0.1 -P3306 -uroot -p 本地连接VS远程连接  本地连接只能在MySQL服务器上创建，常用作为MySQL状态检查，或程序和MySQL部署在一台机器上。 远程连接在MySQL服务器内外都能生效，适合应用服务器和MySQL部署在不同机器上的场景。  在Windows下用命令行连接MySQL mysql -hlocalhost -P3306 -uroot -p 连接进入之后可以做什么 # 数据库状态 status; # 展示当前连接 show processlist; 使用命令行连接MySQL的注意事项  socket一般存储路径为：/tmp/mysql.sock  # 如果找不到文件可以通过tcp连接进来然后通过如下命令查找 show global …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"4785de9a1ac9e0cb94fbbe235141808a","permalink":"https://huachengzhou.github.io/cycle/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter1/","publishdate":"2020-01-17T15:26:15Z","title":"MySQL数据库基础"},{"content":"MySQL数据库对象与应用 2.1-MySQL数据类型 Number不止一种  整形 浮点型  整形  INT SMALLINT MEDIUMINT BIGINT     type Storage Minumun Value Maximum Value      (Bytes) (Signed/Unsigned) (Signed/Unsigned)   TINYINT 1 -128 127     0 255   SMALLINT 2 -32768 32767     0 65535   MEDIUMINT 3 -8388608 8388607     0 16777215   INT 4 -2147483648 2147483647     0 4294967295   BIGINT 8 -9223372036854775808 9223372036854775807     0 18446744073709551615    老生常谈的问题 int(11) VS int(21) 存储空间，还是存储范围有区别？\n答案是：两者完全一样，只是在显示的时候补全0的位数不一样。\n可以通过下面的例子来验证：\ncreate table t(a int(11) zerofill, b int(21) zerofill); insert into t values (1, 1); select * from t; MySQL默认是不带0补全的。\n只是在一些特殊情况下两者显示有区别，其本质完全一样。\n浮点型  FLOAT(M, D) DOUBLE(M, D)     属性 存储空间 精度 精确性     Float 4 bytes 单精度 非精确   Double 8 bytes 双精度 比Float精度高    精度丢失问题  精度丢失  一个例子：\ncreate table t(a int(11), b float(7, 4)); insert into t values (2, 123.12345); select * from t; 定点数-更精确的数字类型  DECIMAL  高精度的数据类型，常用来存储交易相关的数据 DECIMAL(M,N).M代表总精度，N代表小数点右侧的位数（标度） 1 \u0026amp;lt; M \u0026amp;lt; 254, 0 \u0026amp;lt; N \u0026amp;lt; 60; 存储空间变长    性别、省份信息 一般使用tinyint、char(1)、enum类型。\n经验之谈  存储性别、省份、类型等分类信息时选择TINYINT或者ENUM BIGINT存储空间更大，INT和BIGINT之间通常选择BIGINT 交易等高精度数据选择使用DECIMAL  存储用户名的属性  CHAR VARCHAR TEXT  CAHR与VARCHAR  CHAR和VARCHAR存储的单位都是字符 CHAR存储定长，容易造成空间的浪费 VARCHAR存储变长，节省存储空间  字符与字节的区别    编码\\输入字符串 网易 netease     gbk(双字节) varchar(2)/4 bytes varchar(7)/7 bytes   utf8(三字节) varchar(2)/6 bytes varchar(7)/7 bytes   utf8mb4(四字节) varchar(2) ? varchar(7)/7 bytes    对于utf8mb4号称占用四字节但是并不绝对。如果在utf8可以覆盖到的范围则仍然占用3字节。\nutf8mb4最有优势的应用场景是用于存储emoji表情\nemoji表情  MySQL版本 \u0026amp;gt; 5.5.3 JDBC驱动版本 \u0026amp;gt; 5.1.13 库和表的编码设为utf8mb4  TEXT与CHAR和VARCHAR的区别  CHAR和VARCHAR存储单位为字符 TEXT存储单位为字节，总大小为65535字节，约为64KB CHAR数据类型最大为255字符 VARCHAR数据类型为变长存储，可以超过255个字符 TEXT在MySQL内部大多存储格式为溢出页，效率不如CHAR  一个例子：\ncreate table t (a char(256)); create table t (a varchar(256)); 存储头像  BLOB BINARY  性能太差，不推荐\n经验之谈  CHAR与VARCHAR定义的长度是字符长度不是字节长度 存储字符串推荐使用VARCHAR(N),N尽量小 虽然数据库可以存储二进制数据，但是性能低下，不要使用数据库存储文件音频等二进制数据  存储生日信息  DATE TIME DATETIME TIMESTAMP BIGINT  时间类型的区别在哪里   存储空间上的区别\n DATE三字节， …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"0a5b181b03b73fd408490cd941df9ea6","permalink":"https://huachengzhou.github.io/cycle/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter2/","publishdate":"2020-01-17T15:26:15Z","title":"MySQL数据库对象与应用"},{"content":"MySQL事务与存储引擎 3.1-数据库事务 什么是事务  一系列有序的数据库操作：  要么全部成功 要么全部回退到操作前的状态 中间状态对其他连接不可见   事务的基本操作：    基本操作 说明     start transaction 开始事务   commit 提交(全部完成)   rollback 回滚(回到初始状态)      -- 开启一个事务 start transaction; -- 或者使用(非标准sql) begin; insert into t values (1, 1, 1); -- 事务结束，插入成功 commit; begin; insert into t values (2, 1, 1); insert into t values (3, 1, 1); insert into t values (4, 1, 1); -- 事务结束，没有插入数据 rollback; begin; insert into t values (1, 1, 1); savepoint a1; insert into t values (2, 1, 1); -- 回滚到指定的保存点 rollback to a1; commit; 自动提交  autocommit可以在session级别设置 每个DML操作都自动提交 DDL永远都是自动提交，无法通过rollback回滚  事务的四个基本属性(ACID)  原子性(Atomicity) 一致性(Consistency) 隔离性(Isolation) 持久性(Durability)  事务的原子性  包含在事务中的操作要么全部被执行，要么都不执行 中途数据库或应用发生异常，未提交的事务都应该被回滚  事务的一致性  数据的正确性，合理性，完整性 数据一致性应该符合应用需要规则：  余额不能是负数 交易对象必须先有账号 用户账号不能重复   事务的结果需要满足数据的一致性约束  事物的持久性  提交完成的事务对数据库的影响必须是永久性的  数据库异常不会丢失事务更新 通常认为成功写入磁盘的数据即为持久化成功    事务的持久化的实现  数据文件持久化  随机同步刷新(慢)   事务日志持久化与实例恢复  顺序同步刷新(快) -\u0026amp;gt; 事务日志 随机异步刷新 -\u0026amp;gt; 磁盘 事务日志 -\u0026amp;gt; 磁盘(实例恢复)    事务的隔离性  数据库事务在提交完成前，中间的任何数据变化对其他的事务都是不可见的。  数据库隔离现象    隔离现象 描述     脏读(Dirty Read) 事务B读到事务A尚未提交的数据变更   不可重复读(NonRepeatable Read) 事务B读取前后两次读取一条记录之间该记录被事务A修改并提交，于是事务B读到了不一样的结果   幻读(Phantom Read) 事务B按条件匹配到了若干行记录并修改。但是由于修改过程中事务A新插入了符合条件记录，导致B更新完成后发现仍有符合条件却未被更新的记录。    数据库隔离等级    隔离等级 脏读 不可重复读 幻读     未提交读 可能 可能 可能   已提交读 不可能 可能 可能   可重复读 不可能 不可能 可能   可串行化读 不可能 不可能 不可能    MySQL的事务隔离级别  InnoDB默认标记为可重复读 InnoDB并不是标准定义上的课重复读 InnoDB默认在可重复读的基础上避免幻读  MySQL事务隔离级别设置  可在global/session/下个事务，级别分别进行设置 建议使用Read committed(同Oracle) 或者建议使用默认的Repeatable read  set tx_isolation = \u0026amp;#39;\u0026amp;#39; -- 设置隔离级别 事务与并发写  某个正在更新的记录再提交或回滚前不能被其他事务同时更新  事务回滚的实现  回滚段(rollback segment)与数据前像  3.2-存储引擎概述 MySQL程序层次架构 MySQL存储引擎  有多种可选方案，可插拔，可修改存储引擎 基于表选择使用何种存储引擎  主要存储引擎    存储引擎 常用度 支持事务     InnoDB 主要，推荐 是   MyISAM 古老，偶尔有用，系统表 否   MEMORY 偶尔临时表有用，纯内存 否   BLACKHOLE 不用来存放数据，个别特殊用处 否   TokuDB 新颖，个别特殊场景有奇效 是   Cluster 新颖，分布式，内存，线上不要用 是    InnoDB存储引擎  索引组织表 支持事务 支持行级锁 数据块缓存 日志持久化 稳定可靠，性能好，线上尽量使用InnoDB  MyISAM存储引擎  堆表 不支持事务 只维护索引缓存池，表数据缓存交 …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"f4b0f50af8733c395529259d5253700a","permalink":"https://huachengzhou.github.io/cycle/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter3/","publishdate":"2020-01-17T15:26:15Z","title":"MySQL事务与存储引擎"},{"content":"MySQL应用优化 4.1-MySQL索引优化与设计 什么是索引  索引的意义 —— 快速定位要查找的数据  数据库索引查找  全表扫描 VS 索引查找  如何根据首字母找到所在行  二分查找 B+tree  InnoDB表聚簇索引 索引中只放着排序字段和ID\n创建索引  单列索引  create index idx_test1 on tb_student (name);  联合索引  create index idx_test2 on tb_student (name, age);  索引中先根据name排序，name相同的情况下，根据age排序  索引维护  索引维护由数据库自动完成 插入/修改/删除每一个索引行都会变成一个内部封装的事务 索引越多，事务越长，代价越高 索引越多对表的插入和索引字段修改就越慢 控制表上索引的数量，切忌胡乱添加无用索引  如何使用索引  依据WHERE查询条件建立索引  select a, b from tab_a where c=? ; idx_c (c) select a, b from tab_a where c=? and d=?; idx_cd (c, d)  排序order by, group by, distinct字段添加索引  select * from tb_a order by a; select a, count(*) from tb_a group by a; idx_a (a) select * from tb_a order by a, b; idx_a_b (a, b) select * from tb_a order where c=? by a; idx_c_a (c, a) 索引与字段选择性   某个字段其值的重复程度\n  选择性很差的字段通常不适合创建单列索引\n 男女比例相仿的列表中性别不适合创建单列索引 如果男女比例极不平衡，要查询的又是少数方(理工院校查女生)可以考虑使用索引    联合索引中选择性好的字段应该排在前面\n  select * from tab_a where gender=? and name=?; idx_a1 (name, gender) 联合索引与前缀查询  联合索引能为前缀单列，复列查询提供帮助  idx_smp (a, b, c) where a=? ; where a=? and b=? ; where a=? and c=? ;(部分ok)  合理创建联合索引，避免冗余 (a) , (a, b) , (a, b, c) X (a, b, c) ok  长字段上的索引  在非常长的字段上建立索引影响性能 InnoDB索引单字段(utf8)只能取前767 bytes 对长字段处理的方法  Email类，建立前缀索引  Mail_addr varchar(2048) idx_mailadd (Mail_addr(30)) ok  住址类，拆分字段  Home_address varchar(2048) idx_mailadd (Mail_addr(30)) ? -- 很可能前半段都是相同的省市区街道名称 Province varchar(1024), City varchar(1024), District varchar(1024), Local_address varchar(1024) ... -- 建立联合索引或单列索引   索引覆盖扫  最核心SQL考虑索引覆盖 select Name from tb_user where UserID=? Key idx_uid_name(UserID, Name)  不需要回表获取name字段，IO最小，效率最高  无法使用索引的情况  索引列进行数学运算或函数运算 where id+1=10; X where id = (10-1); ok year(col) \u0026amp;lt; 2007; X col \u0026amp;lt; \u0026amp;#39;2007-01-01\u0026amp;#39;; ok  未含符合索引的前缀字段 Idx_abc (a, b, c): where b=? and c=?; X (b, c) ok  前缀通配,\u0026#39;_\u0026amp;lsquo;和\u0026amp;rsquo;%\u0026amp;lsquo;通配符 Like \u0026amp;#39;%xxx%\u0026amp;#39;; X Like \u0026amp;#39;xxx%\u0026amp;#39;; ok  where 条件使用NOT, \u0026amp;lt;\u0026amp;gt;, != 字段类型匹配  并不绝对，但是无法预测地会造成问题，不要使用  a int(11), idx_a (a) where a = \u0026amp;#39;123\u0026amp;#39;; X where a = 123 ; ok   利用索引排序 idx_a_b (a, b)\n 能够使用索引帮助排序的查询： …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"6b55bf572b2a4c92a8e6f235c9a7b908","permalink":"https://huachengzhou.github.io/cycle/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter4/","publishdate":"2020-01-17T15:26:15Z","title":"MySQL应用优化"},{"content":"MySQL运维实践 5.1-MySQL日志系统 什么是日志  日志(log)是一种顺序记录事件流水的文件 记录计算机程序运行过程中发生了什么 多种多样的用途  帮助分析程序问题 分析服务请求的特征、流量等 判断工作是否成功执行 等等……    MySQL日志的分类  服务器日志  记录进程启动运行过程中的特殊事件，帮助分析MySQL服务遇到的问题 根据需求抓取特定的SQL语句，追踪性能可能存在的问题的业务SQL   事务日志  记录应用程序对数据的所有更改 可用于数据恢复 可用于实例间数据同步       分类 日志名称     服务器日志 服务错误日志   服务器日志 慢查询日志   服务器日志 综合查询日志   事务日志 存储引擎事务日志   事务日志 二进制日志    服务错误日志  记录实例启动运行过程中重要消息 配置参数  log_error = /data/mysql_data/node-1/mysql.log   内容并非全是错误消息 如果mysqld进程无法正常启动首先查看错误日志  慢查询日志  记录执行时间超过一定阈值的SQL语句 配置参数  slow_query_log = 1 slow_query_log_file = /data/mysql_data/node-1/mysql-slow.log long_query_time = 5  用于分析系统中可能存在性能问题的SQL  综合查询日志  如果开启将会记录系统中所有SQL语句 配置参数  general_log = 1 general_log_file = /data/mysql_data/node-1/mysql-slow.log  偶尔用于帮助分析系统问题，对性能有影响  查询日志的输出与文件切换  日志输出参数  log_output={file|table|none}\n 如果日志文件过大，可以定期截断并切换新文件  flush log;\n存储引擎事务日志  部分存储引擎拥有重做日志(redo log) 如InnoDB, TokuDB等WAL(Write Ahead Log)机制存储引擎 日志随着事务commit优先持久化，确保异常恢复不丢数据 日志顺序写性能较好  InnoDB事务日志重用机制  InnoDB事务日志采用两组文件交替重用  二进制日志binlog  binlog (binary log) 记录数据引起数据变化的SQL语句或数据逻辑变化的内容 MySQL服务层记录，无关存储引擎 binlog的主要作用：  基于备份恢复数据 数据库主从同步 挖掘分析SQL语句    开启binlog  主要参数  log_bin = c:/tmp/mylog/mysql-bin\rsql_log_bin = 1\rsync_binlog = 1\r 查看binlog  show binary logs;\nbinlog管理  主要参数  max_binlog_size = 100MB\rexpire_logs_days = 7\r  binlog始终生成新文件，不会重用\n  手工清理binlog\n  purge binary logs to \u0026#39;mysql-bin.000009\u0026#39;;\rpurge binary logs before \u0026#39;2016-4-2 21:00:40\u0026#39;\r查看binlog内容  日志  show binlog events in \u0026#39;mysql-bin.000011\u0026#39;;\rshow binlog events in \u0026#39;mysql-bin.000011\u0026#39; from 60 limit 3;\r mysqlbinlog工具  mysqlbinlog c:/tmp/mylog/mysql-bin.000001\r--start-datetime | --stop-datetime\r--start-position | --stop-position\rbinlog格式  主要参数  binlog_format = {ROW|STATEMENT|MIXED}\n 查看row模式的binlog内容  mysqlbinlog --base64-output=decode-rows -v c:/tmp/mylpg/mysql-bin.000001\n5.2-MySQL数据备份 基本指数 - 备份用途  数据备灾  应对硬件故障数据丢失 应对人为或程序bug导致数据删除   制作镜像库以供服务  需要将数据迁移、统计分析等用处 需要为线上数据建立一个镜像    基本知识 - 备份内容  数据  数据文件或文本格式数据   操作日志(binlog)  数据库变更日志    基本知识 - 冷备份与热备份  冷备份  关闭数据库服务，完整拷贝数据文件   热备份  在不影响数据库 …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"6d54e1aef6dc720c1105d25c62859bc5","permalink":"https://huachengzhou.github.io/cycle/databases/mysql_163%E8%AF%BE%E5%A0%82/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82mysql_chapter5/","publishdate":"2020-01-17T15:26:15Z","title":"MySQL运维实践"},{"content":"postgresql学习笔记 postgresql用户与权限 回到上一级 ","date":1610897175,"description":"","lastmod":"2021-01-17T15:26:15Z","objectID":"240094bd16d20b9dcaa9bee850276a74","permalink":"https://huachengzhou.github.io/cycle/databases/postgresql/","publishdate":"2021-01-17T15:26:15Z","title":"postgresql学习笔记"},{"content":"权限  系统权限 role和user都是用户,只不过role属性不能登录当然也可以指定 超级权限 不做权限检查(实际中是很危险的)\n Pg权限分为两部分，一部分是“系统权限”或者数据库用户的属性，可以授予role或user（两者区别在于login权限）；\r一部分为数据库对象上的操作权限。对超级用户不做权限检查，其它走acl。\r对于数据库对象，开始只有所有者和超级用户可以做任何操作，其它走acl。\r在pg里，对acl模型做了简化，组和角色都是role，用户和角色的区别是角色没有login权限。\r超级权限  创建超级用户(create user alice with superuser password \u0026amp;lsquo;123456\u0026amp;rsquo;;)系统不会做权限操作校验,仅仅是不能够创建用户与删除用户  系统权限   (create role blake password \u0026amp;lsquo;123456\u0026amp;rsquo;;)(create user bob password \u0026amp;lsquo;123456\u0026amp;rsquo;;)(create database testdb;)\n  (grant all on database testdb to bob;grant all on database testdb to blake;)\n  测试如下 用户bob可以登录而blake不能登录直接抛出了FATL:role blake is not \u0026amp;lsquo;permitted to log in\u0026amp;rsquo;\n  ( drop database testdb;drop role blake;drop user bob;)\n  (create user bob password \u0026amp;lsquo;123456\u0026amp;rsquo;;)(alter user bob set default_transaction_read_only=on;grant all on database testdb to bob;grant select on all tables in schema public to bob; )\n  (revoke all on database testdb from bob;revoke select on all tables in schema public from bob;)删除前撤销(drop user bob)\n  (grant DELETE,UPDATE,SELECT,INSERT on all tables in schema public to bob;)\n  查询  查询系统中用户的权限(SELECT * FROM pg_roles;) 显示用户和用户的用户属性(\\du) 查看全部可设置的管理权限(\\h)  删除  (drop user bob) (drop role bob)要注意在删除前必须把权限先删除,还有一种笨办法就是把数据库先备份然后在删除这时就可以删除用户了  系统登录  (sudo su postgres -c psql template1)(psql -U alice -d testdb -h localhost -W)参数含义: -U指定用户 -d要连接的数据库 -h要连接的主机 -W提示输入密码。  修改系统密码  (sudo passwd -d postgres)  sudo su postgres -c psql template1\r会出现 postgres=#\r输入postgres=# \\password\r输入２次密码\r然后输入(退出)\rpostgres=# \\q\r回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"f2891be0f4230bf30433485c1e692b16","permalink":"https://huachengzhou.github.io/cycle/databases/postgresql/postgresql_create%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90/","publishdate":"2020-01-17T15:26:15Z","title":"权限"},{"categories":["java"],"content":"目录   工具文档\n  中间件\n  groovy 脚本\n  ","date":1554163200,"description":"","lastmod":"2019-04-02T00:00:00Z","objectID":"09302f25e9634605de2bed402be5bb3f","permalink":"https://huachengzhou.github.io/cycle/javadir/","publishdate":"2019-04-02T00:00:00Z","tags":["java"],"title":" Java技术栈"},{"content":"目录  jsp  回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"a26e3dd875e48e15a8ef31ab215beeac","permalink":"https://huachengzhou.github.io/cycle/javadir/basedir/","publishdate":"2021-04-15T00:00:00Z","title":"Java基础知识 "},{"content":"目录 el表达式\n字符串el表达式\nJSTL_core标签库\nsession\n监听事件原理\n回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"ef4adda3f55a6b84e8490fb8df0f1c6d","permalink":"https://huachengzhou.github.io/cycle/javadir/basedir/jsp_dir/","publishdate":"2021-04-15T00:00:00Z","title":"jsp 基础知识 "},{"content":"接口回调法 模拟输出监听事件 第一步先定义事件接口 public interface PrintListener {\rpublic void print();\r}\r第二步自定义输出类 public class Out {\rPrintListener listener=null;\rpublic Out() {\r}\rpublic Out(PrintListener listener) {\rthis.listener=listener;\r}\rpublic void printlen(String s) {\rSystem.out.println(s);\rif(listener!=null) {\rlistener.print();\r}\r}\r}\r第三步实现监听事件接口 public class PrintListenerDemo implements PrintListener {\r@Override\rpublic void print() {\rSystem.out.println(\u0026amp;quot;监听到输出事件\u0026amp;quot;);\r}\r}\r测试 public class Test {\rpublic static void main(String[] args) {\r//新建一个默认输出类\rOut b=new Out();\rb.printlen(\u0026amp;quot;这里不会被监听到输出事件\u0026amp;quot;);\t//新建一个输出类,为输出类添加一个输出监听事件\rOut b1=new Out(new PrintListenerDemo());\rb1.printlen(\u0026amp;quot;这里输出后会被监听到输出事件\u0026amp;quot;);\r}\r}\r结果 监听事件使用  在javaweb中,不论与ServletContext,HttpSession,ServletRequest相关的监听接口\n  开发者只需要直接实现这些监听接口事件,其他的源码别人己经写好了,我们不用关心它是如何实现\n 回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"325c8c39f6e1fd6dc2e72c85c70b2c3d","permalink":"https://huachengzhou.github.io/cycle/javadir/basedir/jsp_dir/java_%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/","publishdate":"2021-04-15T00:00:00Z","title":"java_监听事件原理 "},{"content":"EL基础教程 El标签语法  ${参数名}\n EL标签的功能   可以访问JSP中不同的域的对象    可以访问JavaBean中的属性    可以访问集合元素    支持简单的运算操作   访问JSP中不同的域的对象 \u0026amp;lt;%\rpageContext.setAttribute(\u0026amp;quot;name1\u0026amp;quot;, \u0026amp;quot;zhangsan\u0026amp;quot;);\rrequest.setAttribute(\u0026amp;quot;name2\u0026amp;quot;, \u0026amp;quot;lisi\u0026amp;quot;);\rsession.setAttribute(\u0026amp;quot;name3\u0026amp;quot;, \u0026amp;quot;wangwu\u0026amp;quot;);\rapplication.setAttribute(\u0026amp;quot;name4\u0026amp;quot;, \u0026amp;quot;liuliu\u0026amp;quot;);\r%\u0026amp;gt;\r\u0026amp;lt;!--范围.参数名 --\u0026amp;gt;\r${pageScope.name1 } ${requestScope.name2 } ${sessionScope.name3 }\r${applicationScope.name4 }\r\u0026amp;lt;br\u0026amp;gt;\r\u0026amp;lt;!-- 直接写参数名称 --\u0026amp;gt;\r${name1 } ${name2 } ${name3 } ${name4 }\r 访问JavaBean中的属性 \u0026amp;lt;%\rUser user=new User(\u0026amp;quot;zhangsan\u0026amp;quot;,20,\u0026amp;quot;北京\u0026amp;quot;);\rrequest.setAttribute(\u0026amp;quot;user\u0026amp;quot;, user);\r%\u0026amp;gt;\ruser name:${user.name }\u0026amp;lt;br\u0026amp;gt; user age:${user.age }\u0026amp;lt;br\u0026amp;gt; user address:${user.address }\r 访问集合元素 \u0026amp;lt;%\r//数组\rint[] array=new int[]{1,2,3};\r//列表\rList list=new ArrayList();\rlist.add(\u0026amp;quot;list1\u0026amp;quot;);\rlist.add(20);\rlist.add(true);\rpageContext.setAttribute(\u0026amp;quot;array\u0026amp;quot;, array);\rpageContext.setAttribute(\u0026amp;quot;list\u0026amp;quot;, list);\r%\u0026amp;gt;\r数组:${array[0] },${array[1] },${array[2] }\u0026amp;lt;br\u0026amp;gt; List列表:${list }\u0026amp;lt;br\u0026amp;gt;\r 简单的运算操作 算术运算符:\n2+3=${2+3 }\r2-3=${2-3 }\r2*3=${2*3 }\r2/3=${2/3 }\r 逻辑运算符:\ntrue\u0026amp;amp;\u0026amp;amp;false=${true\u0026amp;amp;\u0026amp;amp;false }\ttrue||false=${true||false }\t!true=${!true }\t 关系运算符:\n2==5 ${2==5 }\r2!=5 ${2!=5 }\r2\u0026amp;gt;5 ${2\u0026amp;gt;5 }\r2\u0026amp;lt;5 ${2\u0026amp;lt;5 }\r2\u0026amp;gt;=5 ${2\u0026amp;gt;=5 }\r2\u0026amp;lt;=5 ${2\u0026amp;lt;=5 }\r 其他运算符:\n\u0026amp;lt;%\rUser user=new User();\rUser user1=new User(\u0026amp;quot;zhangsan\u0026amp;quot;,20,\u0026amp;quot;北京\u0026amp;quot;);\rString arr=new String();\rString[] arr1=new String[]{\u0026amp;quot;one\u0026amp;quot;,\u0026amp;quot;two\u0026amp;quot;};\tpageContext.setAttribute(\u0026amp;quot;user\u0026amp;quot;, user);\rpageContext.setAttribute(\u0026amp;quot;user1\u0026amp;quot;, user1);\rpageContext.setAttribute(\u0026amp;quot;arr\u0026amp;quot;, arr);\tpageContext.setAttribute(\u0026amp;quot;arr1\u0026amp;quot;, arr1);\r%\u0026amp;gt;\ruser 是否为空:${empty user }\rarr 是否为空:${empty arr }\ruser1 是否为空:${empty user1 }\rarr1 是否为空:${empty arr1 }\r三元目运算符2\u0026amp;lt;5?yes:no:${2\u0026amp;lt;5?\u0026amp;quot;yes\u0026amp;quot;:\u0026amp;quot;no\u0026amp;quot; }\ruser1.address:${user1.address }\rarr1[1]:${arr1[1] }\r EL标签的隐 …","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"bf6bae1d41daf2464131c4feb7a4ec10","permalink":"https://huachengzhou.github.io/cycle/javadir/basedir/jsp_dir/jsp_el%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","publishdate":"2021-04-15T00:00:00Z","title":"EL基础教程 "},{"content":"JSTL标签库 JSTL主要有五大类标签库\n core标签库(核心标签库),包括通用标签(输出标签),流程控制和循环控制标签 fmt标签库,包括格式化,国际格式化标签等 fn标签库,函数标签库 XML标签库,关于XML操作的标签库 SQL标签库,操作数据库标签  core标签库用法 使用core标签前必须添加taglie指令\n %@ taglib prefix=\u0026amp;ldquo;c\u0026amp;rdquo; uri=\u0026amp;ldquo;http://java.sun.com/jsp/jstl/core\u0026amp;quot; %\u0026amp;gt;\n  \u0026amp;lt;c:set\u0026amp;gt;在某个范围设定某个值   \u0026amp;lt;c:set value=\u0026amp;ldquo;表达式\u0026amp;rdquo; var=\u0026amp;ldquo;varname\u0026amp;rdquo; [scope=\u0026amp;ldquo;request|page|session|application\u0026amp;rdquo;]\u0026amp;gt;\u0026amp;lt;/c:set\u0026amp;gt;\n \u0026amp;lt;c:set value=\u0026amp;quot;${1+2 }\u0026amp;quot; var=\u0026amp;quot;variable\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:set\u0026amp;gt;\r${variable }\r \u0026amp;lt;c:out\u0026amp;gt;把表达式的结构输出到页面中   \u0026amp;lt;c:out value=\u0026amp;ldquo;表达式\u0026amp;rdquo; [escapeXml=\u0026amp;ldquo;true|false\u0026amp;rdquo;]\u0026amp;gt;\u0026amp;lt;/c:out\u0026amp;gt;\n \u0026amp;lt;c:set value=\u0026amp;quot;${1+2 }\u0026amp;quot; var=\u0026amp;quot;variable\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:set\u0026amp;gt;\r\u0026amp;lt;c:out value=\u0026amp;quot;${variable }\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:out\u0026amp;gt;\r \u0026amp;lt;c:if\u0026amp;gt;条件判断   \u0026amp;lt;c:if test=\u0026amp;ldquo;判断条件\u0026amp;rdquo; [var=\u0026amp;ldquo;varname\u0026amp;rdquo;] [scope=\u0026amp;ldquo;request|page|session|application\u0026amp;rdquo;]\u0026amp;gt; 条件为真执行的语句 \u0026amp;lt;/c:if\u0026amp;gt;\n \u0026amp;lt;c:if test=\u0026amp;quot;${1\u0026amp;lt;2 }\u0026amp;quot; var=\u0026amp;quot;result\u0026amp;quot;\u0026amp;gt;\r\u0026amp;lt;c:out value=\u0026amp;quot;${result }\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:out\u0026amp;gt;\r\u0026amp;lt;/c:if\u0026amp;gt;\r \u0026amp;lt;c:choose\u0026amp;gt;,\u0026amp;lt;c:when\u0026amp;gt;,\u0026amp;lt;c:otherwise\u0026amp;gt;流程控制标签   \u0026amp;lt;c:choose\u0026amp;gt; \u0026amp;lt;c:when test=\u0026amp;ldquo;表达式\u0026amp;rdquo;\u0026amp;gt; 表达式为真执行的语句 \u0026amp;lt;/c:when\u0026amp;gt; [\u0026amp;lt;c:otherwise\u0026amp;gt; 表达式为假执行的语句 \u0026amp;lt;/c:otherwise\u0026amp;gt;] \u0026amp;lt;/c:choose\u0026amp;gt;\n  \u0026amp;lt;c:when\u0026amp;gt;必须在\u0026amp;lt;c:otherwise\u0026amp;gt;前边,\u0026amp;lt;c:choose\u0026amp;gt;可以添加多个\u0026amp;lt;c:choose\u0026amp;gt;,类似于if else if写法\n \u0026amp;lt;c:set value=\u0026amp;quot;8\u0026amp;quot; var=\u0026amp;quot;variable1\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:set\u0026amp;gt;\r\u0026amp;lt;c:set value=\u0026amp;quot;9\u0026amp;quot; var=\u0026amp;quot;variable2\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:set\u0026amp;gt;\r\u0026amp;lt;c:choose\u0026amp;gt;\r\u0026amp;lt;c:when test=\u0026amp;quot;${variable1%2==0 }\u0026amp;quot;\u0026amp;gt;\r\u0026amp;lt;c:out value=\u0026amp;quot;variable1:偶数\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:out\u0026amp;gt;\r\u0026amp;lt;c:choose\u0026amp;gt;\r\u0026amp;lt;c:when test=\u0026amp;quot;${variable2%2==0 }\u0026amp;quot;\u0026amp;gt;\r\u0026amp;lt;c:out value=\u0026amp;quot;variable2:偶数\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:out\u0026amp;gt;\r\u0026amp;lt;/c:when\u0026amp;gt;\r\u0026amp;lt;c:otherwise\u0026amp;gt;\r\u0026amp;lt;c:out value=\u0026amp;quot;variable2:奇数\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;/c:out\u0026amp;gt;\r\u0026amp;lt;/c:otherwise\u0026amp;gt;\r\u0026amp;lt;/c:choose\u0026amp;gt;\r\u0026amp;lt;/c:when\u0026amp;gt;\r\u0026amp;lt;c:otherwise\u0026amp;gt;\r\u0026amp;lt;c:out value=\u0026amp;quot;variable1:奇 …","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"23f5eb37b9232086b97771fd4b134d15","permalink":"https://huachengzhou.github.io/cycle/javadir/basedir/jsp_dir/jsp_jstl_core%E6%A0%87%E7%AD%BE%E5%BA%93/","publishdate":"2021-04-15T00:00:00Z","title":"jsp jstl core 标签库 "},{"content":"Session  HTTP是无状态协议，这意味着每次客户端检索网页时，都要单独打开一个服务器连接，因此服务器不会记录下先前客户端请求的任何信息   会话,当用户打开一个浏览器连接到web应用或者打开某个页面,直到关闭浏览器这个过程叫做会话   Session是保存在服务器上的数据结构，用于跟踪用户的状态。此数据可以保存在群集、数据库、文件中  Session常用方法   public boolean isNew()\n返回是否为一个新的客户端，或者客户端是否拒绝加入session     public Enumeration getAttributeNames()\n返回session对象中所有的对象名称     public int getMaxInactiveInterval()\n返回最大时间间隔，以秒为单位，servlet 容器将会在这段时间内保持会话打开     public long getCreationTime()\n返回session对象被创建的时间， 以毫秒为单位，从1970年1月1号凌晨开始算起     public long getLastAccessedTime()\n返回客户端最后访问的时间，以毫秒为单位，从1970年1月1号凌晨开始算起     public Object getAttribute(String name)\n返回session对象中与指定名称绑定的对象，如果不存在则返回null     public Object getAttribute(String name)\n返回session对象中与指定名称绑定的对象，如果不存在则返回null     public String getId()\n返回session对象的ID     public void invalidate()\n将session无效化，解绑任何与该session绑定的对象     public void removeAttribute(String name)\n移除session中指定名称的对象     public void setAttribute(String name, Object value)\n使用指定的名称和值来产生一个对象并绑定到session中     public void setMaxInactiveInterval(int interval)\n用来指定时间，以秒为单位，servlet容器将会在这段时间内保持会话有效   Session应用 新建SessionDemo类 @WebServlet(\u0026amp;quot;/SessionDemo\u0026amp;quot;)\rpublic class SessionDemo extends HttpServlet {\rprivate int count=0;\rprotected void doGet(HttpServletRequest request, HttpServletResponse response)\rthrows ServletException, IOException {\rrequest.setCharacterEncoding(\u0026amp;quot;utf-8\u0026amp;quot;);\rresponse.setCharacterEncoding(\u0026amp;quot;utf-8\u0026amp;quot;);\rcount++;\rHttpSession session = request.getSession();\rString id = session.getId();\rlong startTime = session.getCreationTime();\rlong lastTime = session.getLastAccessedTime();\rlong validTime = session.getMaxInactiveInterval();\rsession.setMaxInactiveInterval(60);\rSimpleDateFormat myFormat=new SimpleDateFormat(\u0026amp;quot;yyyy/MM/dd HH:mm:ss\u0026amp;quot;);\rresponse.setContentType(\u0026amp;quot;text/html\u0026amp;quot;);\rPrintWriter out = response.getWriter();\rout.println(\u0026amp;quot;\u0026amp;lt;!DOCTYPE HTML PUBLIC \\\u0026amp;quot;-\rout.println(\u0026amp;quot;\u0026amp;lt;HTML\u0026amp;gt;\u0026amp;quot;);\rout.println(\u0026amp;quot; \u0026amp;lt;HEAD\u0026amp;gt;\u0026amp;lt;TITLE\u0026amp;gt;A Servlet\u0026amp;lt;/TITLE\u0026amp;gt;\u0026amp;lt;/HEAD\u0026amp;gt;\u0026amp;quot;); …","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"7f94d8f6b7cadfec08538ea6fc39d0fe","permalink":"https://huachengzhou.github.io/cycle/javadir/basedir/jsp_dir/jsp_jstl_session/","publishdate":"2021-04-15T00:00:00Z","title":"jsp jstl session "},{"content":"字符串el表达式 fn:contains 判断字符串是否包含另外一个字符串 \u0026amp;lt;c:if test=\u0026amp;quot;${fn:contains(name, searchString)}\u0026amp;quot;\u0026amp;gt;\rfn:containsIgnoreCase 判断字符串是否包含另外一个字符串(大小写无关) \u0026amp;lt;c:if test=\u0026amp;quot;${fn:containsIgnoreCase(name, searchString)}\u0026amp;quot;\u0026amp;gt;\rfn:endsWith 判断字符串是否以另外字符串结束 \u0026amp;lt;c:if test=\u0026amp;quot;${fn:endsWith(filename, \u0026amp;quot;.txt\u0026amp;quot;)}\u0026amp;quot;\u0026amp;gt;\rfn:escapeXml 把一些字符转成XML表示，例如 \u0026amp;lt;字符应该转为\u0026amp;lt; ${fn:escapeXml(param:info)}\rfn:indexOf 子字符串在母字符串中出现的位置 ${fn:indexOf(name, \u0026amp;quot;-\u0026amp;quot;)}\rfn:join 将数组中的数据联合成一个新字符串，并使用指定字符格开 ${fn:join(array, \u0026amp;quot;;\u0026amp;quot;)}\rfn:length 获取字符串的长度，或者数组的大小 ${fn:length(shoppingCart.products)}\rfn:replace 替换字符串中指定的字符 ${fn:replace(text, \u0026amp;quot;-\u0026amp;quot;, \u0026amp;quot;?\u0026amp;quot;)}\rfn:split 把字符串按照指定字符切分 ${fn:split(customerNames, \u0026amp;quot;;\u0026amp;quot;)}\rfn:startsWith 判断字符串是否以某个子串开始 \u0026amp;lt;c:if test=\u0026amp;quot;${fn:startsWith(product.id, \u0026amp;quot;100-\u0026amp;quot;)}\u0026amp;quot;\u0026amp;gt;\rfn:substring 获取子串 ${fn:substring(zip, 6, -1)}\rfn:substringAfter 获取从某个字符所在位置开始的子串 ${fn:substringAfter(zip, \u0026amp;quot;-\u0026amp;quot;)}\rfn:substringBefore 获取从开始到某个字符所在位置的子串 ${fn:substringBefore(zip, \u0026amp;quot;-\u0026amp;quot;)}\rfn:toLowerCase 转为小写 ${fn.toLowerCase(product.name)}\rfn:toUpperCase 转为大写字符 ${fn.UpperCase(product.name)}\rfn:trim 去除字符串前后的空格 ${fn.trim(name)}\r函数 描述\rfn:contains(string, substring)\r如果参数string中包含参数substring，返回true\rfn:containsIgnoreCase(string, substring)\r如果参数string中包含参数substring（忽略大小写），返回true\rfn:endsWith(string, suffix)\r如果参数 string 以参数suffix结尾，返回true\rfn:escapeXml(string)\r将有特殊意义的XML (和HTML)转换为对应的XML character entity code，并返回\rfn:indexOf(string, substring)\r返回参数substring在参数string中第一次出现的位置\rfn:join(array, separator)\r将一个给定的数组array用给定的间隔符separator串在一起，组成一个新的字符串并返回。\rfn:length(item)\r返回参数item中包含元素的数量。参数Item类型是数组、collection或者String。如果是String类型,返回值是String中的字符数。\rfn:replace(string, before, after)\r返回一个String对象。用参数after字符串替换参数string中所有出现参数before字符串的地方，并返回替换后的结果 fn:split(string, separator)\r返回一个数组，以参数separator 为分割符分割参数string，分割后的每一部分就是数组的一个元素\rfn:startsWith(string, prefix)\r如果参数string以参数prefix开头，返回true\rfn:substring(string, begin, end)\r返回参数string部分字符串, 从参数begin开始到参数end位置，包括end位置 …","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"31b7a16ac232746bf19b80100979f9e7","permalink":"https://huachengzhou.github.io/cycle/javadir/basedir/jsp_dir/jsp_%E5%AD%97%E7%AC%A6%E4%B8%B2el%E8%A1%A8%E8%BE%BE%E5%BC%8F/","publishdate":"2021-04-15T00:00:00Z","title":"字符串el表达式 "},{"content":" Groovy是一种面向对象的动态类型语言，跟Java一样运行在JVM上。\n（注：给Java静态世界带来动态能力的语言）\n 目录   groovy中对象的比较以及非空判断\n  groovy使用场景\n  groovy变量\n  groovy变量和数据类型加强\n  groovy基本概念\n  groovy学习\n  groovy数据类型\n  如何在groovy中获取以另一个变量命名的变量的值\n  回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"b94e724d8644cc445d59a33c1c97669a","permalink":"https://huachengzhou.github.io/cycle/javadir/groovy/","publishdate":"2021-04-15T00:00:00Z","title":"groovy 学习与使用 "},{"content":"groovy 对象比较以及空判断  目前测试得知 groovy的比较貌似很多直接可以使用==来比较\n groovy对象的比较 1.字符串比较 def str1 = \u0026amp;quot;Hello World1\u0026amp;quot;\rif (\u0026amp;quot;Hello World\u0026amp;quot; == str1) {\rprintln \u0026amp;quot;Hello World\u0026amp;quot;\r} else {\rprintln \u0026amp;quot;不匹配\u0026amp;quot;\r}\r2.map集合的比较（list集合也可以这样比较） \tdef m1=[\u0026amp;quot;name\u0026amp;quot;:\u0026amp;quot;李明\u0026amp;quot;,\u0026amp;quot;age\u0026amp;quot;:20]\rdef m2=[\u0026amp;quot;name\u0026amp;quot;:\u0026amp;quot;李明\u0026amp;quot;,\u0026amp;quot;age\u0026amp;quot;:21]\rdef m3=[\u0026amp;quot;name\u0026amp;quot;:\u0026amp;quot;李明\u0026amp;quot;,\u0026amp;quot;age\u0026amp;quot;:21]\rif(m1==m2){\rprintln \u0026amp;quot;m1和m2匹配\u0026amp;quot;\r}else{\rprintln \u0026amp;quot;m1和m2不匹配\u0026amp;quot;\r}\r  特别是字符串的比较，是不是比java要简洁的多呢\n  如果要比较两个对象的引用是否相同在groovy中可以使用is\n  def list1 = []\rdef list2 = [1,2,3,4]\rboolean check = list1.is(list2) ;\rprintln(check)\rif 判断对象是否为空  groovy中判断对象是否为空，直接if(对象){}即可，这种便捷真的很强  def list1 = []\rdef list2 = [1,2,3,4]\r//直接写入 有点像C语言里面if可以直接把0,和非0作为boolean来比较\rif (!list1){\rprintln(\u0026amp;quot;list1为null\u0026amp;quot;) ;\r}\rif (list2){\rprintln(\u0026amp;quot;list2不为null\u0026amp;quot;) ;\r}\r 特殊判断法  //def m5 = [name:\u0026amp;quot;a\u0026amp;quot;];\rdef m5 = [];\rprintln \u0026amp;quot;${m5?.name}\u0026amp;quot; ;\r//注意目前我用list失败了\rprintln \u0026amp;quot;${list1?.get(0)}\u0026amp;quot; ; //报error 数组越界 因此这种写法只适合map\r回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"8f23925c0960a602fc3f18504a9fe55c","permalink":"https://huachengzhou.github.io/cycle/javadir/groovy/groovy%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%E4%BB%A5%E5%8F%8A%E9%9D%9E%E7%A9%BA%E5%88%A4%E6%96%AD/","publishdate":"2021-04-15T00:00:00Z","title":" groovy对象比较以及空判断 "},{"content":"groovy 使用场景 Groovy可以用于多种情况。比如   1、作为shell脚本语言完成数据处理和文件操作任务。\n  2、在Java或者Java EE应用程序中嵌入Groovy，实现Java和Groovy的集成。（这样有助于编写和集中处理经常变化的业务逻辑，或者给应用程序架构提供可编程的配置管理能力。）\n  Groovy是增强Java平台的唯一的脚本语言。  它提供了类似于Java的语法，内置映射（Map）、列表（List）、方法、类、闭包（closure）以及生成器。  脚本语言与系统编程语言：  脚本语言不会替代系统编程语言，两者是相互补充的。\n 系统编程语言的目的：   开发复杂的算法或者数据结构\n  实现计算密集型应用\n  操作大型数据集\n  实现定义良好的、变更缓慢的需求\n  脚本语言应用的目的：   连接已有的组件\n  处理经常变化的多种类型的实体\n  具有图形化用户界面\n  拥有快速变化的功能\n  Java编译器会产生可以在Java虚拟机上运行的字节码。 Groovy类和Java是二进制兼容的。 Groovy编译器产生的字节码与Java编译器产生的字节码是完全一样的。 ——对于JVM而言，Groovy和Java是完全一样的。 因此，Groovy能够完全使用各种Java API。 Groovy是一门面向对象的语言。也就是说，Groovy中每一个事物最终都会被当做某些类 的一个实例对象。 回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"07d0b61b253ecec5e3f40f0642137f52","permalink":"https://huachengzhou.github.io/cycle/javadir/groovy/groovy%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","publishdate":"2021-04-15T00:00:00Z","title":" groovy使用场景 "},{"content":"Groovy 变量  Groovy中的变量可以通过两种方式定义 - 使用数据类型的本地语法，或者使用def关键字。对于变量定义，必须明确提供类型名称或在替换中使用“def”。这是Groovy解析器需要的。\n   byte - 这用于表示字节值。例如2。\n  short - 用于表示一个短数。例如10。\n  int - 这用于表示整数。 例如1234。\n  long - 这用于表示一个长数。例如10000090。\n  float - 用于表示32位浮点数。例如12.34。\n  double - 这用于表示64位浮点数。例如12.3456565。\n  char - 这定义了单个字符文字。例如\u0026amp;rsquo;a\u0026#39;。\n  Boolean - 这表示一个布尔值，可以是true或false。\n  String - 这是以字符串形式表示的文本。 例如“Hello World”。\n  Groovy还允许其他类型的变量，如数组，结构和类\n  变量声明  title: \u0026amp;quot; groovy变量 \u0026amp;quot; date: 2021-04-15 draft: false weight: 3   变量声明告诉编译器为变量创建存储的位置和大小。\n  下面是一个变量声明的例子 -\n  // x is defined as a variable String x = \u0026amp;quot;Hello\u0026amp;quot;;\r// The value of the variable is printed to the console println(x);\r 当我们运行上面的程序，我们会得到以下结果   Hello  变量命名  变量的名称可以由字母，数字和下划线字符组成。 它必须以字母或下划线开头。 大写和小写字母是不同的，因为Groovy，就像Java是一种区分大小写的编程语言。  // Defining a variable in lowercase int x = 5;\r// Defining a variable in uppercase int X = 6; // Defining a variable with the underscore in it\u0026#39;s name def _Name = \u0026amp;quot;Joe\u0026amp;quot;; println(x); println(X); println(_Name); 5\r6\rJoe\r你好,世界 !\r 除此之外 在groovy中 定义变量也是可以不加 def 或者 基本类型   a = 125;\n回到上一级 ","date":-62135596800,"description":"","objectID":"d5ef59df31eff0ca0c2ab5b15861febd","permalink":"https://huachengzhou.github.io/cycle/javadir/groovy/groovy%E5%8F%98%E9%87%8F/","title":""},{"content":"groovy 变量和数据类型 groovy类型自动推断  先看有一段代码  def a = 12;\rdef int a1 = 12;\rdef a_type = a instanceof Integer ;\rdef a1_type = a1 instanceof Integer ;\rprintln(a_type) ;\rprintln(a1_type) ;\r//打印结果如下\rtrue\rtrue\r 从上面我们可以看出a和a1实际推导出的类型是一样的,但是有哪些不同呢 接着我把上面的例子改了  def a = 12;\rdef int a1 = 12;\rdef a_type = a instanceof Integer ;\rdef a1_type = a1 instanceof Integer ;\rprintln(a_type) ;\rprintln(a1_type) ;\ra = 52253.46f ;\ra1 = 52253.46f ;\rprintln(a instanceof Integer) ;\rprintln(a1 instanceof Integer) ;\rprintln(\u0026amp;quot;a1 的值:\u0026amp;quot;+a1) ;\rprintln(\u0026amp;quot;a 的 值 :\u0026amp;quot;+a) ;\r//print result\rtrue\rtrue\rfalse\rtrue\ra1 的值:52253\ra 的 值 :52253.46\r  看吧神奇的事情出来了, a1 的 参数类型即便被赋值了浮点数但是类型并没有改变,并且精度和赋值的值相比降低了,而 a 的类型却改变了\n另外假如在idea中编辑变量 编辑器也会提示你\rAssignment is not used less... (Ctrl+F1) Inspection info: Reports on unnecessary Groovy assignment statement Possible loss of precision from \u0026#39;Float\u0026#39; to \u0026#39;int\u0026#39; less... (Ctrl+F1) Inspection info: Reports assignments with incompatible types\r  假如接着上面的例子给 a变量和a1变量分别赋值字符串类型会怎样呢 (算了还是重新写吧好看点)\n  int b = 141;\rx = 141;\rprintln(b) ;\rprintln(x) ;\rb = \u0026amp;quot;字符串b\u0026amp;quot; ;\rx = \u0026amp;quot;字符串x\u0026amp;quot; ;\rprintln(b) ;\rprintln(x) ;\r//运行会怎样呢?\r141\rCaught: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object \u0026#39;字符串b\u0026#39; with class \u0026#39;java.lang.String\u0026#39; to class \u0026#39;int\u0026#39;\r141\rorg.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object \u0026#39;字符串b\u0026#39; with class \u0026#39;java.lang.String\u0026#39; to class \u0026#39;int\u0026#39;\rat gr.h1.t4.run(t4.groovy:10)\r  以上我们可以看出在groovy中赋值的时候系统会尝试强转类型,上面的例子是转失败的情况\n  因此在定义变量的时候尽量不要去更改已经定义的变量的类型,尽量 申明变量类型\n  变量的类型检测方法\n  var_name instanceof type 如 a instanceof Integer\n  b.class == Integer 或 b.class.equals(Integer)\n  回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"6ed8204996f03e3b2211460e52721256","permalink":"https://huachengzhou.github.io/cycle/javadir/groovy/groovy%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8A%A0%E5%BC%BA/","publishdate":"2021-04-15T00:00:00Z","title":" groovy变量和数据类型 "},{"content":"groovy 基本概念 1、基本概念  Groovy是一种面向对象的动态类型语言，跟Java一样运行在JVM上。\n（注：给Java静态世界带来动态能力的语言）\n   与Java不同的语言特性：\n  a) 函数字面值\n  b) 对集合的一等支持\n  c) 对正则表达式的一等支持\n  d) 对XML处理的一等支持\n  （注：所谓“一等”指的是内置到语言的语法中，不需要调用类库。）\n  2:Groovy能解决包括：   快速Web开发\n  原型设计\n  脚本处理\n  等问题，这些使用Java不是解决动态层问题的理想语言。\n  例如:\nSystem.out.println(\u0026amp;quot;It\u0026#39;s a Groovy baby, yeah!\u0026amp;quot;);\rdef writer = new StringWriter();\rdef xml = new groovy.xml.MarkupBuilder(writer);\rxml.person(id:2){\rname \u0026#39;kobicc\u0026#39;\rage 1\r}\rprintln writer.toString();\r回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"a58bcc5c3f91f09aab3de5fb8377e3d9","permalink":"https://huachengzhou.github.io/cycle/javadir/groovy/groovy%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","publishdate":"2021-04-15T00:00:00Z","title":"groovy 基本概念 "},{"content":"Groovy 概述  Groovy是一种基于Java平台的面向对象语言。 Groovy 1.0于2007年1月2日发布，其中Groovy 2.4是当前的主要版本。 Groovy通过Apache License v 2.0发布。  Groovy的特点  同时支持静态和动态类型。 支持运算符重载。 本地语法列表和关联数组。 对正则表达式的本地支持。 各种标记语言，如XML和HTML原生支持。 Groovy对于Java开发人员来说很简单，因为Java和Groovy的语法非常相似。 您可以使用现有的Java库。 Groovy扩展了java.lang.Object。  groovy-脚本和类   在groovy中定义类和java中是一样的。类的方法可以是static，也可以是非static的\n  groovy中的方法可以是public, protected, private，同时也支持java中的修饰符，比如synchronized\n  groovy自动导入的包有以下这些\n   groovy.lang.* groovy.util.* java.lang.* java.util.* java.net.* java.io.* import java.math.BigInteger import java.math.BigDecimal    在groovy和java中不同的一点就是，groovy默认是public的\n  每一个groovy类，在JVM层级，都是字节码形式的java code，所以在java代码中可以调用groovy中申明的方法，反之亦然\n  你可以指定方法的参数和返回值，以便他们能够更好的和java代码相互调用。当然你也可以实现接口或者重载方法。但是需要你没有指定方法后者属性的类型的话，那么在JVM层级的字节码中，他们将会是 java.lang.Object 类型\n  例如 Callee.groovy\n  class Callee{\rvoid hello(){\rprintln \u0026amp;quot;hello, world\u0026amp;quot; ;\r}\r}\rc = new Callee() ;\rc.hello();\r 创建你的第一个 Hello World 程序  class Example1 {\rpublic static void main(String[] args) {\rprintln(\u0026amp;quot;你好,世界 !\u0026amp;quot;) ;\r}\r}\r你好,世界 !\n 当然你也可以不定义一个类 因为groovy中行得通  println(\u0026amp;quot;你好,世界 !\u0026amp;quot;) ;同样可以打印出字符串  在 Groovy 中导入语句  import 语句可以用来导入，可以让你的代码使用其他库的功能。这是通过使用在 Import 关键字完成。 下面的示例演示了如何使用 MarkupBuilder 的类，它可能是最常用的创建 HTML 或 XML 标记的类之一。  import groovy.xml.MarkupBuilder def xml = new MarkupBuilder() Groovy 令牌   令牌可以是一个关键字，一个标识符，常量，字符串文字或符号。 println(“Hello World”);\n  在上面的代码行中，有两个令牌，首先是关键词的 println 而接下来就是字符串的“Hello World”。\n  Groovy 注释  在您的代码中使用注释。Groovy 的注释可以是单行或多行。单行注释使用 // 在该行的任何位置来识别。一个例子如下所示 -  class Example {\rstatic void main(String[] args) {\r// Using a simple println statement to print output to the console\rprintln(\u0026#39;Hello World\u0026#39;);\r}\r}\r分号  就像 Java 编程语言，它需要具有分号在 Groovy 定义多个语句之间进行区分。  class Example {\rstatic void main(String[] args) {\r// One can see the use of a semi-colon after each statement\rdef x = 5;\rprintln(\u0026#39;Hello World\u0026#39;); }\r}\r身份标识  标识符被用来定义变量，函数或其他用户定义的变量。标识符以字母开头，美元或下划线。他们不能以数字开头。以下是有效标识符的一些例子  def employeename def student1 def student_name\r 其中**，DEF** 是在 Groovy 用来定义标识符的关键字。下 …","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"eb666916c1c70fced38eabfe4ca8d4c7","permalink":"https://huachengzhou.github.io/cycle/javadir/groovy/groovy%E5%AD%A6%E4%B9%A0/","publishdate":"2021-04-15T00:00:00Z","title":" Groovy 概述 "},{"content":"Groovy 数据类型  在任何编程语言中，需要使用各种变量来存储各种类型的信息。变量只是保留值的存储位置,这意味着，当你创建一个变量，你保留在内存中的一些空间来存储与变量相关的值。\n  您可能喜欢存储各种数据类型的信息，如字符串，字符，宽字符，整数，浮点数，布尔值等。基于变量的数据类型，操作系统分配内存并决定什么可以存储在保留的存储器中。\n 内置数据类型  byte -这是用来表示字节值。例如2。 short -这是用来表示一个短整型。例如10。 int -这是用来表示整数。例如1234。 long -这是用来表示一个长整型。例如10000090。 float -这是用来表示32位浮点数。例如12.34。 double -这是用来表示64位浮点数，这些数字是有时可能需要的更长的十进制数表示。例如12.3456565。 char -这定义了单个字符文字。例如“A”。 Boolean -这表示一个布尔值，可以是true或false。 String -这些是以字符串的形式表示的文本。例如，“Hello World”的  绑定值    类型 值     byte -128到127   short -32,768到32,767   int 2,147,483,648 到,147,483,647   long -9,223,372,036,854,775,808到+9,223,372,036,854,775,807   float 1.40129846432481707e-45到3.40282346638528860e + 38   double 4.94065645841246544e-324d 到1.79769313486231570e + 308d    包装器类型  java.lang.Byte java.lang.Short java.lang.Integer java.lang.Long java.lang.Float java.lang.Double     名称 描述 例如     java.math.BigInteger 不可变的任意精度的有符号整数数字 30克   java.math.BigDecimal 不可变的任意精度的有符号十进制数 3.5克    package gr.h1\r//Example of a int datatype\rint x = 5;\r//Example of a long datatype\rlong y = 100L;\r//Example of a floating point datatype\rfloat a = 10.56f;\r//Example of a double datatype\rdouble b = 10.5e40;\r//Example of a BigInteger datatype\rBigInteger bi = 30g;\r//Example of a BigDecimal datatype\rBigDecimal bd = 3.5g; //加上这个g也没事的 这是groovy特有的如java中的double a = 3.232d\rBigDecimal bd2 = 235.2323552;\rprintln(x);\rprintln(y);\rprintln(a);\rprintln(b);\rprintln(bi);\rprintln(bd);\rprintln(bd2);\r5\r100\r10.56\r1.05E41\r30\r3.5\r235.2323552\r回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"59f22bb7bdd0265ddaadc46cfe206ec4","permalink":"https://huachengzhou.github.io/cycle/javadir/groovy/groovy%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","publishdate":"2021-04-15T00:00:00Z","title":"groovy 数据类型 "},{"content":"groovy变量值获取 `\nhttps://www.codenong.com/34288451/\n`\n回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"96d42df6cbf1b9ffdbdf2381ba877df4","permalink":"https://huachengzhou.github.io/cycle/javadir/groovy/%E5%A6%82%E4%BD%95%E5%9C%A8groovy%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%BB%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/","publishdate":"2021-04-15T00:00:00Z","title":" groovy变量值获取 "},{"content":"目录  Redis 学习与使用  ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"d555dfb329cbc31b69a9f44bb4e7d3b2","permalink":"https://huachengzhou.github.io/cycle/javadir/middleware/","publishdate":"2021-04-15T00:00:00Z","title":"中间件 "},{"content":"一.Redis介绍 1.1引言  1:由于用户量大，请求了随之增大，数据压力过大。 2:多台服务器之间数据不同步 3:多台服务器之间的锁已经不存在互斥性了\n  1.2 NOSQL  redis就是nosql\n  非关系数据库 \u0026amp;gt; not only sql\n 1:key-value redis 2:文档型 solr,Mongodb,ElasticSearch 3:面向列 Hbase(一般大数据) 4:图形化 Neo4j\n  1.3 redis介绍  Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 Redis是一款基于Key-Value的NOSQL，而且Redis是基于内存存储数据的,Redis还提供了多种持久化机制，Redis还提供了主从、哨兵以及集群的搭建方式，可以更方便的横向扩展以及垂直扩展\n  操作都是原子的\n 所有 Redis 的操作都是原子的，从而确保当两个客户同时访问 Redis 服务器时，得到的是更新后的值（最新值）。在需要高并发的场合可以考虑使用 Redis 的事务，处理一些需要锁的业务。\n  二.Redis安装 三.Redis命令  keys * 获取所有的key\rclear 清除屏幕\rquit ,exit 退出\rset name blake 设置值\rsetex ip 5 192.1.1.168 设置值并且设置过期时长\rget name 取出值\rdel name 删除key所对应的值\rexists key 判断是否存在key\rmset key1,key2...设置多个值\rmget key1,key2...取出多个值\rappend age 1 追加key的value\rstrlen key 获取某个key的value的长度\rselect index 选择数据库 (注意redis一共16个数据库 并且从0开始)\rmove key db或者 move key index (redis一共16个数据库 move age 7) 将某个key移动到某个数据库中\rflushdb 清除当前数据库\rflushall 清除16个数据库\rtype key 获取数据类型 (type name == \u0026amp;gt; string)\r3.1 redis存储数据结构  字符串列表 key-string 无序不重复的字符串集合 key-set 有序不重复的字符串集合 key-list 键、值都为字符串的哈希表 key-hash 有序集合 key-zset  3.2存储结构用处  key-string :最常用的，一般用于存储一个值 key-hash:存储一个对象数据的 key-list:使用list结构实现栈和队列结构 key-set: 交集、差集、并集操作 key-zset : 排行榜,积分存储  回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"1e1fb24d82a85031845a9ed35a0cdaaa","permalink":"https://huachengzhou.github.io/cycle/javadir/middleware/redis/","publishdate":"2020-01-17T15:26:15Z","title":"Redis 学习与使用"},{"content":"目录  Apache Commons 工具类介绍及简单使用 org.apache.commons.io.FilenameUtils 操作 dom4j 处理 xml Guava 基于java1.6的类库集合的扩展项目 常用 Console 调试命令 jsoup学习文档 spring工具 spring常用的工具类  ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"b86dd910909ab8086dd8748d575cd27b","permalink":"https://huachengzhou.github.io/cycle/javadir/tooldoc/","publishdate":"2021-04-15T00:00:00Z","title":"Java公共库文档总结 "},{"content":"Apache Commons 工具类介绍及简单使用    组件 功能介绍     BeanUtils Commons-BeanUtils 提供对 Java 反射和自省API的包装, 提供了对于JavaBean进行各种操作，克隆对象,属性等等.   Betwixt XML与Java对象之间相互转换.   Codec 处理常用的编码方法的工具类包 例如DES、SHA1、MD5、Base64等.   Collections java集合框架操作.   Compress java提供文件打包 压缩类库.   Configuration Commons-Configuration 工具对各种各式的配置和参考文件提供读取帮助,java应用程序的配置管理类库.   DBCP 提供数据库连接池服务.   DbUtils DbUtils 是一个 JDBC helper 类库，完成数据库任务的简单的资源清除代码,提供对jdbc 的操作封装来简化数据查询和记录读取操作   Email java发送邮件 对javamail的封装.   FileUpload 提供文件上传功能.   HttpClient 提供HTTP客户端与服务器的各种通讯操作. 现在已改成HttpComponents   Lang Java基本对象方法的工具类包 如：StringUtils,ArrayUtils等等.   Logging 提供的是一个Java 的日志接口.   Validator 提供了客户端和服务器端的数据验证框架.   Primitives Commons-Primitives提供了一个更小，更快和更易使用的对Java基本类型的支持。当前主要是针对基本类型的 collection。   Math Math 是一个轻量的，自包含的数学和统计组件，解决了许多非常通用但没有及时出现在Java标准语言中的实践问题   EL Commons-EL 提供在JSP2.0规范中定义的EL表达式的解释器.   Discovery Commons-Discovery 提供工具来定位资源 (包括类) ，通过使用各种模式来映射服务/引用名称和资源名称。   Digester Commons-Digester 是一个 XML-Java对象的映射工具，用于解析 XML配置文件.   Chain Chain 提供实现组织复杂的处理流程的“责任链模式”   Modeler Commons-Modeler 提供了建模兼容JMX规范的Mbean的机制.   Net Net 是一个网络工具集，基于 NetComponents 代码，包括 FTP 客户端等等    一:org.apache.commons.lang  ArrayUtils – 用于对数组的操作，如添加、查找、删除、子数组、倒序、元素类型转换等；  ArrayUtils类\rArrayUtils.toString(array) 将数组转为为字符串，格式如：{2,4,8,16}\rArrayUtils.contains(array,8) 判断数组中是否包含数字8，（一维数组）\rArrayUtils.indexOf(array,8) 判断数组中第一个8的位置（一维数组）\rArrayUtils.lastIndexOf(array,8) 判断数组中最后一个8的位置。（一维数组）\rArrayUtils.clone(array) 给一个一维数组来个拷贝\rArrayUtils.reverse(array); 翻转该一维数组\rArrayUtils.toMap(array); 将一个二维数组转换为map，二维数组中至少与两列，第一列为key第二列为value == \u0026amp;gt;注意的是传入toMap()中的二维数组必须是对象如Integer\r  BitField – 用于操作位元，提供了一些方便而安全的方法；\n  BooleanUtils – 用于操作和转换 boolean 或者 Boolean 及相应的数组；\n   boolean[] booleans = new boolean[]{true, false, true};\r//和，并且\rSystem.out.println(BooleanUtils.and(booleans));//false\r//或者\rSystem.out.println(BooleanUtils.or(booleans));//true\rProjectInfo projectInfo = null;\rif (projectInfo != null \u0026amp;amp;\u0026amp;amp; projectInfo.getId() != 0);\r//可以用上面的改为\rBooleanUtils.and(new boolean[]{projectInfo != …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"9144bc9f84e9d4098506c66c57e3201f","permalink":"https://huachengzhou.github.io/cycle/javadir/tooldoc/apache-common%E5%B7%A5%E5%85%B7%E5%8C%85/","publishdate":"2020-01-17T15:26:15Z","title":"Apache Commons 工具类介绍及简单使用"},{"content":"org.apache.commons.io.FilenameUtils 文件名称操作   FilenameUtils.getExtension(fileName) 获取文件后缀 //text\n  FilenameUtils.getName(fileName) 获取文件完整名称 //c.text\n  FilenameUtils.getBaseName(fileName) 获取文件名称 //c\n  FilenameUtils.getFullPath(fileName) 获取文件的完整路径 //D:\\data\\\n  String path = \u0026amp;quot;D:\\\\data\\\\假设开发法土地模板.docx\u0026amp;quot; ;\rString fullPath = FilenameUtils.getFullPath(path);\rSystem.out.println(\u0026amp;quot;fullPath:\u0026amp;quot;+fullPath);//D:\\data\\\rString name = FilenameUtils.getName(path);\rSystem.out.println(\u0026amp;quot;name:\u0026amp;quot;+name); //假设开发法土地模板.docx\rString prefix = FilenameUtils.getPrefix(path);\rSystem.out.println(\u0026amp;quot;prefix:\u0026amp;quot;+prefix); //D:\\\rint prefixLength = FilenameUtils.getPrefixLength(path);\rSystem.out.println(\u0026amp;quot;prefixLength:\u0026amp;quot;+prefixLength); //3\rString path1 = FilenameUtils.getPath(path);\rSystem.out.println(\u0026amp;quot;path:\u0026amp;quot;+path1); //data\\\rString baseName = FilenameUtils.getBaseName(path);\rSystem.out.println(\u0026amp;quot;baseName:\u0026amp;quot;+baseName); //假设开发法土地模板\rString extension = FilenameUtils.getExtension(path);\rSystem.out.println(\u0026amp;quot;extension:\u0026amp;quot;+extension); //docx\rFileUtils：提供文件操作（移动文件，读取文件，检查文件是否存在等等） String path = \u0026amp;quot;D:\\\\data\\\\test\u0026amp;quot;;\rString fileSize = FileUtils.byteCountToDisplaySize(1024 * 1024);\r// 转换文件长度单位\rAssert.assertEquals(\u0026amp;quot;1 MB\u0026amp;quot;, fileSize);\r// 清空某目录下的所有目录,含文件夹和文件,注意是目录下,不包含父目录\rFileUtils.cleanDirectory(new File(path));\r// copy URL中文件到參數2\rFileUtils.copyURLToFile(new URL(\u0026amp;quot;https://v3.bootcss.com/\u0026amp;quot;), new File(\u0026amp;quot;D:\\\\data\\\\test1\\\\a1.txt\u0026amp;quot;));//a1.txt 里面拷贝下来是一个网页\r// 强制删除文件\rFileUtils.forceDelete(new File(\u0026amp;quot;D:\\\\data\\\\test1\\\\a1.txt\u0026amp;quot;));\r// 将文件转为 InputStream\rFileUtils.openInputStream(new File(\u0026amp;quot;D:\\\\data\\\\aac.pptx\u0026amp;quot;));\r//openOutStream\rFileUtils.openOutputStream(new File(\u0026amp;quot;D:\\\\data\\\\aac.pptx\u0026amp;quot;));\r// 读取文件转为字节数组\rbyte[] bytes = FileUtils.readFileToByteArray(new File(\u0026amp;quot;D:\\\\data\\\\aab.pptx\u0026amp;quot;));\r// 读取文件转换为String类型,方便文本读取\rFileUtils.readFileToString(new File(\u0026amp;quot;D:\\\\data\\\\aab.pptx\u0026amp;quot;),\u0026amp;quot;UTF-8\u0026amp;quot;);\r// …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"4333de0b323c60379dfc1a07d0c96423","permalink":"https://huachengzhou.github.io/cycle/javadir/tooldoc/commons_io/","publishdate":"2020-01-17T15:26:15Z","title":"apache FilenameUtils 文件名称操作"},{"content":"dom4j  选取节点\n   nodename 选取当前节点的所有子节点\n  / 从根节点选取\n  // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置\n  . 选取当前节点\n  .. 选取当前节点的父节点\n  @ 选取属性\n   实例\n   路径表达式 结果\n  bookstore 选取 bookstore 元素的所有子节点\n  /bookstore 选取根元素 bookstore\n  bookstore/book 选取bookstore 下名字为 book的所有子元素。\n  //book 选取所有 book 子元素，而不管它们在文档中的位置。\n  bookstore//book 选取bookstore 下名字为 book的所有后代元素，而不管它们位于 bookstore 之下的什么位置。\n  //@lang 选取所有名为 lang 的属性。\n   常见的谓语的一些路径表达式\n  /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()\u0026amp;lt;3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 //title[@lang=\u0026amp;lsquo;eng\u0026amp;rsquo;] 选取所有 title 元素，要求这些元素拥有值为 eng 的 lang 属性。 /bookstore/book[price\u0026amp;gt;35.00] 选取所有 bookstore 元素的 book 元素，要求book元素的子元素 price 元素的值须大于 35.00。 /bookstore/book[price\u0026amp;gt;35.00]/title 选取所有 bookstore 元素中的 book 元素的 title 元素，要求book元素的子元素 price 元素的值须大于 35.00   选取未知节点\n  通配符 描述   匹配任何元素节点   @* 匹配任何属性节点 node() 匹配任何类型的节点 路径表达式 结果 //book/title | //book/price 选取所有 book 元素的 title 和 price 元素。 //title | //price 选取所有文档中的 title 和 price 元素。 /bookstore/book/title|//price 选取所有属于 bookstore 元素的 book 元素的title 元素，以及文档中所有的 price 元素。  回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"7a1f2aa6990001b4b2bd7a4f2675bf91","permalink":"https://huachengzhou.github.io/cycle/javadir/tooldoc/dom4j/","publishdate":"2020-01-17T15:26:15Z","title":"dom4j"},{"content":"Guava 基于java1.6的类库集合的扩展项目  com.google.common.annotations：普通注解类型。 com.google.common.base：基本工具类库和接口。 com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存。 com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类，这里你会发现很多好玩的集合。 com.google.common.eventbus：发布订阅风格的事件总线。 com.google.common.hash： 哈希工具包。 com.google.common.io：I/O工具包。 com.google.common.math：原始算术类型和超大数的运算工具包。 com.google.common.net：网络工具包。 com.google.common.primitives：八种原始类型和无符号类型的静态工具包。 com.google.common.reflect：反射工具包。 com.google.common.util.concurrent：多线程工具包。\r 常见Object方法   hashCode compare/compareTo 实现一个比较器[Comparator]，或者直接实现Comparable接口有时也伤不起\n public class ProjectInfo implements Serializable,Comparable\u0026amp;lt;ProjectInfo\u0026amp;gt; {\rprivate int id;\rprivate String name;\rpublic int getId() {\rreturn id;\r}\rpublic String getName() {\rreturn name;\r}\rpublic void setId(int id) {\rthis.id = id;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\r@Override\rpublic int compareTo(ProjectInfo o) {\rreturn ComparisonChain.start().compare(this.getName(),o.getName()).compare(this.getId(),o.getId()).result();\r}\r@Override\rpublic int hashCode() {\rreturn Objects.hashCode(getId(),getName());\r}\r}\r 当一个对象中的字段可以为null时，实现Object.equals方法会很痛苦，因为不得不分别对它们进行null检查。 使用Objects.equal帮助你执行null敏感的equals判断，从而避免抛出NullPointerException\n public void testA(){\rSystem.out.println(Objects.equal(\u0026amp;quot;a\u0026amp;quot;,\u0026amp;quot;a\u0026amp;quot;));// --\u0026amp;gt;true\rSystem.out.println(Objects.equal(\u0026amp;quot;a\u0026amp;quot;,\u0026amp;quot;\u0026amp;quot;));// --\u0026amp;gt;false\rSystem.out.println(Objects.equal(\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;\u0026amp;quot;));// --\u0026amp;gt;true\rSystem.out.println(Objects.equal(\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;w\u0026amp;quot;));// --\u0026amp;gt;false\rSystem.out.println(Objects.equal(null,null));// --\u0026amp;gt;true\rSystem.out.println(Objects.equal(null,\u0026amp;quot;\u0026amp;quot;));// --\u0026amp;gt;false\r}\r toString 好的toString方法在调试时是无价之宝，但是编写toString方法有时候却很痛苦。使用MoreObjects(低版本还是Objects)\n System.out.println(MoreObjects.toStringHelper(this).add(\u0026amp;quot;x\u0026amp;quot;,2).\radd(\u0026amp;quot;y\u0026amp;quot;,Math.round(Math.random()*10)).toString());\r/*console : ObjectsDemo{x=2, y=9}*/\r Preconditions   前置条件Preconditions提供静态方法来 …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"c7c863ddcf76cff8e99ab4faa00efc7b","permalink":"https://huachengzhou.github.io/cycle/javadir/tooldoc/guava-common/","publishdate":"2020-01-17T15:26:15Z","title":"Guava 基于java1.6的类库集合的扩展项目"},{"content":"Console 对象方法   常用 Console 调试命令\n  console.log(\u0026#39;hello\u0026#39;);\rconsole.info(\u0026#39;信息\u0026#39;);\rconsole.error(\u0026#39;错误\u0026#39;);\rconsole.warn(\u0026#39;警告\u0026#39;);\rassert()  ssert方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。  // 实例\rconsole.assert(true === false, \u0026amp;quot;判断条件不成立\u0026amp;quot;)\r// Assertion failed: 判断条件不成立\rclear()  清除当前控制台的所有输出，将光标回置到第一行。  console.clear()\rcount()  用于计数，输出它被调用了多少次。  (function() {\rfor (var i = 0; i \u0026amp;lt; 5; i++) { console.count(\u0026#39;count\u0026#39;); }\r})()\rerror()  输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈。  console.error(\u0026amp;quot;Error: %s (%i)\u0026amp;quot;, \u0026amp;quot;Server is not responding\u0026amp;quot;,500)\rgroup()  用于将显示的信息分组，可以把信息进行折叠和展开。  console.group(\u0026#39;第一层\u0026#39;);\rconsole.group(\u0026#39;第二层\u0026#39;);\rconsole.log(\u0026#39;error\u0026#39;);\rconsole.error(\u0026#39;error\u0026#39;);\rconsole.warn(\u0026#39;error\u0026#39;);\rconsole.groupEnd(); console.groupEnd();\rinfo()  console.log 别名，输出信息  console.info(\u0026amp;quot;runoob\u0026amp;quot;)\rlog()  输出信息  console.log(\u0026amp;quot;runoob\u0026amp;quot;)\rtable()  将复合类型的数据转为表格显示。  var arr= [ { num: \u0026amp;quot;1\u0026amp;quot;},\r{ num: \u0026amp;quot;2\u0026amp;quot;}, { num: \u0026amp;quot;3\u0026amp;quot; }\r];\rconsole.table(arr);\rvar obj= {\ra:{ num: \u0026amp;quot;1\u0026amp;quot;},\rb:{ num: \u0026amp;quot;2\u0026amp;quot;},\rc:{ num: \u0026amp;quot;3\u0026amp;quot; }\r};\rconsole.table(obj);\rtime() ++ 计时开始\nconsole.time(\u0026#39;计时器1\u0026#39;);\rfor (var i = 0; i \u0026amp;lt; 100; i++) {\rfor (var j = 0; j \u0026amp;lt; 100; j++) {}\r}\rconsole.timeEnd(\u0026#39;计时器1\u0026#39;);\rconsole.time(\u0026#39;计时器2\u0026#39;);\rfor (var i = 0; i \u0026amp;lt; 1000; i++) {\rfor (var j = 0; j \u0026amp;lt; 1000; j++) {}\r}\rconsole.timeEnd(\u0026#39;计时器2\u0026#39;);\rtimeEnd()  计时结束  console.time(\u0026#39;计时器1\u0026#39;);\rfor (var i = 0; i \u0026amp;lt; 100; i++) {\rfor (var j = 0; j \u0026amp;lt; 100; j++) {}\r}\rconsole.timeEnd(\u0026#39;计时器1\u0026#39;);\rconsole.time(\u0026#39;计时器2\u0026#39;);\rfor (var i = 0; i \u0026amp;lt; 1000; i++) {\rfor (var j = 0; j \u0026amp;lt; 1000; j++) {}\r}\rconsole.timeEnd(\u0026#39;计时器2\u0026#39;);\rwarn()  输出警告信息  console.warn(\u0026amp;quot;警告\u0026amp;quot;)\r 最常用的就是 console.log 了。 console上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）:   占位符\t作用\r%s\t字符串\r%d or %i\t整数\r%f\t浮点数\r%o\t可展开的DOM\r%O\t列出DOM的属性\r%c\t根据提供的css样式格式化字符串\r实例:\rconsole.log(\u0026amp;quot;%d年%d月%d日\u0026amp;quot;,2011,3,26);\r回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"6d3b06a351288d137a559d1a937574b0","permalink":"https://huachengzhou.github.io/cycle/javadir/tooldoc/js_console%E7%94%A8%E6%B3%95/","publishdate":"2020-01-17T15:26:15Z","title":"常用 Console 调试命令"},{"content":"jsoup学习文档 简介  Jsoup是用于解析HTML，就类似XML解析器用于解析XML。 Jsoup它解析HTML成为真实世界的HTML。 它与jquery选择器的语法非常相似，并且非常灵活容易使用以获得所需的结果\n +jsoup api 6个包提供用于开发jsoup应用程序的类和接口。\norg.jsoup\rorg.jsoup.examples\rorg.jsoup.helper\rorg.jsoup.nodes\rorg.jsoup.parser\rorg.jsoup.safety\rorg.jsoup.salect\r引入 //大多数情况使用jsoup\rorg.jsoup.nodes.Document document = Jsoup.parse(html);\rDocument doc = Jsoup.parse(new URL(\u0026amp;quot;http://www.funi.com/\u0026amp;quot;),7000);\r//少数情况使用httpUnit\rWebClient webClient = new WebClient() ;\rHtmlPage htmlPage = webClient.getPage(\u0026amp;quot;http://www.89ip.cn/\u0026amp;quot;);\rhtmlPage.asXml()//html\r使用(maven) \u0026amp;lt;dependency\u0026amp;gt;\r\u0026amp;lt;!-- jsoup HTML parser library @ http://jsoup.org/ --\u0026amp;gt;\r\u0026amp;lt;groupId\u0026amp;gt;org.jsoup\u0026amp;lt;/groupId\u0026amp;gt;\r\u0026amp;lt;artifactId\u0026amp;gt;jsoup\u0026amp;lt;/artifactId\u0026amp;gt;\r\u0026amp;lt;version\u0026amp;gt;1.10.2\u0026amp;lt;/version\u0026amp;gt;\r\u0026amp;lt;/dependency\u0026amp;gt;\r\u0026amp;lt;!-- httpclient --\u0026amp;gt;\r\u0026amp;lt;dependency\u0026amp;gt;\r\u0026amp;lt;groupId\u0026amp;gt;org.apache.httpcomponents\u0026amp;lt;/groupId\u0026amp;gt;\r\u0026amp;lt;artifactId\u0026amp;gt;httpclient\u0026amp;lt;/artifactId\u0026amp;gt;\r\u0026amp;lt;version\u0026amp;gt;4.5.6\u0026amp;lt;/version\u0026amp;gt;\r\u0026amp;lt;/dependency\u0026amp;gt;\r\u0026amp;lt;dependency\u0026amp;gt;\r\u0026amp;lt;groupId\u0026amp;gt;net.sourceforge.htmlunit\u0026amp;lt;/groupId\u0026amp;gt;\r\u0026amp;lt;artifactId\u0026amp;gt;htmlunit\u0026amp;lt;/artifactId\u0026amp;gt;\r\u0026amp;lt;version\u0026amp;gt;2.26\u0026amp;lt;/version\u0026amp;gt;\r\u0026amp;lt;/dependency\u0026amp;gt;\r解析一个body片断  假如你有一个HTML片断 (比如. 一个 div 包含一对 p 标签; 一个不完整的HTML文档) 想对它进行解析。这个HTML片断可以是用户提交的一条评论或在一个CMS页面中编辑body部分。\n 办法:使用Jsoup.parseBodyFragment(String html) ,Document.body() 方法能够取得文档body元素的所有子元素，与 doc.getElementsByTag(\u0026amp;ldquo;body\u0026amp;rdquo;)相同\nString html = \u0026amp;quot;\u0026amp;lt;div\u0026amp;gt;\u0026amp;lt;p\u0026amp;gt;Lorem ipsum.\u0026amp;lt;/p\u0026amp;gt;\u0026amp;quot;;\rDocument doc = Jsoup.parseBodyFragment(html);\rSystem.out.println(doc.html());//可以看到我们的html片段被包裹了一个body\rElement body = doc.body();\rSystem.out.println(body.html());\r/*\r\u0026amp;lt;html\u0026amp;gt;\r\u0026amp;lt;head\u0026amp;gt;\u0026amp;lt;/head\u0026amp;gt;\r\u0026amp;lt;body\u0026amp;gt;\r\u0026amp;lt;div\u0026amp;gt;\r\u0026amp;lt;p\u0026amp;gt;Lorem ipsum.\u0026amp;lt;/p\u0026amp;gt;\r\u0026amp;lt;/div\u0026amp;gt;\r\u0026amp;lt;/body\u0026amp;gt;\r\u0026amp;lt;/html\u0026amp;gt;\r*/\r/**\r\u0026amp;lt;div\u0026amp;gt;\r\u0026amp;lt;p\u0026amp;gt;Lorem ipsum.\u0026amp;lt;/p\u0026amp;gt;\r\u0026amp;lt;/div\u0026amp;gt;\r*/\r从一个URL加载一个Document  你需要从一个网站获取和解析一个HTML文档，并查找其中的相关数据。你可以使用下面解决方法\n 办法:使用 Jsoup.connect(String url)方法\nDocument doc = Jsoup.parse(new …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"ccd75d93cad076e99c48f971adf8de51","permalink":"https://huachengzhou.github.io/cycle/javadir/tooldoc/jsoup/","publishdate":"2020-01-17T15:26:15Z","title":"jsoup学习文档"},{"content":"spring工具类  Spring-core中提供了大量的工具类，常用的有StringUtils、ObjectUtils、NumberUtils、Base64Utils等，Spring工具类在spring-core.jar中的org.springframework.util包下。\n  1:StringUtils  方法名\t返回值类型\t作用\t备注\risEmpty(Object str)\tboolean\t判断字符串是否为Null或者空字符串\tnull和\u0026#39;\u0026#39;都为true\rhasLength(CharSequence str)\tboolean\t判断字符串长度是否大于1\tnull和\u0026#39;\u0026#39;都为false\rhasText(CharSequence str)\tboolean\t判断字符串中是否有字符\tnull和空字白符都为false\rcontainsWhitespace(CharSequence str)\tboolean\t字符串中是否含有空白字符\ttrimWhitespace(CharSequence str)\tString\t去掉字符串中首尾的空白字符\ttrimAllWhitespace(String str)\tString\t去 掉字符串中所有的空白字符\ttrimLeadingWhitespace(String str)\tString\t去掉字符串左边的空白字符\ttrimTrailingWhitespace(String str)\tString\t去掉字符串右边边的空白字符\tstartsWithIgnoreCase(String str, String prefix)\tString\t判断字符串是否以xx开头，并且忽略大小写\tgetFilename(String path)\tString\t获取文件名\t“mypath/myfile.txt” -\u0026amp;gt; “myfile.txt”\rgetFilenameExtension(String path)\tString\t获取文件扩展名\t“mypath/myfile.txt” -\u0026amp;gt; “txt”\rstripFilenameExtension(String path)\tString\t去掉文件扩展名\t“mypath/myfile.txt” -\u0026amp;gt; “mypath/myfile”\rreplace(String inString, String oldPattern, String newPattern)\tString\t替换字符串\tdelete(String inString, String pattern)\tString\t从给定的字符串中删除所有匹配的字符\tdeleteAny(String inString, String charsToDelete)\tString\t删除所有指定字符\t“az\\n” will delete ‘a’s, ‘z’s and new lines\rSystem.out.println(org.springframework.util.StringUtils.containsWhitespace(\u0026amp;quot;sfas\u0026amp;quot;));//是否有空白 false\rSystem.out.println(org.springframework.util.StringUtils.trimWhitespace(\u0026amp;quot; - dfasd- \u0026amp;quot;));//去除前后空格\rSystem.out.println(org.springframework.util.StringUtils.trimAllWhitespace(\u0026amp;quot; - - - - fshjk s j - -\u0026amp;quot;));//去除所有空格\rSystem.out.println(org.springframework.util.StringUtils.trimLeadingWhitespace(\u0026amp;quot; - - - - fshjk s j - - \u0026amp;quot;));//去除第字符串开头的空格\rSystem.out.println(org.springframework.util.StringUtils.trimTrailingWhitespace(\u0026amp;quot; - - - - fshjk s j - - \u0026amp;quot;));//去除第字符串结尾的空格\rSystem.out.println(org.springframework.util.StringUtils.substringMatch(\u0026amp;quot;f sdfc\u0026amp;quot;,2,\u0026amp;quot;sd\u0026amp;quot;));// …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"84bdb03c20e2587dce169390ab1f1d42","permalink":"https://huachengzhou.github.io/cycle/javadir/tooldoc/spring%E5%B7%A5%E5%85%B7/","publishdate":"2020-01-17T15:26:15Z","title":"spring工具类"},{"content":"spring常用的工具类 内置的resouce类型 UrlResource\rClassPathResource\rFileSystemResource\rServletContextResource\rInputStreamResource\rByteArrayResource\rEncodedResource 也就是Resource加上encoding, 可以认为是有编码的资源\rVfsResource(在jboss里经常用到, 相应还有 工具类 VfsUtils)\rorg.springframework.util.xml.ResourceUtils 用于处理表达资源字符串前缀描述资源的工具. 如: \u0026amp;amp;quot;classpath:\u0026amp;amp;quot;. 有 getURL, getFile, isFileURL, isJarURL, extractJarFileURL 工具类 org.springframework.core.annotation.AnnotationUtils 处理注解\rorg.springframework.core.io.support.PathMatchingResourcePatternResolver 用 于处理 ant 匹配风格(com/*.jsp, com/**/*.jsp),找出所有的资源, 结合上面的resource的概念一起使用,对于遍历文件很有用. 具体请详细查看javadoc\rorg.springframework.core.io.support.PropertiesLoaderUtils 加载Properties资源工具类,和Resource结合\rorg.springframework.core.BridgeMethodResolver 桥接方法分析器. 关于桥接方法请参考: http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.12.4.5\rorg.springframework.core.GenericTypeResolver 范型分析器, 在用于对范型方法, 参数分析.\rorg.springframework.core.NestedExceptionUtils\rxml工具 org.springframework.util.xml.AbstractStaxContentHandler\rorg.springframework.util.xml.AbstractStaxXMLReader\rorg.springframework.util.xml.AbstractXMLReader\rorg.springframework.util.xml.AbstractXMLStreamReader\rorg.springframework.util.xml.DomUtils\rorg.springframework.util.xml.SimpleNamespaceContext\rorg.springframework.util.xml.SimpleSaxErrorHandler\rorg.springframework.util.xml.SimpleTransformErrorListener\rorg.springframework.util.xml.StaxUtils\rorg.springframework.util.xml.TransformerUtils\r其它工具集 org.springframework.util.xml.AntPathMatcherant风格的处理\rorg.springframework.util.xml.AntPathStringMatcher\rorg.springframework.util.xml.Assert断言,在我们的参数判断时应该经常用\rorg.springframework.util.xml.CachingMapDecorator\rorg.springframework.util.xml.ClassUtils用于Class的处理\rorg.springframework.util.xml.CollectionUtils用于处理集合的工具\rorg.springframework.util.xml.CommonsLogWriter\rorg.springframework.util.xml.CompositeIterator\rorg.springframework.util.xml.ConcurrencyThrottleSupport\rorg.springframework.util.xml.CustomizableThreadCreator …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"8969507cf9494db98d4af0a113c115ce","permalink":"https://huachengzhou.github.io/cycle/javadir/tooldoc/spring%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/","publishdate":"2020-01-17T15:26:15Z","title":"spring常用的工具类"},{"content":"现代操作系统  操作系统的基本特征是：\n  1、并发性：  是在计算机系统中同时存在多个程序，宏观上看，这些程序是同时向前推进的。 在单CPU上，这些并发执行的程序是交替在CPU上运行的。\n程序并发性体现在两个方面： 用户程序与用户程序之间的并发执行。 用户程序与操作系统程序之间的并发。\n 2、共享性：  资源共享是操作系统程序和多个用户程序共用系统中的资源。\n 3、 随机性：  随机性指：操作系统的运行是在一个随机的环境中，一个设备可能在任何时间向处理机发出中断请求，系统无法知道运行着的程序会在什么时候做什么事情。\n操作系统分类：  1、批处理操作系统 ：  批处理操作系统的工作方式是：用户将作业交给系统操作员，系统操作员将许多用户的作业组成一批作业，之后输入到计算机中，在系统中形成一个自动转接的连续的作业流，然后启动操作系统，系统自动、依次执行每个作业。最后由操作员将作业结果交给用户。\n批处理操作系统的特点是：多道和成批处理。\n 2、分时操作系统 ：  分时操作系统的工作方式是：一台主机连接了若干个终端，每个终端有一个用户在使用。用户交互式地向系统提出命令请求，系统接受每个用户的命令，采用时间片轮转方式处理服务请求，并通过交互方式在终端上向用户显示结果。\n常见的通用操作系统是分时系统与批处理系统的结合。其原则是：分时优先，批处理后。“前台”响应需频繁交互的作业，如终端的要求； “后台”处理时间性要求不强的作业。\n 3、实时操作系统 ：  实时操作系统是指使计算机能及时响应外部事件的请求在规定的严格时间内完成对该事件的处理，并控制所有实时设备和实时任务协调一致地工作的操作系统。实时操作系统要追求的目标是：对外部请求在严格时间范围内做出反应，有高可靠性和完整性。\n 4、嵌入式操作系统 ：  嵌入式操作系统是运行在嵌入式系统环境中，对整个嵌入式系统以及它所操作、控制的各种部件装置等资源进行统一协调、调度、指挥和控制的系统软件。程，并使整个系统能高效地运行。\n 5、个人计算机操作系统 ：  个人计算机操作系统是一种单用户多任务的操作系统。个人计算机操作系统主要供个人使用，功能强、价格便宜，可以在几乎任何地方安装使用。它能满足一般人操作、学习、游戏等方面的需求。个人计算机操作系统的主要特点是计算机在某一时间内为单个用户服务；采用图形界面人机交互的工作方式，界面友好；使用方便，用户无需专门学习，也能熟练操纵机器。\n 6、网络操作系统 ：  网络操作系统是基于计算机网络的，是在各种计算机操作系统上按网络体系结构协议标准开发的软件，包括网络管理、通信、安全、资源共享和各种网络应用。其目标是相互通信及资源共享。\n 7、分布式操作系统 ：  大量的计算机通过网络被连结在一起，可以获得极高的运算能力及广泛的数据共享。这种系统被称作分布式系统。\n","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"9deddec4184984b88857a3525e71db7c","permalink":"https://huachengzhou.github.io/cycle/operating_system/","publishdate":"2021-04-15T00:00:00Z","title":"操作系统 "},{"content":" Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\n 目录   linux基础命令\n  nginx学习与使用\n  host映射\n  Linux下设置和查看环境变量\n  Ubuntu清理系统垃圾\n  Notepad++安装\n  ubuntu 安装chmsee\n  ubuntu软件卸载\n  Ubuntu 16.04修改hosts\n  git命令\n  git配置\n  回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"2ce8caaaf3db6cf871f4dd0ae3f62eb0","permalink":"https://huachengzhou.github.io/cycle/operating_system/linux/","publishdate":"2021-04-15T00:00:00Z","title":"linux学习与使用 "},{"content":"git学习 git 区域概念  git分为工作区(我们自己的file)和版本库这其中版本库又包含暂存区(Stage)和分支区(master)    git add ********** 把文件添加到仓库\n  git reset README.md 取消提交到暂存区域\n  git commmit -m \u0026amp;lsquo;xxxx\u0026amp;rsquo; 提交到仓库\n  git diff 查看提交到仓库文件之后文件又被修改的变化\n  git status 查看状态\n  git rm -f gitS.md 强制删除\n  git log 显示从最近到最远的提交日志\n  git log \u0026amp;ndash;pretty=oneline 只显示版本号\n  关于版本回退问题   git reset \u0026amp;ndash;hard HEAD^ 版本重置为上一个版本\n  git 关于版本处理进行了设置\n  git reset \u0026amp;ndash;hard HEAD^　重置为上一个版本\n   这里解释下HEAD表示当前版本 如最新提交的版本号:3a451d666e6c952e1588117ef18933be489beb18 zch, 上上一个版本就是HEAD^^ 那么假如是重置为上上一个版本那么命令就是git reset \u0026amp;ndash;hard HEAD^^ 那么假如说有100个版本呢?当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 如:git reset \u0026amp;ndash;hard HEAD~50 往上５０个版本 当然了如果记得具体版本号当然更好了    git reset \u0026amp;ndash;hard 3a451d666e6c952e1588117ef18933be489beb18 这样就可以了,对了这的版本号其实可以不用写全,因为是linux嘛\n  git reflog 记录一天的命令(当天)\n  a249f45 HEAD@{0}: reset: moving to HEAD^\r545bb20 HEAD@{1}: commit: 2018年 03月 12日 星期一 10:17:56\ra249f45 HEAD@{2}: commit: append GPL\r3a451d6 HEAD@{3}: commit (initial): zch\r 你可以发现这里面包含当天所有操作的版本号(因为回退到某个版本之后那个版本号你再用git log就查找不出来了)   git log可以查看提交历史，以便确定要回退到哪个版本 git reflog查看命令历史，以便确定要回到未来的哪个版本。   (假如在工作区的内容已经做了修改与暂存区之间相比有了变化,并且你想要要丢弃这种变化,那么你可以)   git checkout \u0026amp;ndash; gitS.md 抛弃工作区所做的修改　那么工作区就被修改为与暂存区一样了 git checkout \u0026amp;ndash; file命令中的\u0026amp;ndash;很重要，没有\u0026amp;ndash;，就变成了“切换到另一个分支”的命令   关于删除文件\n  假如说你删除了当前工作区的某一个文件比如gitS.md   如进行了这个操作 rm gitS.md(linux 下) 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了(git status) 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令(git rm gitS.md) (git commit -m \u0026amp;lsquo;yes delete file\u0026amp;rsquo;) 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本 命令(git checkout \u0026amp;ndash; gitS.md)\n 分支(重点)  git checkout -b dev (创建dev分支，然后切换到dev分支)  git branch dev 创建分支dev\rgit checkout dev 切换到分支dev\r git branch命令查看当前分支   git branch命令会列出所有分支，当前分支前面会标一个*号\n * dev\rmaster\r 可以随便写点内容然后提交 git commit -m \u0026amp;lsquo;branch test\u0026amp;rsquo; 现在，dev分支的工作完成，我们就可以切换回master分支\n  git checkout master 切换到当前分支 (这时查看gitS.md刚刚随便写的内容并没有在file中)   　我们需要与当前分支合并\n  git merge dev (dev与master合并,master表示主分支)   cat gitS.md 就看到我们添加的内容了\n  再次查看当前分支 git branch …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"a82328117cc3f4d435c37efb6458d863","permalink":"https://huachengzhou.github.io/cycle/operating_system/linux/git_introduction/","publishdate":"2020-01-17T15:26:15Z","title":"git学习"},{"content":"zhou@zhou-Lenovo-Z480:~$ git version\rgit version 2.7.4\rzhou@zhou-Lenovo-Z480:~$ ssh -T git@github.com\rWarning: Permanently added the RSA host key for IP address \u0026#39;192.30.255.112\u0026#39; to the list of known hosts.\rPermission denied (publickey).\rzhou@zhou-Lenovo-Z480:~$ git config --global user.name \u0026amp;quot;zhouchenhua\u0026amp;quot;\rzhou@zhou-Lenovo-Z480:~$ git config --global user.email \u0026amp;quot;noatnu@163.com\u0026amp;quot;\rzhou@zhou-Lenovo-Z480:~$ git config --list\ruser.name=zhouchenhua\ruser.email=noatnu@163.com\rzhou@zhou-Lenovo-Z480:~$ ssh-keygen -C ‘noatnu@163.com’ -t rsa\rGenerating public/private rsa key pair.\rEnter file in which to save the key (/home/zhou/.ssh/id_rsa): america347191\rEnter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in america347191.\rYour public key has been saved in america347191.pub.\rThe key fingerprint is:\rSHA256:7WlMe5QL3eMrdG6b7BB/z66zSpwIOBRM0GTD4hK6BW4 ‘noatnu@163.com’\rThe key\u0026#39;s randomart image is:\r+---[RSA 2048]----+\r| .B* |\r|. . ..+o |\r|.o o .. |\r|.Eo .. . . . o |\r|.o . o S + = o |\r|. . = B.*.. |\r| B.Boo .|\r| . o.o+=.|\r| .=O*+|\r+----[SHA256]-----+\rroot@zhou-Lenovo-Z480:/home/zhou# cd ~/.ssh\rroot@zhou-Lenovo-Z480:~/.ssh# ls -a\r. .. id_rsa id_rsa.pub\rroot@zhou-Lenovo-Z480:~/.ssh# gedit id_rsa.pub 回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"42164c0fae26ad3fa08918dc3d34d1d8","permalink":"https://huachengzhou.github.io/cycle/operating_system/linux/gitub_config/","publishdate":"2020-01-17T15:26:15Z","title":"git配置"},{"content":"sudo vi hosts\n127.0.0.1\tlocalhost 127.0.1.1\tzhou-Lenovo-Z480\nThe following lines are desirable for IPv6 capable hosts ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters\n#pmcc dev 127.0.0.1 dev.pmcc.com\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"0306ac54b1825f940a229d53a581a2cc","permalink":"https://huachengzhou.github.io/cycle/operating_system/linux/host%E6%98%A0%E5%B0%84/","publishdate":"2020-01-17T15:26:15Z","title":"host映射"},{"content":"Linux的变量种类 按变量的生存周期来划分，Linux变量可分为两类： 1 永久的：需要修改配置文件，变量永久生效。 2 临时的：使用export命令声明即可，变量在关闭shell时失效。\n设置变量的三种方法 1 在/etc/profile文件中添加变量【对所有用户生效(永久的)】 用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。 例如：编辑/etc/profile文件，添加CLASSPATH变量\nvi /etc/profile export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib\n注：修改文件后要想马上生效还要运行# source /etc/profile不然只能在下次重进此用户时生效。\n2 在用户目录下的.bash_profile文件中增加变量【对单一用户生效(永久的)】 用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。 例如：编辑guok用户目录(/home/guok)下的.bash_profile $ vi /home/guok/.bash.profile 添加如下内容： export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib 注：修改文件后要想马上生效还要运行$ source /home/guok/.bash_profile不然只能在下次重进此用户时生效。\n3 直接运行export命令定义变量【只对当前shell(BASH)有效(临时的)】 在shell的命令行下直接使用[export 变量名=变量值] 定义变量，\n该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，\nshell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。\n环境变量的查看 1 使用echo命令查看单个环境变量。例如： echo $PATH 2 使用env查看所有环境变量。例如： env 3 使用set查看所有本地定义的环境变量。\n使用unset删除指定的环境变量 set可以设置某个环境变量的值。清除环境变量的值用unset命令。如果未指定值，则该变量值将被设为NULL。示例如下： $ export TEST=\u0026amp;ldquo;Test\u0026amp;hellip;\u0026amp;rdquo; #增加一个环境变量TEST $ env|grep TEST #此命令有输入，证明环境变量TEST已经存在了 TEST=Test\u0026amp;hellip; unset TEST #删除环境变量TEST $ env|grep TEST #此命令没有输出，证明环境变量TEST已经删除\n常用的环境变量 PATH 决定了shell将到哪些目录中寻找命令或程序 HOME 当前用户主目录 HISTSIZE　历史记录数 LOGNAME 当前用户的登录名 HOSTNAME　指主机的名称 SHELL 当前用户Shell类型 LANGUGE 语言相关的环境变量，多语言可以修改此环境变量 MAIL　当前用户的邮件存放目录 PS1　基本提示符，对于root用户是#，对于普通用户是$\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"db81651c278bb23ccf5bcdaf24d87d04","permalink":"https://huachengzhou.github.io/cycle/operating_system/linux/linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","publishdate":"2020-01-17T15:26:15Z","title":"Linux下设置和查看环境变量"},{"content":"linux命令 文件管理 文件基本操作   less命令 (Q退出less命令)([pagedown]： 向下翻动一页)([pageup]： 向上翻动一页) less ss.md\n  cat命令 (cat -n ss.md \u0026amp;gt; sdfsd.txt)把 ss.md 的文档内容加上行号后输入 sdfsd.txt 这个文档里, 这要注意假如sdfsd.txt先有文档会被清空,另外(cat ss.md)可以把消息打印到输出流中,cat 软盘功能暂时不予以考虑\n  ls命令 (ls -a)显示所有文件及目录包括隐藏文件,相当于la命令,ll显示具体信息\n  touch命令 主要用作创建文件如touch ss.md,(touch -m miss,touch -a miss)可以改变文件的读取时间,另外touch miss也可以改变文件的读取时间, 当且仅当miss不存在的时候会创建miss空文件\n  mkdir命令 主要用作创建文件目录;(mkdir dd)创建一个dd目录,(mkdir -p dd/ffg)在当前目录下建立一个dd目录并且在dd下创建一个ffg目录,假如dd不存在会自动创建的\n  mv命令 (mv missA miss.txt)把missA修改为miss.txt (mv sskg /home/zhou/fontconfig/dgsd/sdfg)把sskg移到sdfg目录 (mv ss.md ~)\n  file命令 (file -c ss.md)详细显示指令执行过程(file -v ss.md)显示版本信息 (tar zcvf ss.tar ss.md,file -z ss.tar)尝试去解读压缩文件的内容\n  find命令 (find . -type f)将目前目录其其下子目录中所有一般文件列出(find . -ctime -20)将目前目录及其子目录下所有最近 20 天内更新过的文件列出 (find /home/zhou/fontconfig -name \u0026amp;lsquo;**.md\u0026amp;rsquo;)任意的以md结尾的文件,-name改为-iname会忽略大小写(find /home/zhou/fontconfig -size 0)所有文件长度为0的普通文件\n  split命令 ( split -2 sdfsd.txt) 每隔２行分割成一个文件\u0026amp;ndash;\u0026amp;gt; 分割后:xaa xab xac xad xae xaf xag\n  pwd命令 (pwd)pwd命令用于显示工作目录\n  rm命令 删除操作 (rm xaa)删除单一文件xaa文本文件,这里也是可以用正则的如rm x** ,(rm -r dgsd)递归删除文件目录dgsd下的所有文件包括其本身; (rm -rf baba)加了一个f此命令表示即使原档案属性设为唯读，亦直接删除，无需逐一确认\n  cp命令 复制或者说是拷贝命令 (cp ss.md s1)注意是在同级目录下 (cp /home/zhou/fontconfig/s1/ss.md ~),将ss.md复制到主home下,这的~可以随便换为其它目录 (cp -a s1 /home/zhou/fontconfig/s2,cp -a s1 s2)当cp的是目录时要加上-a参数,当然如果加上-p就更好了,因为-p表示把file拥有的权限也一起复制 如:(cp -ap s1 /home/zhou/fontconfig/s2),(cp -ap ./* /home/zhou/fontconfig/s3)在某个目录把所有内容都复制到s3下\n  chmod 权限命令 Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。\n  u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行\n  (chmod ugo+r miss.txt)将文件miss.txt 设为所有人皆可读取;(chmod u+x ex1.py)将 ex1.py 设定为只有该文件拥有者可以执行;(chmod 777 file)chmod也可以用数字来表示权限如\n  文本操作  假如是ubuntu则可以直接使用gedit (sudo apt-get install gedit) vi命令 切换模式(i：光标处开始插入,l：光标所在行首开始插入,a：光标所在行尾开始插入,o：光标下插入新行) 进入编辑模式,当编辑完成时,在按Esc按键退出编辑模式,保存并退 …","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"1ce2a87f9563b5fa89f75188cf74c580","permalink":"https://huachengzhou.github.io/cycle/operating_system/linux/linux%E5%91%BD%E4%BB%A4/","publishdate":"2020-01-17T15:26:15Z","title":"linux命令"},{"content":"nginx学习 基础操作  start ./sbin/nginx stop ./sbin/nginx -s stop quite ./sbin/nginx -s quit   启动成功标志\n Welcome to nginx!\r 默认监听的端口是80 也就是说访问此端口就可以得到启动成功的标识符号\n  简单的负载均衡配置    http 模块中配置  #配置开始 author zhou\rupstream myproject{\rserver 127.0.0.1:8000 weight=3;\rserver 127.0.0.1:8080 weight=10;\rserver 127.0.0.1:8090;\r}\r#配置结束 author zhou\r location模块配置  proxy_pass http://myproject;\r注意:这的myproject要和上面的name一致\r测试结果 (这的测试用到了session的唯一性)\n http://localhost/nginx_test/ sessionId=8D9C4ACEE65EB24301B1C0D9E4CF3A6E\rhttp://localhost:8080/nginx_test/ sessionId=8D9C4ACEE65EB24301B1C0D9E4CF3A6E\rhttp://localhost:8090/nginx_test/ sessionId=7539B2C4AFD433ECEFAC8F2B2EBCC411\r 由于配置了权重 因此大部分是8080端口\n参数解释   1）down\n表示单前的server暂时不参与负载\n  2）Weight\n默认为1.weight越大，负载的权重就越大。\n  3）max_fails\n允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误\n  4）fail_timeout\nmax_fails 次失败后，暂停的时间。\n  5）Backup\n其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\n  service nginx start\rservice nginx stop\rnginx\r回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"e0e9502834b57bb3b61bb0968f7a1c85","permalink":"https://huachengzhou.github.io/cycle/operating_system/linux/nginx/","publishdate":"2020-01-17T15:26:15Z","title":"nginx学习"},{"content":"Notepad++是一套非常有特色的自由软件的纯文字编辑器(许可证:GPL)。有完整的中文化接口及支持多国语言编写的功能(UTF8 技术)。 它的功能比 Windows 中的 Notepad(记事本)强大，除了可以用来制作一般的纯文字说明文件，也十分适合当作编写电脑程序的编辑器。 Notepad++ 不仅有语法高亮度显示，也有语法折叠功能，并且支持宏以及扩充基本功能的外挂模组。但是可惜的是Notepad++只能在Windows平台下使用。 工作中必须使用Windows时，Notepad++是众多程序员最喜爱的文本编辑器，在Ubuntu下是否能够使用到相同的软件呢？Notepadqq就是这样一款与Notepad++非常接近的编辑器，拥有几乎相同的功能。 如果您是一个Notepad++粉丝，我们推荐您尝试下Notepadqq。\n对于Ubuntu发行版本可以通过PPA安装，命令如下： sudo add-apt-repository ppa:notepadqq-team/notepadqq sudo apt-get update sudo apt-get install notepadqq 类似的，卸载命令如下：\nsudo apt-get remove notepadqq sudo add-apt-repository \u0026amp;ndash;remove ppa:notepadqq-team/notepadqq\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"08ec9fcc2b57b3ee82d51d10c12c2519","permalink":"https://huachengzhou.github.io/cycle/operating_system/linux/notepad++%E5%AE%89%E8%A3%85/","publishdate":"2020-01-17T15:26:15Z","title":"Notepad++ 学习与使用"},{"content":"IntelliJ IDE运行Tomcat报错解决办法的相关资料,出现“Unable to ping server at localhost:1099”错误解决方法，需要的朋友可以参考下\nsudo gedit /etc/hosts\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"12ee000fe94547068a1b6e7e520f45f0","permalink":"https://huachengzhou.github.io/cycle/operating_system/linux/ubuntu16.04%E4%BF%AE%E6%94%B9hosts/","publishdate":"2020-01-17T15:26:15Z","title":"Ubuntu 16.04修改hosts"},{"content":"垃圾的ubuntu 14.04 又一次去掉一些特别好用的软件, 官方给的解释是怕破坏他们系统. 只想说一句 我去年买了个本.\n14.04 之前的版本,如13.10, 12.04 继续能够使用 sudo apt-get install chmsee 来安装.\n14.04 需要下载安装包来安装:\nsudo apt-get install libc6 libchm1 libgcrypt11 libgdk-pixbuf2.0-0 libglib2.0-0 libgtk2.0-0 libpango1.0-0 libwebkitgtk-1.0-0 libxml2 安装依赖包\n(64位) sudo dpkg -i chmsee_1.3.0-2ubuntu2_amd64.deb 安装软件包,下载地址: http://kr.archive.ubuntu.com/ubuntu/pool/universe/c/chmsee/chmsee_1.3.0-2ubuntu2_amd64.deb Ubuntu的官方软件库放心下载.\n(32位) sudo dpkg -i chmsee_1.3.0-2ubuntu2_i386.deb 安装软件包,下载地址: http://kr.archive.ubuntu.com/ubuntu/pool/universe/c/chmsee/chmsee_1.3.0-2ubuntu2_i386.deb Ubuntu的官方软件库放心下载.\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"879e027841bc118680f45ed2ba0bb2ab","permalink":"https://huachengzhou.github.io/cycle/operating_system/linux/ubuntu%E5%AE%89%E8%A3%85chmsee/","publishdate":"2020-01-17T15:26:15Z","title":"ubuntu安装chmsee"},{"content":"1，非常有用的清理命令： sudo apt-get autoclean \u0026amp;ndash;清理旧版本的软件缓存 www.2cto.com\nsudo apt-get clean\u0026amp;ndash;清理所有软件缓存\nsudo apt-get autoremove\u0026amp;ndash;删除系统不再使用的孤立软件\n这三个命令主要清理升级缓存以及无用包的。\n2，清理opera firefox的缓存文件： ls ~/.opera/cache4 ls ~/.mozilla/firefox/*.default/Cache\n3，清理Linux下孤立的包： 图形界面下我们可以用：gtkorphan sudo apt-get install gtkorphan -y 终端命令下我们可以用：deborphan sudo apt-get install deborphan -y\n4，卸载：tracker 这个东西一般我只要安装Ubuntu就会第一删掉tracker 他不仅会产生大量的cache文件而且还会影响开机速度。所以在新得利里面删掉就行。 www.2cto.com\n5，删除多余的内核：一定不要删错哦，切记！！ 打开终端敲命令：dpkg \u0026amp;ndash;get-selections|grep linux 有image的就是内核文件 删除老的内核文件： sudo apt-get remove 内核文件名（例如：linux-image-2.6.27-2-generic） 内核删除，释放空间了，应该能释放130－140M空间。\n最后不要忘了看看当前内核：uname -a 附录： 包管理的临时文件目录: 包在 /var/cache/apt/archives 没有下载完的在 /var/cache/apt/archives/partial\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"89e3fe16f5db679ee9d60265fce1b643","permalink":"https://huachengzhou.github.io/cycle/operating_system/linux/ubuntu%E6%B8%85%E7%90%86%E7%B3%BB%E7%BB%9F%E5%9E%83%E5%9C%BE/","publishdate":"2020-01-17T15:26:15Z","title":"Ubuntu清理系统垃圾"},{"content":"ubuntu软件卸载\n安装Synaptic\nsudo apt-get install synaptic\n回到上一级 ","date":1579274775,"description":"","lastmod":"2020-01-17T15:26:15Z","objectID":"6cfa43f43e38c2167235a7628cafa9b8","permalink":"https://huachengzhou.github.io/cycle/operating_system/linux/ubuntu%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/","publishdate":"2020-01-17T15:26:15Z","title":"ubuntu软件卸载"},{"content":"windows系统  MicrosoftWindows操作系统是美国微软公司研发的一套操作系统，它问世于1985年，起初仅仅是Microsoft-DOS模拟环境，后续的系统版本由于微软不断的更新升级，不但易用，也当前应用最广泛的操作系统。\n Microsoft公司从1983年开始研制Windows系统，最初的研制目标是在MS - DOS的基础上提供一个多任务的图形用户界面。第一个版本的Windows 1.0于1985年问世，它是一个具有图形用户界面的系统软件。1987年推出了Windows 2.0版，最明显的变化是采用了相互叠盖的多窗口界面形式。但这一切都没有引起人们的关注。直到1990年推出Windows 3.0成为一个重要的里程碑，它以压倒性的商业成功确定了Windows系统在PC领域的垄断地位。现今流行的Windows窗口界面的基本形式也是从Windows3.0开始基本确定的。1992年主要针对Windows 3.0的缺点推出了Windows 3.1，为程序开发提供了功能强大的窗口控制能力，使Windows和在其环境下运行的应用程序具有了风格统一、操纵灵活、使用简便的用户界面。Windows3.1在内存管理上也取得了突破性进展。它使应用程序可以超过常规内存空间限制，不仅支持16MB内存寻址，而且在80386及以上的硬件配置上通过虚拟存储方式可以支持几倍于实际物理存储器大小的地址空间。Windows 3.1还提供了一定程度的网络支持、多媒体管理、超文本形式的联机帮助设施等，对应用程序的开发有很大影响。 [3] 众所周知，Windows在个人计算机领域是普及度很高的操作系统。当计算机的体积不断变小，发展成掌上电脑的形态时，Windows系统自然电延伸到这类便携式产品的领域。然而，掌上电脑在续航能力、显示屏幕、输入界面等方面与普通的PC还是有很大差别的，考虑功耗和用户使用习惯等方面的因素，Windows系统针对手持设备的特点进行了多次调整和优化，先后形成了Windows CE，Windows Mobile，Windows Phone等移动版本的系统。 [4] 早期的Windows移动版本系统并未充分考虑智能手机的特点，更多的是从掌上电脑的角度在设计系统。例如，开始菜单虽然在PC上早已为人们所习惯和熟知，但将开始菜单放到手机屏幕上使用时，层层展开的菜单在狭小的屏幕上会让用户很难找到自己所需要的程序。因此，当微软充分认识到移动互联网的发展潜力后，Windows针对智能手机系统的各种设计才逐渐朝着扁平化的风格演变，其中一个特色就是动态磁贴的概念。 [4] 目前，虽然Windows Phone系统凭借Windows系统在桌面计算领域的优势，以及其办公软件Office多年培养起来的庞大用户群体和操作习惯，一直试图在移动计算领域扩大份额。然而，决定一个系统生命力的是应用程序的数量和质量，在这一点上，Windows Phone系统似乎起步太晚了，如何将开发者和用户从已经较为成熟的安卓和iOS系统吸引到这个平台上来是WP面临的最大挑战。 [4] Windows 10 Mobile是微软发发布的一个手机系统 [5] 。\rwindows问题 DOS基础 FTP DOS常用命令(文件) DOS常用命令(网络检测) 回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"4634732fecd5ff3b402fdde1dd6fc2d0","permalink":"https://huachengzhou.github.io/cycle/operating_system/windows/","publishdate":"2021-04-15T00:00:00Z","title":"windows学习与使用 "},{"content":"DOS基本命令  wing+r ==\u0026amp;gt; cmd 进入dos控制台   打开屏幕键盘  C:\\Users\\noatn\u0026amp;gt;osk;\r dos各种操作查看参数用法 command params ==? command /?  C:\\Users\\noatn\u0026amp;gt;cd /?\r显示当前目录名或改变当前目录。\rCHDIR [/D] [drive:][path]\rCHDIR [..]\rCD [/D] [drive:][path]\rCD [..]\r.. 指定要改成父目录。\r键入 CD drive: 显示指定驱动器中的当前目录。\r不带参数只键入 CD，则显示当前驱动器和目录。\r使用 /D 开关，除了改变驱动器的当前目录之外，\r还可改变当前驱动器。\r如果命令扩展被启用，CHDIR 会如下改变:\r当前的目录字符串会被转换成使用磁盘名上的大小写。所以，\r如果磁盘上的大小写如此，CD C:\\TEMP 会将当前目录设为\rC:\\Temp。\rCHDIR 命令不把空格当作分隔符，因此有可能将目录名改为一个\r带有空格但不带有引号的子目录名。例如:\rcd \\winnt\\profiles\\username\\programs\\start menu\r与下列相同:\rcd \u0026amp;quot;\\winnt\\profiles\\username\\programs\\start menu\u0026amp;quot;\r在扩展停用的情况下，你必须键入以上命令。\r  显示文件夹列表 dir\n  改变目录 cd\n  返回上一级目录 cd ..\n  返回根目录 cd \\\n  创建子目录 md\n  删除目录 rd\n  清理屏幕 cls\n  cd s ==\u0026amp;gt; 按住tab键切换\n  DOS窗口中创建用户并设定为管理员  查看本机用户数量 net user  PS E:\\\u0026amp;gt; net user; \\\\DESKTOP-GN2SF7M 的用户帐户\r-------------------------------------------------------------------------------\rAdministrator DefaultAccount Guest\rWDAGUtilityAccount zch\r命令成功完成。\r 创建一个新用户 net user name password /add  PS E:\\\u0026amp;gt; net user blake 123456 /add ; 命令成功完成。\r 提升到管理员权限 net localgroup administrators 用户名 /add  PS E:\\\u0026amp;gt; net localgroup administrators blake /add; 命令成功完成。\rPS E:\\\u0026amp;gt;  删除某个用户名 net user user1 /del  PS E:\\\u0026amp;gt; net user alice /del 命令成功完成。\rPS E:\\\u0026amp;gt;  修改用户密码 net user user1 （直接输入新密码）即可  PS E:\\\u0026amp;gt; net user alice 000000 命令成功完成。\rPS E:\\\u0026amp;gt;  dos备份磁盘   XCOPY D: E:\\backup /s/e/c/h/j/g\rPS E:\\\u0026amp;gt; XCOPY D: E:\\kao /e/h/k/y/c\r回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"b151304c4630340b1d1d2f0abc4a5e5c","permalink":"https://huachengzhou.github.io/cycle/operating_system/windows/dos_basic/","publishdate":"2021-04-15T00:00:00Z","title":"DOS基本命令 "},{"content":"DOS基本文件操作命令   wing+r ==\u0026amp;gt; cmd 进入dos控制台\n  D:\n  进入D盘\r cd命令  CD命令是更改目录命令 如果要进入D盘不用这个命令直接输入 D: 回车 即可\r例如:\rC:\\Users\\HP\u0026amp;gt;D:\rD:\\\u0026amp;gt;\rD:\\\u0026amp;gt;dir\r驱动器 D 中的卷是 新加卷\r卷的序列号是 DAB4-11FE\rD:\\ 的目录\r2019-10-10 14:15 \u0026amp;lt;DIR\u0026amp;gt; 360极速浏览器下载\r2020-01-13 13:47 \u0026amp;lt;DIR\u0026amp;gt; BaiduNetdiskDownload\r2020-01-20 13:59 \u0026amp;lt;DIR\u0026amp;gt; CS\r2019-12-13 16:53 \u0026amp;lt;DIR\u0026amp;gt; data\r2020-02-10 15:55 \u0026amp;lt;DIR\u0026amp;gt; IdeaProjects\r2019-12-06 15:01 \u0026amp;lt;DIR\u0026amp;gt; log\r2019-10-23 10:40 \u0026amp;lt;DIR\u0026amp;gt; MailMasterData\r2019-09-29 10:43 \u0026amp;lt;DIR\u0026amp;gt; output\r2020-01-13 13:40 \u0026amp;lt;DIR\u0026amp;gt; soft\r2020-02-04 17:43 \u0026amp;lt;DIR\u0026amp;gt; temp\r2020-01-15 18:05 \u0026amp;lt;DIR\u0026amp;gt; ultraeditWork\r2019-12-10 09:47 \u0026amp;lt;DIR\u0026amp;gt; workspace\r0 个文件 0 字节\r12 个目录 463,738,040,320 可用字节\rD:\\\u0026amp;gt;cd CS\rD:\\CS\u0026amp;gt; /*进入了CS目录**/\r cd .. (进入当前磁盘的上一级)  \r类似于 linux 下的cd ~\rzch@zch MINGW64 /d/data\r$ cd ~\r已经在某个磁盘下的情况下可以用cd 进入目录\rC:\\Users\\noatn\u0026amp;gt;cd d:\\tencent\rC:\\Users\\noatn\u0026amp;gt;cd C:\\Users\\noatn\\.android\rC:\\Users\\noatn\\.android\u0026amp;gt;\r这里进入d盘失败但是成功进入了C盘预计的目录\r 创建文件 echo \u0026amp;gt;fileName或者 echo [this content] \u0026amp;gt; fileName  \recho \u0026amp;gt;d.txt;\r============\u0026amp;gt;\rE:\\temp\u0026amp;gt;echo \u0026amp;gt;d.txt;\rE:\\temp\u0026amp;gt;dir\r驱动器 E 中的卷是 新加卷\r卷的序列号是 64E8-4ABF\rE:\\temp 的目录\r2020/02/14 18:56 \u0026amp;lt;DIR\u0026amp;gt; .\r2020/02/14 18:56 \u0026amp;lt;DIR\u0026amp;gt; ..\r2020/02/14 18:56 3 d.txt\r1 个文件 3 字节\r2 个目录 264,645,689,344 可用字节\r 查看文件内容 type fileName  E:\\temp\u0026amp;gt;type d.txt\rthis is a text file\r 创建目录 md pathName  E:\\temp\u0026amp;gt;md cc\rE:\\temp\u0026amp;gt;dir\r驱动器 E 中的卷是 新加卷\r卷的序列号是 64E8-4ABF\rE:\\temp 的目录\r2020/02/14 19:02 \u0026amp;lt;DIR\u0026amp;gt; .\r2020/02/14 19:02 \u0026amp;lt;DIR\u0026amp;gt; ..\r2020/02/14 19:02 \u0026amp;lt;DIR\u0026amp;gt; cc\r2020/02/14 18:59 19 d.txt\r1 个文件 19 字节\r3 个目录 264,645,689,344 可用字节\r 复制文件 copy fileName path+fileName  E:\\temp\u0026amp;gt;copy d.txt E:\\temp\\cc;\r已复制 1 个文件。\r 深复制 XCOPY  H:\\\u0026amp;gt;xcopy /?\r复制文件和目录树。\rXCOPY source [destination] [/A | /M] [/D[:date]] [/P] [/S [/E]] [/V] [/W]\r[/C] [/I] [/Q] [/F] [/L] [/G] [/H] [/R] [/T] [/U]\r[/K] [/N] [/O] [/X] [/Y] [/-Y] [/Z] [/B] [/J]\r[/EXCLUDE:file1[+file2][+file3]...]\rsource 指定要复制的文件。\rdestination 指定新文件的位置和/或名称。\r/A 仅复制有存档属性集的文件，\r但不更改属性。\r/M 仅复制有存档属性集的文件，\r并关闭存档属性。\r/D:m-d-y 复制在指定日期或 …","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"96d50fcdec69e9d3cd9c6c8f099c5189","permalink":"https://huachengzhou.github.io/cycle/operating_system/windows/dos_file/","publishdate":"2021-04-15T00:00:00Z","title":"DOS基本文件操作命令 "},{"content":"DOS网络操作命令  netstat -ano (列出所有端口的情况)  PS C:\\Users\\noatn\u0026amp;gt; netstat -ano\r活动连接\r协议 本地地址 外部地址 状态 PID\rTCP 0.0.0.0:135 0.0.0.0:0 LISTENING 1028\rTCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4\rTCP 0.0.0.0:1024 0.0.0.0:0 LISTENING 852\rTCP 0.0.0.0:1025 0.0.0.0:0 LISTENING 2232\rTCP 0.0.0.0:3306 0.0.0.0:0 LISTENING 3672\rTCP 0.0.0.0:5040 0.0.0.0:0 LISTENING 5660\rTCP 0.0.0.0:7680 0.0.0.0:0 LISTENING 6628\rTCP 0.0.0.0:49664 0.0.0.0:0 LISTENING 868\rTCP 0.0.0.0:49665 0.0.0.0:0 LISTENING 784\rTCP 0.0.0.0:49666 0.0.0.0:0 LISTENING 1580\rTCP 0.0.0.0:49667 0.0.0.0:0 LISTENING 1316\rTCP 127.0.0.1:1036 0.0.0.0:0 LISTENING 2536\rTCP 127.0.0.1:1155 127.0.0.1:1156 ESTABLISHED 1204\rTCP 127.0.0.1:1156 127.0.0.1:1155 ESTABLISHED 1204\rTCP 127.0.0.1:1157 127.0.0.1:1158 ESTABLISHED 1204\rTCP 127.0.0.1:1158 127.0.0.1:1157 ESTABLISHED 1204\rTCP 127.0.0.1:6942 0.0.0.0:0 LISTENING 1204\rTCP 127.0.0.1:10000 0.0.0.0:0 LISTENING 3556\rTCP 127.0.0.1:63342 0.0.0.0:0 LISTENING 1204\rTCP 192.168.31.208:139 0.0.0.0:0 LISTENING 4\rTCP 192.168.31.208:3810 104.18.25.243:80 ESTABLISHED 6976\rTCP 192.168.31.208:4258 13.107.3.254:443 ESTABLISHED 6976\rTCP 192.168.31.208:4368 40.90.189.152:443 ESTABLISHED 3700\rTCP 192.168.31.208:4571 111.231.211.246:443 FIN_WAIT_1 9324\rTCP 192.168.31.208:4589 111.12.62.190:443 LAST_ACK 9324\rTCP 192.168.31.208:4593 185.199.108.153:443 FIN_WAIT_1 9324\rTCP 192.168.31.208:4595 112.25.253.5:443 ESTABLISHED 9324\rTCP 192.168.31.208:4596 223.85.58.79:443 CLOSE_WAIT 9324\rTCP 192.168.31.208:4600 223.85.58.79:443 LAST_ACK 9324\rTCP 192.168.31.208:4602 192.144.173.136:7823 ESTABLISHED 9324\rTCP 192.168.31.208:4609 192.30.252.153:80 LAST_ACK 9324\rTCP 192.168.31.208:4610 192.30.252.153:80 LAST_ACK 9324\rTCP 192.168.31.208:4611 192.30.252.153:80 LAST_ACK 9324\rTCP 192.168.31.208:4616 209.197.3.24:443 LAST_ACK 9324\rTCP 192.168.31.208:4617 140.205.33.7:443 TIME_WAIT 0\rTCP [::]:135 [::]:0 LISTENING 1028\rTCP [::]:445 [::]:0 LISTENING 4\rTCP [::]:1024 [::]:0 LISTENING 852\rTCP [::]:1025 [::]:0 LISTENING 2232\rTCP [::]:3306 [::]:0 …","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"a4347cadd4f383757363ed1e2d8c07ab","permalink":"https://huachengzhou.github.io/cycle/operating_system/windows/dos_network/","publishdate":"2021-04-15T00:00:00Z","title":" DOS网络操作命令 "},{"content":"本地设置FTP服务器 步骤1：在计算机上打开“控制面板”，然后单击“程序和功能”。 步骤2：在“程序和功能”窗口中，单击“控制面板”窗口左侧的“打开或关闭Windows功能”。 第3步：现在等待一段时间并向下滚动以找出“Internet信息服务”。 只需展开它，打开“FTP服务器”，“Web管理工具”和“万维网服务”下的所有内容，与下面的屏幕截图相同。 完成所有服务后，单击“确定” 第4步：应用更改需要一些时间，完成后，单击“立即重新启动”以重新启动计算机并应用所做的更改 步骤5：重新启动计算机后，再次打开“控制面板”，然后单击“管理工具”将其打开 步骤7：在IIS管理器窗口的左侧，展开窗口左侧的计算机名称，除非您找到“站点”。 只需右键单击“站点”，然后单击“添加FTP站点\u0026amp;hellip;” 第8步：这里给FTP站点命名。 我将\u0026amp;rsquo;sampleftp\u0026amp;rsquo;赋予FTP站点名称。 现在单击“\u0026amp;hellip;”按钮以找到要通过FTP服务器访问的文件夹或驱动程序。 我为本教程选择了“C：FTP_Path”。 完成所有操作后，单击“下一步” 步骤9：在下一个窗口中，单击与“IP Address：”对应的下拉菜单，然后在本地网络上选择计算机的IP地址。  将端口号保留为“21”，默认情况下是这样。  步骤10：选择“No SSL”并启用“自动启动FTP站点”，然后单击“下一步”。  *由于这是一个教程，我不允许使用SSL。 但是，如果您想通过FTP服务器访问敏感数据，我建议您使用SSL  步骤11：现在选择“基本”的身份验证方法，并向“所有用户”提供“授权”。 用户必须输入您的Windows用户名和密码才能使用此身份验证方法访问FTP服务器上的文件  现在，根据您要如何设置FTP服务器，将权限设置为“读取”和“写入”或仅设置为“读取”。 之后，单击“完成”以完成站点设置并在Windows计算机上启动FTP服务器  配置防火墙  您的FTP服务器已准备就绪并且正在运行 但是，您需要配置Windows防火墙以允许与您的计算机进行FTP通信的事务处理。  步骤12：打开“控制面板”并在Windows 10上单击“Windows Defender Firewall”或在Windows 7上单击“Windows防火墙” 步骤13：单击窗口左侧的“允许通过Windows Defender防火墙的应用程序或功能” 步骤14：在新窗口中，单击“更改设置”并标记“FTP服务器”的“公共”和“私人”对应的复选框，然后单击“确定”。   现在，您可以使用适当的应用程序轻松地从本地网络中的任何其他计算机或移动设备访问FTP服务器，或者只需从浏览器访问即可。\n  步骤15：只需输入\u0026amp;rsquo;ftp：//\u0026#39;，然后输入计算机的IP地址和端口号，即21。对于本教程，我的计算机的IP地址为192.168.1.108。\n  所以完整的地址将是\u0026amp;rsquo;ftp://192.168.1.108:21\u0026#39;\n  步骤16：如果输入的地址正确，将要求您输入Windows计算机的用户名和密码。 最后，点击“确定”或“登录”，以适用于您的方式为准  如果身份验证成功，您将能够看到通过FTP服务器共享的文件夹或驱动器中的内容。    这样，您就可以在本地网络上访问Windows计算机上的文件。\n  通过Internet访问本地FTP服务器\n  通过Internet访问本地或家庭FTP服务器需要在路由器上配置一些设置。因此，该过程可能会根据您使用的路由器的公司和型号而有所不同。不过，我在此基本了解如何配置路由器以通过互联网访问您的FTP服务器。\n  在继续之前，请记下您的Internet服务提供商从以下链接提供给您的外部IP地址。\n  打开路由器配置页面，该页面应为192.168.1.1,192.168.0.1或左右。您可以在配置手册中找到路由器配置页面的地址。\n  对我来说，它是192.168.1.1。只需打开配置页面，然后使用用户名和密码登录即可。\n  然后转到“高级设置”，并在其下选择“NAT”。\n  步骤17：在“Virtual Circuit”中选择“PVC2”，然后单击“Virtual Server”。将“IP数量”设置为“单个”，这应该是默认值。 步骤18：现在点击“应用程序”对应的下拉菜单，然后从菜单中选择“FTP”。 之后将自动应用其他配置。 您甚至会注意到FTP应用程序的端口号也被分配为“21”  现在为我设置本地IP地址，即192.168.1.108。  第19步：完成后，单击“保存”。 第20步：一切准备就绪。 现在输入\u0026amp;rsquo;ftp：//\u0026#39;，后跟前面提到的外部IP地址，以及冒号后的端口号，即21。  所以对我来说地址 …","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"c0e36d33f025ea5cc95fc1bbbc4d3b1e","permalink":"https://huachengzhou.github.io/cycle/operating_system/windows/ftp/","publishdate":"2021-04-15T00:00:00Z","title":" FTP "},{"content":" 磁盘变为了动态磁盘解决办法 最好是找软件解决 如DiskGenius 或者 傲梅分区助手 暴力解决办法  \r1、diskpart\r2、list disk\r3、select disk n\r4、convert basic\rSTEP 1：打开命令提示符窗口，在其中键入：“diskpart”命令并按下回车键。 STEP 2：在DISKPART命令提示符下，键入“list disk”命令并按下回车键后，能够查看到电脑中的磁盘情况。 STEP 3：在DISKPART命令提示符下，继续键入“select disk n”命令并按下回车键，其中n代表磁盘的序号。 STEP 4：在DISKPART命令提示符下，键入“convert dynamic”命令并按下回车键后，开始转换的工作。\r回到上一级 ","date":1618444800,"description":"","lastmod":"2021-04-15T00:00:00Z","objectID":"1d1ceed28f4af82ffd30170ee82c7af7","permalink":"https://huachengzhou.github.io/cycle/operating_system/windows/windows_question/","publishdate":"2021-04-15T00:00:00Z","title":" windows 问题 "},{"content":"自己整理的日常开发参考网址    在线工具 链接     web工具 web工具   在线超级转换工具 在线超级转换工具   程序员在线工具 在线超级转换工具   图片转base64工具 图片转base64工具       算法 链接     算法网址 leetcode 国内 算法网址 leetcode 国内   算法网址 牛课网 国内 算法网址 牛课网 国内   算法网址 codility 国外 算法网址 codility 国外       bootstrap 链接     bootstrap 重要参考例子 bootstrap 重要参考例子   bootstrap table api(csdn) bootstrap table api(csdn)   bootstrap table api(官方) bootstrap table api(官方)       图标 链接     阿里巴巴icon 阿里巴巴icon   easy icon easy icon        Java学习 链接     ibm java example ibm java example   Java并发参考 Java并发参考   csdn csdn   Java分享网 Java分享网   java fx api java fx api       教程 链接     www.w3cschoo 国内 www.w3cschoo 国内   www.w3cschoo 国外 www.w3cschoo 国外   菜鸟教程 菜鸟教程   nginx api nginx api   vue 学习 vue 学习   幕课网 幕课网   我要自学网 我要自学网       网站 链接     站长之家 站长之家   脚本之家 脚本之家   源码之家 源码之家       考试网 链接     中国人事考试网 中国人事考试网   计算机技术与软件专业技术资格 计算机技术与软件专业技术资格   中国计算机职业资格网 中国计算机职业资格网       例子 链接     淘宝如何处理分布式请求的 博客网 淘宝如何处理分布式请求的 博客网   [淘宝如何处理分布式请求的 微信公众号 [淘宝如何处理分布式请求的 微信公众号   Java程序员必学知识点整理 Java程序员必学知识点整理   程序员必须掌握哪些算法？ 程序员必须掌握哪些算法？   12个模块 150 道 java 必考面试题 12个模块 150 道 java 必考面试题   优化代码中大量的if/else，你有什么方案? 优化代码中大量的if/else，你有什么方案?   短时间如何过java面试？ 短时间如何过java面试？   如何学习Java的NIO？ 如何学习Java的NIO？   16个小众却很实用的网站（程序员方向） 16个小众却很实用的网站（程序员方向）   如何判断 Java 工程师的基础知识是否扎实？ 如何判断 Java 工程师的基础知识是否扎实？   JAVA的多态用几句话能直观的解释一下吗？ JAVA的多态用几句话能直观的解释一下吗？    计算机在职研究生招生学校    学校 层次     西南交通大学 211   中国人民大学 教育部直属   自考参考网站 教育部直属    收集的杂七杂八得网址    学校     Java程序员掉发系列——程序员的成长之路   史上最全的程序员常用英语词汇   Java程序员掉发系列——程序员必须认识的英文单词（汇总）   每个程序员必须掌握的常用英语词汇   程序员必知1700英语单词   这70个Java必背英语单词不会，就别说你是Java程序员！   java代理机制   国内有哪些质量高的JAVA社区？   hutool-all 介绍 ==\u0026amp;gt; Hutool是一个小而全的Java工具类库   GitHub Pages 绑定来自阿里云的域名   Spring Boot 学习    面试背题网站    名称 链接     javaguide javaguide   pdai.tech pdai.tech    面试网 面试网    1-3年应该掌握的知识与技能 1：基本语法 这包括static、final、transient等关键字的作用，foreach循环的原理等等。今天面试我问你static关键字有哪些作用，如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满意，因为能看出你非常热衷研究技术。\n2、集合 非常重要，也是必问的内容。基本上就是List、Map、Set，问的是各种实现类的底层实现原理，实现类的优缺点。\n集合要掌握的 …","date":1554163200,"description":"经验,规律,总结,宁静","lastmod":"2019-04-02T00:00:00Z","objectID":"588dd4868be77ba7452cb18b95e1878f","permalink":"https://huachengzhou.github.io/cycle/post/website/","publishdate":"2019-04-02T00:00:00Z","title":"网站链接"},{"categories":["Development","golang"],"content":"一、 编译程序   1、 编译器是一种翻译程序，它用于将源语言（即用某种程序设计语言写成的）程序翻译为目标语言（即用二进制数表示的伪机器代码写成的）程序。后者在windows操作系统平台下，其文件的扩展名通常为.obj。该文件通常还要经过进一步的连接，生成可执行文件（机器代码写成的程序，文件扩展名为.exe）。通常有两种方式进行这种翻译，一种是编译，另一种是解释。后者并不生成可执行文件，只是翻译一条语句、执行一条语句。这两种方式相编译比解释运行的速度要快得多。\n  2、 编译过程的5个阶段：词法分析；语法分析；语义分析与中间代码产生；优化；目标代码生成。\n  3、 在这五个阶段中，词法分析的任务是识别源程序中的单词是否有误，编译程序中实现这种功能的部分一般称为词法分析器。在编译器中，词法分析器通常仅作为语法分析程序的一个子程序以便在它需要单词符号时调用。在这一编译阶段中发现的源程序错误，称为词法错误。\n  4、 语法分析阶段的目的是识别出源程序的语法结构（即语句或句子）是否错误，所以有时又常为句子分析。编译程序中负责这一功能的程序称为语法分析器或语法分析程序。在这一阶段中发现的错误称为语法错误。\n  5、 C语言的（源）程序必须经过编译才能生成目标代码，再经过链接才能运行。PASCAL语言、FORTRAN语言的源程序也要经过这样的过程。通常将C、PASCAL、FORTRAN这样的语言统称为高级语言。而将最终的可执行程序称为机器语言程序。\n  6、 在编译C语言程序的过程中，发现源程序中的一个标识符过长，超过了编译程序允许的范围，这个错误应在词法分析阶段发现，这种错误通常被称作词法错误。\n 词法分析器的任务是以词法规则为依据对输入的源程序进行单词及其属性的识别，识别出一个个单词符号。\n 词法分析的输入是源程序，输出是一个个单词的特殊符号，称为Token（标记或符号）。\n 语法分析器的类型有:自下而上、自上而下。常用的语法分析器有：递归下降分析方法是一种自上而下分析方法, 算符优先分析法属于自下而上分析方法，LR分析法属于自下而上分析方法等等。\n 通常用正规文法或正规式来描述程序设计语言的词法规则，而使用上下文无关文法来描述程序设计语言的语法规则。\n 语法分析阶段中，处理的输入数据是来自词法分析阶段的单词符号。它们是词法分析阶段的终结符。\n  7、 编译程序总框\n  8、 在计算机发展的早期阶段，内存较小的不能一次完成程序的编译。这时通常将编译过程分成若干遍来完成。每一遍完成一部分功能，称为多遍编译。 与采用高级程序设计语言写的词法分析器相比，用汇编语言写的词法分析通常分析速度要快些。\n  二. 词法与语法   1、 程序语言主要由语法和语义两个方面来定义。\n  2、 任何语言的程序都可看成是某字符集上的一个长字符串。\n  3、 语言的语法：是指这样的一组规则（即产生式），用它可以生成和产生一个良定的程序。这些规则的一部分称为词法规则，另一部分称为语法规则。\n  4、 词法规则：单词符号的形成规则；语法规则：语法单位（句子）的形成规则。语义规则：定义程序句子的意义。\n  5、 一个程序语言的基本功能是描述数据和对数据的运算。\n  6、 高级语言的分类：强制式语言；应用式语言；基于规则的语言；面向对象的语言。\n  7、 一个语言的字母表为{a,b}，则字符串ab的前缀有a、ε，其中ε不是真前缀。\n  8、 字符串的连接运算一般不满足交换率。\n  9、 文法G是一个四元组，或者说由四个元素构成，即非终结符集合VN、非终结符号集合VT 、开始符号S、产生式集合P，它可以形式化地表示成G =（VN，VT，S，P）。 按照文法的定义，这4个元素中终结符号集合是这个文法所规定的语言的字母表，产生式集合代表文法所规定的语言语法实体的集合。对上下文无关文法，通常我们只需要写出这个文法的产生式集合就可以确定这个文法的其他所有元素。其中，第一条产生式的左部符号为开始符号，而所有产生式的左部符号构成的集合就是该文法的非终结符集合。\n   文法的例子： 设文法G=（VN，VT， S，P），其中P为产生式集合，它的每个元素的形式为产生式。\n  10、如果文法G的一个句子存在两棵不同的最左语法分析树，则这个文法是无二义的。\n  11、如果文法G的一个句子存在两棵不同的最右语法分析树，则这个文法是无二义的。\n  12、如果文法G的一个句子存在两棵不同的语法分析树，则这个文法是无法判断是否是二义的。\n  13、A为非终结符，如果文法存在产生式 ，则称 可以推导出 ；反之，称 可归约为 。\n  14、乔姆斯基（Chomsky）将文法分为四类，即0型文法、1文法、2文法、3文法。 按照乔姆斯基对方法的分类，上下文无关文法是2型文法，2型文法的描述能力最 …","date":1396396800,"description":"","lastmod":"2014-04-02T00:00:00Z","objectID":"804ccadd98489d5ab35b54ff21dd5313","permalink":"https://huachengzhou.github.io/cycle/post/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","publishdate":"2014-04-02T00:00:00Z","tags":["go","golang","hugo","development"],"title":"编译原理"},{"categories":["Development","golang"],"content":"一、计算机的组成及学习大纲 1. 计算机的组成 计算机的三大件 ：CPU、内存、主板 （1）CPU，中央处理器，计算机最核心的配件，负责所有的计算。\n（2）内存，你编写的程序、运行的游戏、打开的浏览器都要加载到内存中才能运行，程序读取的数据、计算的结果也都在内存中，内存的大小决定了你能加载的东西的多少。\n（3）主板，存放在内存中数据需要被CPU读取，CPU计算完成后，还要把数据写入到内存中，然而CPU不能直接插在内存上，这就需要主板出马了，主板上很多个插槽，CPU和内存都是插在主板上，主板的芯片组和总线解决了CPU和内存之间的通讯问题，芯片组控制数据传输的流转，决定数据从哪里流向哪里，总线是实际数据传输的告诉公里，总线速度决定了数据的传输速度。\n（4）输入/输出设备，其实有了以上三大件之后，计算机就可以跑起来了。我们日常使用的话还需要键盘、鼠标、显示器等输入/输出设备，而很多云服务器通过SSH远程登录就可以访问，就不需要配显示器、鼠标、键盘这些东西，节省成本且方便维护。\n（5）硬盘，有了硬盘数据才能长久的保存下来，大部分还会给自己的机器配上机箱和风扇，解决灰尘和散热问题，不过这些也不是必须的，用纸板和电风扇替代也一样可以用。\n（6）显卡，显卡里有GPU图形处理器，主要负责图形渲染，使用图形界面操作系统的计算机，显卡是必不可少的。现在的主板都带了内置的显卡，如果想玩游戏、做图形渲染，一般需要一张单独的显卡，插在主板上。\n2. 冯·诺依曼体系 现代计算机的硬件基础架构都是依赖于冯诺依曼提出的冯诺依曼体系结构，现代计算机的核心架构可以抽象为五个基础组件：运算器、控制器、存储器、输入设备和输出设备。\n具体到现代计算机，运算器和控制器组成了现代计算机的CPU，存储器对应着内存和硬盘，主板控制着CPU、内存、硬盘、输出/输出设备之间的通讯。\n冯诺依曼体系结构也叫做存储程序计算机，即可编程、可存储的计算机。\n任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的。\n冯诺依曼体系结构确立了我们现代计算机的硬件基础架构，学习计算机组成原理，就是学习和拆解冯诺依曼体系。\n学习组成原理，就是学习以下内容：\n CPU（运算器+控制器）怎么工作，为什么这么设计； 内存和硬盘的工作原理； CPU是怎么和内存、硬盘、输入设备、输出设备通讯的； 从电路这样的硬件到最终开发给软件的接口是怎么运作的，为什么要这么设计，以及在软件开发层面怎么尽可能的用好它；  3. 计算机组成原理学习大纲 计算机组成原理知识地图\n学习大纲：  计算机的基本组成：冯诺依曼体系结构的五大基本组件：运算器、控制器、存储器、输入设备和输出设备；计算机的两个核心指标：性能和功耗。 计算机的指令和计算：高级语言是怎么跑起来的，怎么通过编译器和汇编器变成机器指令的；操作系统怎么链接、装载、执行程序的；指令的执行是怎么控制的（控制器）。 运算器，数据在计算机中的表示（二进制和编码）；计算机是怎么实现加法、乘法等基本运算功能的。 CPU的设计：我们为什么需要CPU时钟；寄存器和内存怎么组成的；整个计算机的数据通路是如何构造的；CPU的流水线设计；数据和控制冒险；分支预测；CPU的异常和中断机制；指令的并行执行；CPU怎么通过SIMD来支持并行计算。 存储器的原理：CPU高速缓存、内存、SSD硬盘和机械硬盘的工作原理，及它们之间的性能差异；CPU和存储器之间怎么通讯的；什么是IO_WAIT；如何通过DMA提升程序性能；如何保证存储器里的数据不丢失；如何通过RAID、Erasure Code、ECC、HDFS，这些不同的技术来确保数据的完整性和访问性能。  总结：计算机组成原理是整个计算机科学的纲要，这门课程的很多知识点深挖下去都会变成一个核心课程。\n例如：\n 计算是怎么实现的，对应着数字电路课程。 CPU和存储器系统的优化，对应着计算机体系结构课程。 程序通过编译器和汇编器变成机器指令的编译过程，对应着编译原理课程。 操作系统是怎么链接、装载、执行程序的，对应着操作系统课程。  二、下面我们根据课程大纲，大致过一遍组成原理 1. 性能 衡量计算机的性能，主要有两个指标：响应时间和吞吐率。\n 响应时间，就是执行一个程序花费的时间，花的时间越短，性能就越好。 吞吐率，就是一定时间内，到底能处理多少数据和指令，处理的越多，性能就越好。  我们一般把性能定义为响应时间的倒数，也就是：性能 = 1 / 响应时间\n响应时间也就是CPU执行我们程序的时间，我们对时间这个指标进行拆解，把程序的CPU执行时间变成CPU时钟周期数和时钟周期时间的乘积。\n程序的CPU执行时间 = CPU时钟周期数 x 时钟周期时间\n程序的CPU执行时间 = …","date":1396396800,"description":"","lastmod":"2014-04-02T00:00:00Z","objectID":"c2e7dfeab5fdbf6988b3b3921a6b32ea","permalink":"https://huachengzhou.github.io/cycle/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","publishdate":"2014-04-02T00:00:00Z","tags":["go","golang","templates","themes","development"],"title":"计算机组成原理"},{"content":" dos,lua,sheel,python,js\n   dos 可以使用VisualBat编辑器编写以及调试\n  lua 可以运行在redis ,dos,Java,c++等里面另外还可以用来写触屏精灵 http://www.touchsprite.com/docs/5362 ==\u0026amp;gt; https://www.zybuluo.com/miniknife/note/317045#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\n  sheel脚本 运行在linux或者unix上相当于windows上的dos\n  python 胶水语言 可以直接在linux当成sheel使用,也是人工智能的一种使用工具\n   js 浏览器脚本  ","date":1508253975,"description":"","lastmod":"2017-10-17T15:26:15Z","objectID":"644b8093b79ae2990e7f40fda0864d85","permalink":"https://huachengzhou.github.io/cycle/%E8%84%9A%E6%9C%AC/","publishdate":"2017-10-17T15:26:15Z","title":"脚本"},{"content":"目录  ECMAScript 6  ","date":1623715200,"description":"","lastmod":"2021-06-15T00:00:00Z","objectID":"186e7c3a34df01c8ff6b753c6a7a503f","permalink":"https://huachengzhou.github.io/cycle/%E8%84%9A%E6%9C%AC/javascript/","publishdate":"2021-06-15T00:00:00Z","title":"javascript "},{"content":" ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。  Module 的语法 概述 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\nES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\n// CommonJS模块\rlet { stat, exists, readFile } = require(\u0026#39;fs\u0026#39;);\r// 等同于\rlet _fs = require(\u0026#39;fs\u0026#39;);\rlet stat = _fs.stat;\rlet exists = _fs.exists;\rlet readfile = _fs.readfile;\r上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。\nES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。\n// ES6模块\rimport { stat, exists, readFile } from \u0026#39;fs\u0026#39;;\r 严格模式  ES6 的模块自动采用严格模式，不管你有没有在模块头部加上\u0026amp;quot;use strict\u0026amp;quot;;。\n export 命令  模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。\n// profile.js\rexport var firstName = \u0026#39;Michael\u0026#39;;\rexport var lastName = \u0026#39;Jackson\u0026#39;;\rexport var year = 1958;\r上面代码是profile.js文件，保存了用户信息。ES6 将其视为一个模块，里面用export命令对外部输出了三个变量。\nexport的写法，除了像上面这样，还有另外一种。\n/ profile.js\rvar firstName = \u0026#39;Michael\u0026#39;;\rvar lastName = \u0026#39;Jackson\u0026#39;;\rvar year = 1958;\rexport {firstName, lastName, year}; //优秀导出写法\r上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。\nexport命令除了输出变量，还可以输出函数或类（class）。\nexport function multiply(x, y) {\rreturn x * y;\r};\r上面代码对外输出一个函数multiply。\n通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。\nfunction v1() { ... }\rfunction v2() { ... }\rexport {\rv1 as streamV1,\rv2 as streamV2,\rv2 as streamLatestVersion\r};\r需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。\n// 报错\rexport 1;\r// 报错\rvar m = 1;\rexport m;\r上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量m，还是直接输 …","date":1623888000,"description":"","lastmod":"2021-06-17T00:00:00Z","objectID":"bc6e017081258adbe16f9b8fd96dd09b","permalink":"https://huachengzhou.github.io/cycle/%E8%84%9A%E6%9C%AC/javascript/es6/","publishdate":"2021-06-17T00:00:00Z","title":"ECMAScript 6"},{"content":"node js  Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时\n Linux 上安装 Node.js  直接使用已编译好的包 Node 官网已经把 linux 下载版本更改为已编译好的版本了，我们可以直接下载解压后使用：  # wget https://nodejs.org/dist/v10.9.0/node-v10.9.0-linux-x64.tar.xz // 下载 # tar xf node-v10.9.0-linux-x64.tar.xz // 解压 # cd node-v10.9.0-linux-x64/ // 进入解压目录 # ./bin/node -v // 执行node命令 查看版本 v10.9.0  解压文件的 bin 目录底下包含了 node、npm 等命令，我们可以使用 ln 命令来设置软连接：  ln -s /usr/software/nodejs/bin/npm /usr/local/bin/ ln -s /usr/software/nodejs/bin/node /usr/local/bin/  Ubuntu 源码安装 Node.js   以下部分我们将介绍在 Ubuntu Linux 下使用源码安装 Node.js 。 其他的 Linux 系统，如 Centos 等类似如下安装步骤。\n  在 Github 上获取 Node.js 源码：  $ sudo git clone https://github.com/nodejs/node.git\rCloning into \u0026#39;node\u0026#39;...\r 修改目录权限：  $ sudo chmod -R 755 node  使用 ./configure 创建编译文件，并按照：  $ cd node $ sudo ./configure $ sudo make $ sudo make install 查看 node 版本：\n$ node --version v0.10.25  Ubuntu apt-get命令安装 命令格式如下：  sudo apt-get install nodejs sudo apt-get install npm  CentOS 下源码安装 Node.js   1、下载源码，你需要在https://nodejs.org/en/download/下载最新的Nodejs版本，本文以v0.10.24为例:\n cd /usr/local/src/ wget http://nodejs.org/dist/v0.10.24/node-v0.10.24.tar.gz  2、解压源码\n tar zxvf node-v0.10.24.tar.gz  3、 编译安装\n cd node-v0.10.24 ./configure --prefix=/usr/local/node/0.10.24 make make install  4、 配置NODE_HOME，进入profile编辑环境变量\n vim /etc/profile  设置 nodejs 环境变量，在 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容:  #set for nodejs export NODE_HOME=/usr/local/node/0.10.24 export PATH=$NODE_HOME/bin:$PATH  :wq保存并退出，编译/etc/profile 使配置生效  source /etc/profile  验证是否安装配置成功  node -v 输出 v0.10.24 表示配置成功  npm模块安装路径  /usr/local/node/0.10.24/lib/node_modules/ windows 上安装 Node.js   地址\n  选择zip格式 如图所示\n   解压zip格式 如图所示   配置环境变量 如图所示   检验安装  Microsoft Windows [版本 10.0.19043.1052]\r(c) Microsoft Corporation。保留所有权利。\rC:\\Users\\dell\u0026amp;gt;node -v\rv14.17.2\rC:\\Users\\dell\u0026amp;gt;npm -v\r6.14.13\rC:\\Users\\dell\u0026amp;gt;npm root -g\rD:\\CS\\node\\node-v14.17.2-win-x64\\node_modules\rC:\\Users\\dell\u0026amp;gt;\rwindows 下 修改全局依赖包下载路径  默认情况下，我们在执行npm install -g XXXX下载全局包时，这个包的默认存放路径 …","date":1623888000,"description":"","lastmod":"2021-06-17T00:00:00Z","objectID":"acc7c5dedde5127c0403a63530b84beb","permalink":"https://huachengzhou.github.io/cycle/%E8%84%9A%E6%9C%AC/nodejs/","publishdate":"2021-06-17T00:00:00Z","title":"node js "},{"content":" npm 是 Node 的模块管理器，功能极其强大。它是 Node 获得成功的重要原因之一\n  假如是nodejs 高版本 那么不需要再安装npm了因为node js已经包含了npm  一、从 npm install 说起  npm install 命令用来安装模块到node_modules目录。  $ npm install \u0026amp;lt;packageName\u0026amp;gt;   安装之前，npm install会先检查，node_modules目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。\n  如果你希望，一个模块不管是否安装过，npm 都要强制重新安装，可以使用-f 或 \u0026amp;ndash;force 参数。\n  $ npm install \u0026amp;lt;packageName\u0026amp;gt; --force 二、npm update  如果想更新已安装模块，就要用到npm update命令。  $ npm update \u0026amp;lt;packageName\u0026amp;gt;  它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。  三、registry   npm update命令怎么知道每个模块的最新版本呢？\n  答案是 npm 模块仓库提供了一个查询服务，叫做 registry 。以 npmjs.org 为例，它的查询服务网址是 https://registry.npmjs.org/ 。\n  这个网址后面跟上模块名，就会得到一个 JSON 对象，里面是该模块所有版本的信息。比如，访问 https://registry.npmjs.org/react，就会看到 react 模块所有版本的信息。\n  它跟下面命令的效果是一样的。\n  $ npm view react # npm view 的别名 $ npm info react $ npm show react $ npm v react 四、缓存目录   npm install或npm update命令，从 registry 下载压缩包之后，都存放在本地的缓存目录。\n  这个缓存目录，在 Linux 或 Mac 默认是用户主目录下的.npm目录，在 Windows 默认是%AppData%/npm-cache。通过配置命令，可以查看这个目录的具体位置。\n  $ npm config get cache $HOME/.npm  你最好浏览一下这个目录。  $ ls ~/.npm # 或者 $ npm cache ls  你会看到里面存放着大量的模块，储存结构是{cache}/{name}/{version}。  $ npm cache ls react ~/.npm/react/react/0.14.6/ ~/.npm/react/react/0.14.6/package.tgz ~/.npm/react/react/0.14.6/package/ ~/.npm/react/react/0.14.6/package/package.json  .npm目录保存着大量文件，清空它的命令如下。  $ rm -rf ~/.npm/* # 或者 $ npm cache clean 五、模块的安装过程  总结一下，Node模块的安装过程是这样的。  1:发出npm install命令\r2:npm 向 registry 查询模块压缩包的网址\r3:下载压缩包，存放在~/.npm目录\r4:解压压缩包到当前项目的node_modules目录\r 注意，一个模块安装以后，本地其实保存了两份。一份是~/.npm目录下的压缩包，另一份是node_modules目录下解压后的代码。 但是，运行npm install的时候，只会检查node_modules目录，而不会检查~/.npm目录。也就是说，如果一个模块在～/.npm下有压缩包，但是没有安装在node_modules目录中，npm 依然会从远程仓库下载一次新的压缩包。 这种行为固然可以保证总是取得最新的代码，但有时并不是我们想要的。最大的问题是，它会极大地影响安装速度。即使某个模块的压缩包就在缓存目录中，也要去远程仓库下载，这怎么可能不慢呢？ 另外，有些场合没有网络（比如飞机上），但是你想安装的模块，明明就在缓存目录之中，这时也无法安装。\n ","date":1623888000,"description":"","lastmod":"2021-06-17T00:00:00Z","objectID":"7b467046b74c0f3cf12e953ad62c69b0","permalink":"https://huachengzhou.github.io/cycle/%E8%84%9A%E6%9C%AC/npm%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B/","publishdate":"2021-06-17T00:00:00Z","title":"node js - npm "},{"content":"webpack 一:卸载  全局卸载  D:\\IdeaProjects\\cycle\\docs\\webc\\web\\webpack-study\\one\u0026amp;gt;npm uninstall webpack webpack-cli -g removed 73 packages in 0.726s  本地卸载  D:\\IdeaProjects\\cycle\\docs\\webc\\web\\webpack-study\\one\u0026amp;gt;npm uninstall webpack webpack-cli -D npm WARN saveError ENOENT: no such file or directory, open \u0026amp;#39;D:\\IdeaProjects\\package.json\u0026amp;#39; npm WARN enoent ENOENT: no such file or directory, open \u0026amp;#39;D:\\IdeaProjects\\package.json\u0026amp;#39; npm WARN IdeaProjects No description npm WARN IdeaProjects No repository field. npm WARN IdeaProjects No README data npm WARN IdeaProjects No license field. up to date in 0.791s 16 packages are looking for funding run `npm fund` for details D:\\IdeaProjects\\cycle\\docs\\webc\\web\\webpack-study\\one\u0026amp;gt; 二:安装  1:webpack依赖node环境。 2:node环境依赖众多包，所以需要npm，npm（node packages manager）node包管理工具 3:nvm是node管理工具可以自由切换node环境版本   在终端执行webpack命令，使用的是全局安装(在某个地方看到)\n  1: 全局安装webpack simple (低版本)  npm install webpack -g //指定版本安装 npm install webpack@3.6.0 -g  2: 全局安装webpack (高版本)  npm install webpack webpack-cli -g //或指定版本，类似这样： npm install webpack@4.16.5 webpack-cli -g  3:本地安装 ?  npm install webpack webpack-cli --save-dev //或者 npm install webpack webpack-cli -D //或者指定版本 npm install webpack@4.16.5 webpack-cli -D 三:使用   1:简单使用\n  1、初始化\n  D:\\IdeaProjects\\cycle\\docs\\webc\\web\\webpack-study\\one\u0026amp;gt;npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. See `npm help init` for definitive documentation on these fields and exactly what they do. Use `npm install \u0026amp;lt;pkg\u0026amp;gt;` afterwards to install a package and save it as a dependency in the package.json file. Press ^C at any time to quit. package name: (one) version: (1.0.0) description: entry point: (index.js) test command: git repository: keywords: author: license: (ISC) About to write to D:\\IdeaProjects\\cycle\\docs\\webc\\web\\webpack-study\\one\\package.json: { \u0026amp;#34;name\u0026amp;#34;: \u0026amp;#34;one\u0026amp;#34;, \u0026amp;#34;version\u0026amp;#34;: \u0026amp;#34;1.0.0\u0026amp;#34;, …","date":1623888000,"description":"","lastmod":"2021-06-17T00:00:00Z","objectID":"f7ff6ae2d048c0b1184c4e690899109e","permalink":"https://huachengzhou.github.io/cycle/%E8%84%9A%E6%9C%AC/simple-webpack/","publishdate":"2021-06-17T00:00:00Z","title":"webpack simple"},{"content":"uni-app的基本使用 课程介绍：\n基础部分：\n 环境搭建 页面外观配置 数据绑定 uni-app的生命周期 组件的使用 uni-app中样式学习 在uni-app中使用字体图标和开启scss 条件注释跨端兼容 uni中的事件 导航跳转 组件创建和通讯，及组件的生命周期 uni-app中使用uni-ui库  项目：黑马商城项目\nuni-app介绍 官方网页 uni-app view uni-app view uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。\n即使不跨端，uni-app同时也是更好的小程序开发框架。\n具有vue和微信小程序的开发经验，可快速上手uni-app\n为什么要去学习uni-app？\n相对开发者来说，减少了学习成本，因为只学会uni-app之后，即可开发出iOS、Android、H5、以及各种小程序的应用，不需要再去学习开发其他应用的框架，相对公司而言，也大大减少了开发成本。\n环境搭建 安装编辑器HbuilderX 下载地址\nHBuilderX是通用的前端开发工具，但为uni-app做了特别强化。\n下载App开发版，可开箱即用\n安装微信开发者工具 下载地址\n利用HbuilderX初始化项目   点击HbuilderX菜单栏文件\u0026amp;gt;项目\u0026amp;gt;新建\n  选择uni-app,填写项目名称，项目创建的目录\n  运行项目 在菜单栏中点击运行，运行到浏览器，选择浏览器即可运行\n在微信开发者工具里运行：进入hello-uniapp项目，点击工具栏的运行 -\u0026amp;gt; 运行到小程序模拟器 -\u0026amp;gt; 微信开发者工具，即可在微信开发者工具里面体验uni-app\n在微信开发者工具里运行：进入hello-uniapp项目，点击工具栏的运行 -\u0026amp;gt; 运行到手机或模拟器 -\u0026amp;gt; 选择调式的手机\n注意：\n 如果是第一次使用，需要先配置小程序ide的相关路径，才能运行成功 微信开发者工具在设置中安全设置，服务端口开启  介绍项目目录和文件作用 pages.json 文件用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar 等\nmanifest.json 文件是应用的配置文件，用于指定应用的名称、图标、权限等。\nApp.vue是我们的跟组件，所有页面都是在App.vue下进行切换的，是页面入口文件，可以调用应用的生命周期函数。\nmain.js是我们的项目入口文件，主要作用是初始化vue实例并使用需要的插件。\nuni.scss文件的用途是为了方便整体控制应用的风格。比如按钮颜色、边框风格，uni.scss文件里预置了一批scss变量预置。\nunpackage 就是打包目录，在这里有各个平台的打包文件\npages 所有的页面存放目录\nstatic 静态资源目录，例如图片等\ncomponents 组件存放目录\n为了实现多端兼容，综合考虑编译速度、运行性能等因素，uni-app 约定了如下开发规范：\n 页面文件遵循 Vue 单文件组件 (SFC) 规范 组件标签靠近小程序规范，详见uni-app 组件规范 接口能力（JS API）靠近微信小程序规范，但需将前缀 wx 替换为 uni，详见uni-app接口规范 数据绑定及事件处理同 Vue.js 规范，同时补充了App及页面的生命周期 为兼容多端运行，建议使用flex布局进行开发  全局配置和页面配置 通过globalStyle进行全局配置 用于设置应用的状态栏、导航条、标题、窗口背景色等。详细文档\n   属性 类型 默认值 描述     navigationBarBackgroundColor HexColor #F7F7F7 导航栏背景颜色（同状态栏背景色）   navigationBarTextStyle String white 导航栏标题颜色及状态栏前景颜色，仅支持 black/white   navigationBarTitleText String  导航栏标题文字内容   backgroundColor HexColor #ffffff 窗口的背景色   backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark / light   enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面生命周期。   onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位只支持px，详见页面生命周期    创建新的message页面 右键pages …","date":1623888000,"description":"","lastmod":"2021-06-17T00:00:00Z","objectID":"a4be36b326d307061720af75de045010","permalink":"https://huachengzhou.github.io/cycle/%E8%84%9A%E6%9C%AC/uniapp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","publishdate":"2021-06-17T00:00:00Z","title":"uniapp基础知识 "},{"content":"（十五）webpack 15.1\twebpack起步 15.1.1\t什么是webpack webpack是一个JavaScript应用的静态模块打包工具。\n从这句话中有两个要点，模块和打包需要关注。grunt/gulp都可以打包，那有什么区别。\n 模块化\n webpack可以支持前端模块化的一些方案，例如AMD、CMD、CommonJS、ES6。可以处理模块之间的依赖关系。不仅仅是js文件可以模块化，图片、css、json文件等等都可以模块化。\n 打包\n webpack可以将模块资源打包成一个或者多个包，并且在打包过程中可以处理资源，例如压缩图片，将scss转成css，ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。grunt/gulp也可以打包。\n和grunt/glup的对比\n grunt/glup的核心是Task  我们可以配置一系列的task，并且定义task要处理的事务（例如ES6/TS转化，图片压缩，scss转css） 之后可以让grunt/glup来执行依次这些任务，让整个流程自动化 所以grunt/glup也被称为前端自动化任务管理工具   看一个gulp例子  task将src下的js文件转化为ES5语法 并输入到dist文件夹中    const gulp = require(\u0026#39;gulp\u0026#39;)\rconst babel = require(\u0026#39;gulp-babel\u0026#39;)\rgulp.task(\u0026#39;js\u0026#39;()=\rgulp.src(\u0026#39;src/*.js\u0026#39;)\r.pipe(babel({\rpresets:[\u0026#39;es2015\u0026#39;]\r}))\r.pipe(gulp.dest(\u0026#39;dist\u0026#39;))\r);\r\r 什么时候使用grunt/gulp呢？  如果工程依赖简单，甚至没有模块化 只需要进行简单的合并/压缩 如果模块复杂，相互依赖性强，我们需要使用webpack   grunt/glup和webpack区别  grunt/glup更加强调的是前端自动化流程，模块化不是其核心 webpack加强模块化开发管理，而文件压缩/合并/预处理等功能，是附带功能    webpack就是前端模块化打包工具\n15.1.2\twebpack的安装  webpack依赖node环境。 node环境依赖众多包，所以需要npm，npm（node packages manager）node包管理工具 nvm是node管理工具可以自由切换node环境版本  全局安装webpack\nnpm install webpack -g //指定版本安装 npm install webpack@3.6.0 -g  由于vue-cli2基于webpack3.6.0 如果要用vue-cli2的可以使用npm install webpack@3.6.0 -g\n 局部安装\nnpm install webpack --save-dev   在终端执行webpack命令，使用的是全局安装。\n  当在package.json中定义了scripts时，其中包括了webpack命令，那么使用的是局部webpack\n  15.1.3 起步 新建一个文件夹，新建如下结构的目录：\n目录结构\n如图所示在src文件夹（源码文件夹），dist（要发布的文件，已经处理过的）。\n1.新建入口js文件main.js和mathUtils.js，main.js依赖mathUtils.js。\n mathUtils\n //1.新建mathUtils.js，用CommonJs规范导出 function add(num1,num2) { return num1+num2 } function mul(num1,num2) { return num1*num2 } module.exports = { add,mul }  main.js\n //2.新建入口js文件main.js 导入mathUtil.js文件，并调用 const {add,mul} = require(\u0026amp;#34;./mathUtils.js\u0026amp;#34;) console.log(add(10,20)) console.log(mul(10,10)) 2.使用webpack命令打包js文件\n 注意：webpack3使用webpack ./src/main.js ./dist/bundle.js\nwebpack4，webpack打包在01-webpack的起步目录下打开终端 webpack ./scr/main.js -o ./dist/bundle.js\n 我全局安装的是webpack@3.6.0，所以在根路径执行\n如图显示打包成功，查看dist文件夹下自动生成了一个bundle.js。\n bundle.js\n //2.新建入口js文 …","date":1623888000,"description":"","lastmod":"2021-06-17T00:00:00Z","objectID":"1aec514c98142cd107ebdf3fedc36c04","permalink":"https://huachengzhou.github.io/cycle/%E8%84%9A%E6%9C%AC/webpack/","publishdate":"2021-06-17T00:00:00Z","title":"webpack "},{"content":"webpack和nodejs关系  webpack可以将 .vue 文件转换为 .js 文件，而这个转换需要借助打包器vue-loader，这个打包器的下载是在node环境使用 npm 下载的（npm类似与一个应用商店，里面有很多包）；这样webpack在打包的时候是在node环境中运行的。\n  nodejs是js后端运行平台，可以把它看成java体系中对应的jdk，是三个里面最基础的。 npm是nodejs的包管理工具，可以把它看成maven中包依赖管理那部分。 webpack是前端工程化打包工具，可以把它看成maven中工程自动化那部分  npm npm是什么 是Node.js的包管理工具，是全球最大的开发库生态系统（注册表）\r为何产生？ 当网站的依赖的js越来越多，程序员发现这是一件麻烦事：\r去JQuery官网下载JQuery，去 BootStrap 官网下载 BootStrap ，去 Underscore 官网下载 Underscore .......没完没了\r于是npm就出来了（全称 Node Package Manager 包管理工具），大家把自己写好的源码上传到npm官网上，如果要用某个或某些个，直接通过npm安装就可以了，并且模块A依赖B，B依赖C、D，此时只需安装A即可，因为此时npm会根据依赖关系，把所有依赖的包都下载下来并且管理起来；\r这一点和maven、gradle十分相似，只不过maven、gradle是用来管理java jar包的，而npm是用来管理js的。\r常用命令  npm init：初始化一个项目包，包含package.json文件 npm install：package.json的devDependencies字段里的插件全部安装到node_modules下  node node.js是javascript的一种运行环境，是对Google V8引擎进行的封装。是一个服务器端的javascript的解释器。\r包含关系，nodejs中含有npm，比如说你安装好nodejs，你打开cmd输入npm -v会发现出啊线npm的版本号，说明npm已经安装好。\rwebpack Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将这些模块按照指定的规则生成对应的静态资源。\r我们为什么使用webpack? 开发是时候需要一个开发环境，要是我们修改一下代码保存之后浏览器就自动展现最新的代码就好了（热更新服务）\r本地代码的时候，要是调后端的接口不跨域就好了（代理服务）\r为了跟上时代，要是能用上ES678N就好了（翻译服务）\r项目要上线了，要是能一键压缩代码，图片什么的就好了（压缩打包服务）\r我们平时的静态资源都是放到CDN上的，要是能自动帮我把这些搞好的静态资源怼到CDN上就好了（自动上传服务）\r这么多服务，我们需要webpack帮我们去整合那么多的服务，而node的出现，赋予了我们操作系统的能力，要根据自己的需求来使用webpack，知道自己需要什么样的服务，webpack能不能提供这样的服务，如果可以，那么这个服务应该在构建中的呢个环节被处理。\r1.如果与输入相关的需求，找entry（比如多页面就有多个入口）\r2.如果与输出相关的需求，找output（比如你要定义输出文件的路径）\r3.如果与模块寻址相关的需求，找resolve（比如定义别名alias）\r4.如果与转译相关的需求，找loader（比如处理sass处理es678N）\r5.如果与构建流程相关的需求，找plugin（比如我需要在打包完成后，将打包好的文件复制到某个目录，然后提交到git上）\r4人点赞\r工程化\r其它   提问：\n  1.webpack安装一般使用npm，那么也需要安装node，而后台不想用nodeJs编写，这样是不是多余，毕竟不用nodeJs,为什么要因为使用webpage而被动安装node呢？（请原谅我对这方面知识的欠缺= =）\n  2.不仅是vue.js使用npm，很多好的框架和工具都使用，这里还请大神告诉我npm、node、nodejs他们之间的关系，好混乱啊。。\n  问题一：\n  使用webpack跟后台是否用nodejs无关，因为webpack在执行打包压缩的时候是依赖nodejs的，没有nodejs就不能使用webpack就好比你要使用电灯，首先必须得有电流，而电流是需要发动机来发电的，你不能因为说我不要发动机而直接使用电流吧~\n  问题二：\n  node和nodejs就是同一个东西，只是名字不同而已，而npm只是nodejs的一个模块\n  webpack是基于nodejs实现的， Node.js 是前端工程化 …","date":1623888000,"description":"","lastmod":"2021-06-17T00:00:00Z","objectID":"45fb6d558a5e30b80b07d6109ae4c721","permalink":"https://huachengzhou.github.io/cycle/%E8%84%9A%E6%9C%AC/webpack%E5%92%8Cnodejs%E5%85%B3%E7%B3%BB/","publishdate":"2021-06-17T00:00:00Z","title":"webpack和nodejs关系 "}]