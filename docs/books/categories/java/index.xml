<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on Hugo Book</title>
    <link>https://huachengzhou.github.io/cycle/books/categories/java/</link>
    <description>Recent content in java on Hugo Book</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 15 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://huachengzhou.github.io/cycle/books/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>10个Java经典的List面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_10%E4%B8%AAjava%E7%BB%8F%E5%85%B8%E7%9A%84list%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_10%E4%B8%AAjava%E7%BB%8F%E5%85%B8%E7%9A%84list%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>1、你知道的 List 都有哪些？ ArrayList、LinkedList、Vector 等。 2、List 和 Vector 有什么区别？ Vector 是 List 接口下线程安全的集合。 3、List 是有序的吗？ List 是有序的。 4、ArrayList 和 LinkedList 的区别？分别用在什么场景？ ArrayList 和 LinkedList 数据结构不一样，前者用在查询较多的场合，后者适用于插入较多的 场合。 5、ArrayList 和 LinkedList 的底层数据结构是什么？ ArrayList 使用的是数组结构，LinkedList 使用的是链表结构。 6、ArrayList 默认大小是多少，是如何扩容的？ Jdk1.7 之前 ArrayList 默认大小是 10，JDK1.7 之后是 0，JDK 差异，每次约按 1.5 倍扩容。 7、List 是线程安全的吗？如果要线程安全要怎么做？ List 中 的 Vector 才 是 线 程 安 全 的 ， 其 他 要 实 现 线 程 安 全 使 用 工 具 类 Collections.</description>
    </item>
    
    <item>
      <title>10个Java经典的Main方法面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_10%E4%B8%AAjava%E7%BB%8F%E5%85%B8%E7%9A%84main%E6%96%B9%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_10%E4%B8%AAjava%E7%BB%8F%E5%85%B8%E7%9A%84main%E6%96%B9%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>1.main方法是做什么用的？
main方法是Java程序的入口方法，JVM在运行的时候会首先查找main方法。
2.不用main方法如何运行一个类？
不行，没有main方法我们不能运行Java类。 在Java 7之前，你可以通过使用静态初始化运行Java类。但是，从Java 7开始就行不通了。
3.main方法如何传递参数？传递参数的类型是什么？能不能改变该参数类型？
String数组，不能改变。
4.main方法为什么是静态的？能不能改为非静态？
main()方法一定是静态的，如果main()是非静态的那么在调用main方法时JVM就得实例化 它的类。
不能改为非静态，main()方法必须声明为静态的，这样JVM才可以调用main()方法而无需实 例化它的类。 如果从main()方法去掉“static”这个声明，虽然编译依然可以成功，但在运行时会导致程序 失败。 在实例化时，还得调用类的构造函数。如果这个类的构造函数有参数，那么届时就会出现歧 义。
5.main方法能被重载吗？
可以，我们可以重载main()方法。一个Java类可以有任意数量的main()方法。
6.main方法能被覆盖吗？
在Java中静态方法在编译时会编译在一起，main方法是静态方法，所以你在Java中不能覆 盖静态方法。
7.main方法的返回类型是什么？能不能改变？
void，不能改变。
8.main方法的作用域用什么修饰？能不能改变？
public，不能改变。
9.main方法可以同步吗？
main方法可以在Java中同步，synchronized修饰符允许用于main方法的声明中，这样就可 以在Java中同步main方法了。
10.main方法可以终结吗？
可以在Java中终结main方法。
更多关注Java大后端公众号</description>
    </item>
    
    <item>
      <title>10个Java经典的String面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_10%E4%B8%AAjava%E7%BB%8F%E5%85%B8%E7%9A%84string%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_10%E4%B8%AAjava%E7%BB%8F%E5%85%B8%E7%9A%84string%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>1 、String是基本数据类型吗？
String不是基本数据类型。
2 、String是可变的话？
String是final类型的，不可变。
3 、怎么比较两个字符串的值一样，怎么比较两个字符串是否同一对象？
比较字符串的值是否相同用equals,比较字符串对象是否同一个用==。
4 、switch中可以使用String吗？
jdk7+中的switch可以使用String类型。
5 、String str = new String(&amp;ldquo;abc&amp;rdquo;);创建了几个对象，为什么？
创建了两个，&amp;ldquo;abc&amp;quot;本身创建在常量池，通过new又创建在堆中。
6 、String、StringBuffer、StringBuilder有什么区别？
String、StringBuffer、StringBuilder最大的不同是String不可变，后者可变。StringBuffer是线 程安全的，StringBuilder线程不安全速度较快。
7 、String.trim()方法去掉的是哪些字符？
trim去掉字符串首尾的空白字符。
8 、String可以被子类继承吗？
既然String是final的，所以不能被继承。
9 、可以自定义java.lang.String类并使用吗？
可以自定义java.lang.String类并编译成功，但不能被加载使用，具体请学习类加载机制。
10 、String与byte[]两者相互之间如何转换？
String &amp;gt; byte[] 通过String类的getBytes方法；byte[] &amp;gt; String通过new String(byte[])构造器。</description>
    </item>
    
    <item>
      <title>10道Java面试必备的设计模式面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_10%E9%81%93java%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_10%E9%81%93java%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>**1.**请列举出在 JDK 中几个常用的设计模式？
单例模式（Singleton pattern）用于 Runtime，Calendar 和其他的一些类中。工厂模式（Factory pattern）被用于各种不可变的类如 Boolean，像 Boolean.valueOf，观察者模式（Observer pattern）被用于 Swing 和很多的事件监听中。装饰器设计模式（Decorator design pattern）被用于多个 Java IO 类中。
**2.**什么是设计模式？你是否在你的代码里面使用过任何设计模式？
设计模式是世界上各种各样程序员用来解决特定设计问题的尝试和测试的方法。设计模式是代码可用性的延伸
3.Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式
单例模式重点在于在整个系统上共享一些创建时较耗资源的对象。整个应用中只维护一个特定类实例，它被所有组件共同使用。Java.lang.Runtime 是单例模式的经典例子。从 Java 5 开始你可以使用枚举（enum）来实现线程安全的单例。
**4.**在 Java 中，什么叫观察者设计模式（observer design pattern）？
观察者模式是基于对象的状态变化和观察者的通讯，以便他们作出相应的操作。简单的例子就是一个天气系统，当天气变化时必须在展示给公众的视图中进行反映。这个视图对象是一个主体，而不同的视图是观察者。
**5.**使用工厂模式最主要的好处是什么？在哪里使用？
工厂模式的最大好处是增加了创建对象时的封装层次。如果你使用工厂来创建对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任何修改。
6.举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？
装饰模式增加强了单个对象的能力。Java IO 到处都使用了装饰模式，典型例子就是 Buffered 系列类如 BufferedReader 和 BufferedWriter，它们增强了 Reader 和 Writer 对象，以实现提升性能的 Buffer 层次的读取和写入。
**7.**在 Java 中，为什么不允许从静态方法中访问非静态变量？
{width=&amp;ldquo;1.3041666666666667in&amp;rdquo; height=&amp;ldquo;1.336111111111111in&amp;rdquo;}
更多关注 Java 大后端公众号
Java 中不能从静态上下文访问非静态数据只是因为非静态变量是跟具体的对象实例关联的，而静态的却没有和任何实例关联。
**8.**设计一个 ATM 机，请说出你的设计思路？
比如设计金融系统来说，必须知道它们应该在任何情况下都能够正常工作。不管是断电还是</description>
    </item>
    
    <item>
      <title>10道Java高级必备的Netty面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_10%E9%81%93java%E9%AB%98%E7%BA%A7%E5%BF%85%E5%A4%87%E7%9A%84netty%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_10%E9%81%93java%E9%AB%98%E7%BA%A7%E5%BF%85%E5%A4%87%E7%9A%84netty%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>1.BIO、NIO和AIO的区别？#BIO：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线#程开销大。#伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。#NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器#轮询到连接有I/O请求时才启动一个线程进行处理。#AIO：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启#动线程进行处理，#BIO是面向流的，NIO是面向缓冲区的；BIO的各种流是阻塞的。而NIO是非阻塞的；BIO的#Stream是单向的，而NIO的channel是双向的。
NIO的特点：事件驱动模型、单线程处理多任务、非阻塞I/O，I/O读写不再阻塞，而是返回 0 、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大 提高了Java网络应用的可伸缩性和实用性。基于Reactor线程模型。
在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器 就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。如 在Reactor中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到 来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到 的数据，注册新的事件，然后返还控制权。
2.NIO的组成？ Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的
flip方法 ： 反转此缓冲区，将position给limit，然后将position置为 0 ，其实就是切换读写 模式 clear方法 ：清除此缓冲区，将position置为 0 ，把capacity的值给limit。 rewind方法 ： 重绕此缓冲区，将position置为 0 DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高， 不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用 heapBuffer，由JVM进行管理。
Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进 行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！
Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向
多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生 一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法： 使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的 channel或者事件； channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。</description>
    </item>
    
    <item>
      <title>15道经典的Tomcat面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_15%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84tomcat%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_15%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84tomcat%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>1、Tomcat 的缺省端口是多少，怎么修改？ 1）找到 Tomcat 目录下的 conf 文件夹2）进入 conf 文件夹里面找到 server.xml 文件3）打开 server.xml 文件
 4）在 server.xml 文件里面找到下列信息
&amp;lt;Connector connectionTimeout=&amp;quot;20000&amp;quot; port=&amp;quot;8080&amp;quot; protocol=&amp;quot;HTTP/1.1&amp;quot; redirectPort=&amp;quot;8443&amp;quot; uriEncoding=&amp;quot;utf-8&amp;quot;/&amp;gt;
port=&amp;quot;8080&amp;quot;改成你想要的端口
2、tomcat 有哪几种 Connector 运行模式(优化)？#bio：传统的 Java I/O 操作，同步且阻塞 IO。
maxThreads=&amp;ldquo;150&amp;rdquo;//Tomcat 使用线程来处理接收的每个请求。这个值表示Tomcat 可创建的最大的线程数。默认值 200。可以根据机器的时期性能和内存大小调整，一般可以在 400-500。最大可以在 800 左右。minSpareThreads=&amp;ldquo;25&amp;rdquo;&amp;mdash;Tomcat 初始化时创建的线程数。默认值 4。如果当前没有空闲线程，且没有超过 maxThreads，一次性创建的空闲线程数量。Tomcat初始化时创建的线程数量也由此值设置。
maxSpareThreads=&amp;ldquo;75&amp;rdquo;&amp;ndash;一旦创建的线程超过这个值，Tomcat 就会关闭不再需要的 socket 线程。默认值 50。一旦创建的线程超过此数值，Tomcat 会关闭不再需要的线程。线程数可以大致上用 &amp;ldquo;同时在线人数每秒用户操作次数系统平均操作时间&amp;rdquo; 来计算。
acceptCount=&amp;ldquo;100&amp;rdquo;&amp;mdash;-指定当所有可以使用的处理请求的线程数都被使用时， 可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值 10。如果当前可用线程数为 0，则将请求放入处理队列中。这个值限定了请求队列的大小，超过这个数值的请求将不予处理。
connectionTimeout=&amp;ldquo;20000&amp;rdquo; &amp;ndash;网络连接超时，默认值 20000，单位：毫秒。设置为 0 表示永不超时，这样设置有隐患的。通常可设置为 30000 毫秒。
nio：JDK1.4 开始支持，同步阻塞或同步非阻塞 IO。指定使用 NIO 模型来接受 HTTP 请求</description>
    </item>
    
    <item>
      <title>15道面试常问的Java多线程面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_15%E9%81%93%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_15%E9%81%93%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>现在有 T1、T2、T3 三个线程，你怎样保证 T2 在 T1 执行完后执行，T3 在 T2 执行完后执行？   这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对&amp;quot;join&amp;quot;方法是否熟悉。这个多线程问题比较简单，可以用 join 方法实现。
  在 Java 中 Lock 接口比 synchronized 块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？   lock 接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap 这样的高性能数据结构和有条件的阻塞。Java 线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下 Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。
  在 java 中 wait 和 sleep 方法的不同？   通常会在电话面试中经常被问到的 Java 线程面试问题。最大的不同是在等待时 wait 会释放锁，而 sleep 一直持有锁。Wait 通常被用于线程间交互，sleep 通常被用于暂停执行。
 用 Java 实现阻塞队列。   这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用 Java 线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用wait()和notify()方法来实现阻塞队列，你可以要求他用最新的Java 5 中的并发类来再写一次。
 用 Java 写代码来解决生产者&amp;mdash;&amp;mdash;消费者问题。   与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在 Java 中怎么解决生产者&amp;mdash;&amp;mdash;消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。</description>
    </item>
    
    <item>
      <title>17道消息队列Kafka面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_17%E9%81%93%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_17%E9%81%93%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>Kafka 的设计时什么样的呢？  Kafka 将消息以 topic 为单位进行归纳
将向Kafka topic 发布消息的程序成为 producers.
将预订 topics 并消费消息的程序成为 consumer.
Kafka 以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个 broker. producers 通过网络将消息发送到Kafka 集群，集群向消费者提供消息
 数据传输的事物定义有哪三种？  数据传输的事务定义通常有以下三种级别：
  最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输
  最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输.
  精确的一次（Exactly once）: 不会漏传输也不会重复传输,每个消息都传输被一次而且仅仅被传输一次，这是大家所期望的
   Kafka 判断一个节点是否还活着有那两个条件？    节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接
  如果节点是个follower,他必须能及时的同步 leader 的写操作，延时不能太久
   producer 是否直接将数据发送到 broker 的 leader(主节点)？  producer 直接将数据发送到 broker 的 leader(主节点)，不需要在多个节点进行分发，为了帮助 producer 做到这点，所有的 Kafka 节点都可以及时的告知:哪些节点是活动的，目标 topic 目标分区的leader 在哪。这样 producer 就可以直接将消息发送到目的地了</description>
    </item>
    
    <item>
      <title>18道非常牛逼的Nginx面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_18%E9%81%93%E9%9D%9E%E5%B8%B8%E7%89%9B%E9%80%BC%E7%9A%84nginx%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_18%E9%81%93%E9%9D%9E%E5%B8%B8%E7%89%9B%E9%80%BC%E7%9A%84nginx%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>1、请解释一下什么是 Nginx?# Nginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3 和IMAP 协议。
**2、请列举 Nginx 的一些特性。**Nginx 服务器的特性包括：
反向代理/L7 负载均衡器嵌入式 Perl 解释器
动态二进制升级
可用于重新编写 URL，具有非常好的 PCRE 支持3、请列举 Nginx 和 Apache 之间的不同点
 4、请解释 Nginx 如何处理 HTTP 请求。# Nginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提供数万个并发连接。
5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求? 只需将请求删除的服务器就可以定义为：
Server {listen 80;server_name &amp;quot; &amp;quot; ;return 444;
}
这里，服务器名被保留为一个空字符串，它将在没有&amp;quot;主机&amp;quot;头字段的情况下匹配请求，而一个特殊的 Nginx 的非标准代码 444 被返回，从而终止连接。
 6、 使用&amp;quot;反向代理服务器&amp;quot;的优点是什么?# 反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服务时。
 7、请列举 Nginx 服务器的最佳用途。# Nginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应用程序服务器、用于脚本的 FastCGI 处理程序。它还可以作为负载均衡器。</description>
    </item>
    
    <item>
      <title>20道面试官常问的JVM面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_20%E9%81%93%E9%9D%A2%E8%AF%95%E5%AE%98%E5%B8%B8%E9%97%AE%E7%9A%84jvm%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_20%E9%81%93%E9%9D%A2%E8%AF%95%E5%AE%98%E5%B8%B8%E9%97%AE%E7%9A%84jvm%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>内存模型以及分区，需要详细到每个区放什么。
  堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。
  对象创建方法，对象的内存分配，对象的访问定位。
   new 一个对象
   GC 的两种判定方法：
  SafePoint 是什么
  GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在
   什么地方，如果让你优化收集方法，有什么思路？
   GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。
  Minor GC 与 Full GC 分别在什么时候发生？
   新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC
   几种常用的内存调试工具：jmap、jstack、jconsole、jhat
  类加载的几个过程：
  JVM 内存分哪几个区，每个区的作用是什么?
  如和判断一个对象是否存活?</description>
    </item>
    
    <item>
      <title>20道顶尖的Springoot面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_20%E9%81%93%E9%A1%B6%E5%B0%96%E7%9A%84springoot%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_20%E9%81%93%E9%A1%B6%E5%B0%96%E7%9A%84springoot%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>面试了一些人，简历上都说自己熟悉 Spring Boot, 或者说正在学习 Spring Boot，一问他们时，都只停留在简单的使用阶段，很多东西都不清楚，也让我对面试者大失所望。
下面，我给大家总结下有哪些 Spring Boot 的面试题，这是我经常拿来问面试者的，希望对你有帮助。
 1、什么是 Spring Boot？# Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。
更多 Spring Boot 详细介绍请看这篇文章《什么是 Spring Boot?》。
 2、为什么要用 Spring Boot？# Spring Boot 优点非常多，如：
   独立运行
  简化配置
  自动配置
  无代码生成和 XML 配置
  应用监控
  上手容易
  ...
   Spring Boot 集这么多优点于一身，还有理由不使用它呢？</description>
    </item>
    
    <item>
      <title>22道面试常问的SpringMVC面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_22%E9%81%93%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84springmvc%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_22%E9%81%93%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84springmvc%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>1、什么是SpringMvc？
答：SpringMvc 是 spring 的一个模块，基于MVC 的一个框架，无需中间整合层来整合。
2、Spring MVC 的优点： 答：
 它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java  组件.并且和 Spring 提供的其他基础结构紧密集成.
  不依赖于Servlet API(目标虽是如此,但是在实现的时候确实是依赖于 Servlet 的)
  可以任意使用各种视图技术,而不仅仅局限于JSP
  支持各种请求资源的映射策略
  它应是易于扩展的
  3、SpringMVC 工作原理？ 答：
  客户端发送请求到 DispatcherServlet
  DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller 3）Controller 调用业务逻辑后，返回 ModelAndView 4）DispatcherServlet 查询 ModelAndView，找到指定视图
   5）视图将结果返回到客户端
 4、SpringMVC 流程？ 答：
 1）用户发送请求至前端控制器 DispatcherServlet。2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。
  处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。</description>
    </item>
    
    <item>
      <title>24道消息队列RabbitMQ面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_24%E9%81%93%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rabbitmq%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_24%E9%81%93%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rabbitmq%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>问题一：RabbitMQ 中的 broker 是指什么？cluster 又是指什么？
答：broker 是指一个或多个 erlang node 的逻辑分组，且 node 上运行着 RabbitMQ 应用程序。cluster 是在 broker 的基础之上，增加了 node 之间共享元数据的约束。
问题二：什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据有哪些？元数据是如何保存的？元数据在 cluster 中是如何分布的？
答：在非 cluster 模式下，元数据主要分为 Queue 元数据（queue 名字和属性等）、Exchange 元数据（exchange 名字、类型和属性等）、Binding 元数据（存放路由关系的查找表）、Vhost 元数据（vhost 范围内针对前三者的名字空间约束和安全属性设置）。在 cluster 模式下，还包括 cluster 中 node 位置信息和 node 关系信息。元数据按照 erlang node 的类型确定是仅保存于 RAM 中，还是同时保存在 RAM 和 disk 上。元数据在 cluster 中是全 node 分布的。
下图所示为 queue 的元数据在单 node 和 cluster 两种模式下的分布图。
问题三：RAM node 和 disk node 的区别？
答：RAM node 仅将 fabric（即 queue、exchange 和 binding 等 RabbitMQ 基础构件）相关元数据保存到内存中，但 disk node 会在内存和磁盘中均进行存储。RAM node 上唯一会存储到磁盘上的元数据是 cluster 中使用的 disk node 的地址。要求在 RabbitMQ cluster 中至少存在一个 disk node 。</description>
    </item>
    
    <item>
      <title>24道经典的英语面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_24%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84%E8%8B%B1%E8%AF%AD%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_24%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84%E8%8B%B1%E8%AF%AD%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>Q： Can you sell yourself in two minutes？ Go for it. （你能在两分钟內自我推荐吗？大胆试试吧！）
A： With my qualifications and experience, I feel I am hardworking, responsible and diligent in any project I undertake. Your organization could benefit from my analytical and interpersonal skills.(依我的资格和经验，我觉得我对所从事的每一个项目都很努力、负责、勤勉。我的分析能力和与人相处的技巧，对贵单位必有价值。)
Q：Give me a summary of your current job description. (对你目前的工作， 能否做个概括的说明。)
A：I have been working as a computer programmer for five years. To be specific, I do system analysis, trouble shooting and provide software support.</description>
    </item>
    
    <item>
      <title>27道顶尖的Java多线程锁、内存模型面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_27%E9%81%93%E9%A1%B6%E5%B0%96%E7%9A%84java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_27%E9%81%93%E9%A1%B6%E5%B0%96%E7%9A%84java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>Synchronized 相关问题#问题一： Synchronized 用过吗， 其原理是什么？
这是一道 Java 面试中几乎百分百会问到的问题，因为没有任何写过并发程序的开发者会没听说或者没接触过 Synchronized。
Synchronized 是由 JVM 实现的一种实现互斥同步的一种方式， 如果你查看被 Synchronized 修饰过的程序块编译后的字节码， 会发现， 被Synchronized 修 饰 过 的 程 序 块 ， 在 编 译 前 后 被 编 译 器 生 成了 monitorenter 和 monitorexit 两个字节码指令。
这两个指令是什么意思呢？
在虚拟机执行到 monitorenter 指令时， 首先要尝试获取对象的锁：
如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁的计数器 +1 ；当执行 monitorexit 指令时将锁计数器 - 1 ；当计数器为 0 时， 锁就被释放了。
如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。
Java 中 Synchronize 通过在对象头设置标记， 达到了获取锁和释放锁的目的。
**问题二：**你刚才提到获取对象的锁，这个&amp;quot; 锁&amp;quot;到底是什么？ 如何确定对象的锁？
&amp;quot; 锁&amp;quot; 的本质其实是 monitorenter 和 monitorexit 字节码指令的一个Reference 类型的参数， 即要锁定和解锁的对象。 我们知道， 使用</description>
    </item>
    
    <item>
      <title>29道常见的Spring面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_29%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84spring%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_29%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84spring%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>以下为 spring 常见面试问题：
1、什么是 Spring 框架？Spring 框架有哪些主要模块？
Spring 框架是一个为 Java 应用程序的开发提供了综合、广泛的基础性支持的 Java 平台。
Spring 帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。
Spring 框架本身亦是按照[设计模式]{.underline}精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。
Spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、
Web、AOP（面向切面编程）、工具、消息和测试模块。
2、使用 Spring 框架能带来哪些好处？
下面列举了一些使用 Spring 框架带来的主要好处：
   [Dependency Injection(DI)]{.underline} 方法使得构造器和 JavaBean properties 文件中的依赖关系一目了然。
  与 EJB 容器相比较，IoC 容器更加趋向于轻量级。这样一来 IoC 容器在有限的内存和 CPU 资源的情况下进行应用程序的开发和发布就变得十分有利。
  Spring 并没有闭门造车，Spring 利用了已有的技术比如 ORM 框架、logging 框架、J2EE、Q uartz 和 JDK Timer，以及其他视图技术。
  Spring 框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。
  要[测试一项用 Spring 开发的应用程序]{.</description>
    </item>
    
    <item>
      <title>30个Java经典的集合面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_30%E4%B8%AAjava%E7%BB%8F%E5%85%B8%E7%9A%84%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_30%E4%B8%AAjava%E7%BB%8F%E5%85%B8%E7%9A%84%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>Java 集合框架是什么？说出一些集合框架的优点？  每种编程语言中都有集合，最初的 Java 版本包含几种集合类：Vector、Stack、HashTable 和
Array。
随着集合的广泛使用，Java1.2 提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java 已经经历了很久。它还包括在 Java 并发包中，阻塞接口以及它们的实现。
集合框架的部分优点如下：
  使用核心集合类降低开发成本，而非实现我们自己的集合类。
  随着使用经过严格测试的集合框架类，代码质量会得到提高。
  通过使用 JDK 附带的集合类，可以降低代码维护成本。
  复用性和可操作性。
   集合框架中的泛型有什么优点？    Java1.5 引入了泛型，所有的集合接口和实现都大量地使用它。
  泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。
  这避免了在运行时出现 ClassCastException，因为你将会在编译时得到报错信息。4.泛型也使得代码整洁，我们不需要使用显式转换和 instanceOf 操作符。
  5.它也给运行时带来好处，因为不会产生类型检查的字节码指令。
3.Java 集合框架的基础接口有哪些？
Collection 为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java 平台不提供这个接口任何直接的实现。
Set 是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合， 就如一副牌。
List 是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List 更像长度动态变换的数组。
Map 是一个将 key 映射到 value 的对象.一个 Map 不能包含重复的 key：每个 key 最多只能映射一个 value。</description>
    </item>
    
    <item>
      <title>36道面试常问的MyBatis面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_36%E9%81%93%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84mybatis%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_36%E9%81%93%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84mybatis%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>1、什么是MyBatis？
答：MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。2、讲下 MyBatis 的缓存
答：MyBatis 的缓存分为一级缓存和二级缓存,一级缓存放在 session 里面,默认就有,二级缓存放在它的命名空间里,默认是不打开的,使用二级缓存属性类需要实现Serializable 序列化接口 (可用来保存对象的状态),可在它的映射文件中配置&amp;lt;cache/&amp;gt;
3、Mybatis 是如何进行分页的？分页插件的原理是什么？ 答：
 Mybatis 使用 RowBounds 对象进行分页，也可以直接编写 sql 实现分页，也可以使用 Mybatis  的分页插件。
 分页插件的原理：实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写 sql。  举例：select * from student，拦截 sql 后重写为：select t.* from （select * from student）t limit 0，10
4、简述 Mybatis 的插件运行原理，以及如何编写一个插件？ 答：
  Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor这 4 种接口的插件，Mybatis 通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时， 就会进入拦截方法， 具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。
  实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</description>
    </item>
    
    <item>
      <title>40道常问的Java多线程面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_40%E9%81%93%E5%B8%B8%E9%97%AE%E7%9A%84java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_40%E9%81%93%E5%B8%B8%E9%97%AE%E7%9A%84java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>这些多线程的问题，有些来源于各大网站、有些来源于自己的思考。可能有些问题网上有、可能有些问题对应的答案也有、也可能有些各位网友也都看过， 但是本文写作的重心就是所有的问题都会按照自己的理解回答一遍，不会去看网上的答案，因此可能有些问题讲的不对，能指正的希望大家不吝指教。
1、多线程有什么用？#一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓&amp;quot;知其然知其所以然&amp;quot;，&amp;quot;会用&amp;quot;只是&amp;quot; 知其然&amp;quot;，&amp;quot;为什么用&amp;quot;才是&amp;quot;知其所以然&amp;quot;，只有达到&amp;quot;知其然知其所以然&amp;quot;的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法： 1）发挥多核 CPU 的优势
 随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4 核、8 核甚至 16 核的也都不少见，如果是单线程的程序，那么在双核 CPU 上就浪费了 50%，在 4 核 CPU 上就浪费了 75%。单核 CPU 上所谓的&amp;quot;多线程&amp;quot;那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程&amp;quot;同时&amp;quot;运行罢了。多核 CPU 上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核 CPU 的优势来，达到充分利用 CPU 的目的。
 防止阻塞#从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因为在单核 CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核 CPU 我们还是要应用多线程，就是为了防止阻塞。试想，如果单核 CPU 使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。
便于建模#这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程， 那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成几个小任务，任务 B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。
2、创建线程的方式#比较常见的一个问题了，一般就是两种：
  继承 Thread 类
  实现 Runnable 接口</description>
    </item>
    
    <item>
      <title>55道BAT精选的Mysql面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_55%E9%81%93bat%E7%B2%BE%E9%80%89%E7%9A%84mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_55%E9%81%93bat%E7%B2%BE%E9%80%89%E7%9A%84mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>{width=&amp;ldquo;6.857017716535433in&amp;rdquo; height=&amp;ldquo;1.6727821522309712in&amp;rdquo;}1、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录， 再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？
2、Mysql 的技术特点是什么？
 Mysql 数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程 SQL 服务器、不同的后端、广泛的应用程序编程接口和管理工具。
 3、Heap 表是什么？
 HEAP 表存在于内存中，用于临时高速存储。
  BLOB 或 TEXT 字段是不允许的
  只能使用比较运算符=，&amp;lt;，&amp;gt;，=&amp;gt;，= &amp;lt;
  HEAP 表不支持 AUTO_INCREMENT
  索引不可为 NULL
   4、Mysql 服务器默认端口是什么？ Mysql 服务器的默认端口是 3306。
5、与 Oracle 相比，Mysql 有什么优势？
   Mysql 是开源软件，随时可用，无需付费。</description>
    </item>
    
    <item>
      <title>60道必备的Java核心技术面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_60%E9%81%93%E5%BF%85%E5%A4%87%E7%9A%84java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_60%E9%81%93%E5%BF%85%E5%A4%87%E7%9A%84java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>1、作用域 public,private,protected,以及不写时的区别#+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+ | **答：**区别如下： | | +====================+==========+================+==========+================+ | 作用域 | &amp;gt; 当前类 | &amp;gt; 同一 package | &amp;gt; 子孙类 | &amp;gt; 其他 package | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+ | public | &amp;gt; √ | &amp;gt; √ | &amp;gt; √ | &amp;gt; √ | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+ | protected | &amp;gt; √ | &amp;gt; √ | &amp;gt; √ | &amp;gt; × | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+ | friendly | &amp;gt; √ | &amp;gt; √ | &amp;gt; × | &amp;gt; × | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+ | private | &amp;gt; √ | &amp;gt; × | × | &amp;gt; × | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+</description>
    </item>
    
    <item>
      <title>7道消息队列ActiveMQ面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_7%E9%81%93%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97activemq%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_7%E9%81%93%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97activemq%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>1.什么是 ActiveMQ? activeMQ 是一种开源的，实现了 JMS1.1 规范的，面向消息(MOM)的中间件，为应用程序提供高效的、 可扩展的、稳定的和安全的企业级消息通信 2. ActiveMQ 服务器宕机怎么办？ 这得从 ActiveMQ 的储存机制说起。在通常的情况下，非持久化消息是存储在内存中的，持久化消息是存 储在文件中的，它们的最大限制在配置文件的节点中配置。但是，在非持久化消息堆积 到一定程度，内存告急的时候，ActiveMQ 会将内存中的非持久化消息写入临时文件中，以腾出内存。虽 然都保存到了文件里，但它和持久化消息的区别是，重启后持久化消息会从文件中恢复，非持久化的临时 文件会直接删除。 那如果文件增大到达了配置中的最大限制的时候会发生什么？我做了以下实验： 设置 2G 左右的持久化文件限制，大量生产持久化消息直到文件达到最大限制，此时生产者阻塞，但消费 者可正常连接并消费消息，等消息消费掉一部分，文件删除又腾出空间之后，生产者又可继续发送消息， 服务自动恢复正常。 设置 2G 左右的临时文件限制，大量生产非持久化消息并写入临时文件，在达到最大限制时，生产者阻塞， 消费者可正常连接但不能消费消息，或者原本慢速消费的消费者，消费突然停止。整个系统可连接，但是 无法提供服务，就这样挂了。 具体原因不详，解决方案：尽量不要用非持久化消息，非要用的话，将临时文件限制尽可能的调大。 3. 丢消息怎么办？ 这得从 java 的 java.net.SocketException 异常说起。简单点说就是当网络发送方发送一堆数据，然后调 用 close 关闭连接之后。这些发送的数据都在接收者的缓存里，接收者如果调用 read 方法仍旧能从缓存中 读取这些数据，尽管对方已经关闭了连接。但是当接收者尝试发送数据时，由于此时连接已关闭，所以会 发生异常，这个很好理解。不过需要注意的是，当发生 SocketException 后，原本缓存区中数据也作废了， 此时接收者再次调用 read 方法去读取缓存中的数据，就会报 Software caused connection abort: recv failed 错误。 通过抓包得知，ActiveMQ 会每隔 10 秒发送一个心跳包，这个心跳包是服务器发送给客户端的，用来判 断客户端死没死。如果你看过上面第一条，就会知道非持久化消息堆积到一定程度会写到文件里，这个写 的过程会阻塞所有动作，而且会持续 20 到 30 秒，并且随着内存的增大而增大。当客户端发完消息调用 connection.close()时，会期待服务器对于关闭连接的回答，如果超过 15 秒没回答就直接调用 socket 层 的 close 关闭 tcp 连接了。这时客户端发出的消息其实还在服务器的缓存里等待处理，不过由于服务器心 跳包的设置，导致发生了 java.</description>
    </item>
    
    <item>
      <title>apache-common工具包</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_apache-common%E5%B7%A5%E5%85%B7%E5%8C%85/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_apache-common%E5%B7%A5%E5%85%B7%E5%8C%85/</guid>
      <description>Apache Commons 工具类介绍及简单使用#   组件 功能介绍     BeanUtils Commons-BeanUtils 提供对 Java 反射和自省API的包装, 提供了对于JavaBean进行各种操作，克隆对象,属性等等.   Betwixt XML与Java对象之间相互转换.   Codec 处理常用的编码方法的工具类包 例如DES、SHA1、MD5、Base64等.   Collections java集合框架操作.   Compress java提供文件打包 压缩类库.   Configuration Commons-Configuration 工具对各种各式的配置和参考文件提供读取帮助,java应用程序的配置管理类库.   DBCP 提供数据库连接池服务.   DbUtils DbUtils 是一个 JDBC helper 类库，完成数据库任务的简单的资源清除代码,提供对jdbc 的操作封装来简化数据查询和记录读取操作   Email java发送邮件 对javamail的封装.   FileUpload 提供文件上传功能.   HttpClient 提供HTTP客户端与服务器的各种通讯操作. 现在已改成HttpComponents   Lang Java基本对象方法的工具类包 如：StringUtils,ArrayUtils等等.</description>
    </item>
    
    <item>
      <title>dom4j</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_dom4j/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_dom4j/</guid>
      <description>dom4j# 选取节点
   nodename 选取当前节点的所有子节点
  / 从根节点选取
  // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置
  . 选取当前节点
  .. 选取当前节点的父节点
  @ 选取属性
   实例
   路径表达式 结果
  bookstore 选取 bookstore 元素的所有子节点
  /bookstore 选取根元素 bookstore
  bookstore/book 选取bookstore 下名字为 book的所有子元素。
  //book 选取所有 book 子元素，而不管它们在文档中的位置。
  bookstore//book 选取bookstore 下名字为 book的所有后代元素，而不管它们位于 bookstore 之下的什么位置。</description>
    </item>
    
    <item>
      <title>Guava-common</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_guava-common/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_guava-common/</guid>
      <description>Guava 基于java1.6的类库集合的扩展项目# com.google.common.annotations：普通注解类型。 com.google.common.base：基本工具类库和接口。 com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存。 com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类，这里你会发现很多好玩的集合。 com.google.common.eventbus：发布订阅风格的事件总线。 com.google.common.hash： 哈希工具包。 com.google.common.io：I/O工具包。 com.google.common.math：原始算术类型和超大数的运算工具包。 com.google.common.net：网络工具包。 com.google.common.primitives：八种原始类型和无符号类型的静态工具包。 com.google.common.reflect：反射工具包。 com.google.common.util.concurrent：多线程工具包。 常见Object方法   hashCode compare/compareTo 实现一个比较器[Comparator]，或者直接实现Comparable接口有时也伤不起
 public class ProjectInfo implements Serializable,Comparable&amp;lt;ProjectInfo&amp;gt; {private int id;private String name;public int getId() {return id;}public String getName() {return name;}public void setId(int id) {this.id = id;}public void setName(String name) {this.name = name;}@Overridepublic int compareTo(ProjectInfo o) {return ComparisonChain.</description>
    </item>
    
    <item>
      <title>IO</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_io/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_io/</guid>
      <description>org.apache.commons.io.FilenameUtils 文件名称操作#  FilenameUtils.getExtension(fileName) 获取文件后缀 //text
  FilenameUtils.getName(fileName) 获取文件完整名称 //c.text
  FilenameUtils.getBaseName(fileName) 获取文件名称 //c
  FilenameUtils.getFullPath(fileName) 获取文件的完整路径 //D:\data\
  String path = &amp;quot;D:\\data\\假设开发法土地模板.docx&amp;quot; ;String fullPath = FilenameUtils.getFullPath(path);System.out.println(&amp;quot;fullPath:&amp;quot;+fullPath);//D:\data\String name = FilenameUtils.getName(path);System.out.println(&amp;quot;name:&amp;quot;+name); //假设开发法土地模板.docxString prefix = FilenameUtils.getPrefix(path);System.out.println(&amp;quot;prefix:&amp;quot;+prefix); //D:\int prefixLength = FilenameUtils.getPrefixLength(path);System.out.println(&amp;quot;prefixLength:&amp;quot;+prefixLength); //3String path1 = FilenameUtils.getPath(path);System.out.println(&amp;quot;path:&amp;quot;+path1); //data\String baseName = FilenameUtils.getBaseName(path);System.out.println(&amp;quot;baseName:&amp;quot;+baseName); //假设开发法土地模板String extension = FilenameUtils.getExtension(path);System.</description>
    </item>
    
    <item>
      <title>java &gt; thread &gt; 高并发和分布式中的幂等处理</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_thread_java_thread_%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%B9%82%E7%AD%89%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_thread_java_thread_%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%B9%82%E7%AD%89%E5%A4%84%E7%90%86/</guid>
      <description>高并发和分布式中的幂等处理#我们先来谈下幂等的概念#抽象概念#  幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。
  在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()和setTrue()”函数就是一个幂等函数。
  用通俗的话讲：就是针对一个操作，不管做多少次，产生效果或返回的结果都是一样的
  举几个例子：
  1.比如前端对同一表单数据的重复提交，后台应该只会产生一个结果。
  2.比如我们发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱。
  3.比如发送消息，也应该只发一次，同样的短信如果多次发给用户，用户会崩溃。
  4.比如创建业务订单，一次业务请求只能创建一个，不能出现创建多个订单。
  还有很多诸如此类的，这些逻辑都需要幂等的特性来支持。
  实现幂等性的技术方案
  查询操作
  查询一次和查询多次，在数据不变的情况下，查询结果是一样的，select是天然的幂等操作。
  删除操作
  删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)
  唯一索引，防止新增脏数据
  拿资金账户和用户账户来说，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，在新增的时候只有一个请求成功，剩下都会抛出唯一索引重复异常。比如org.springframework.dao.DuplicateKeyException，这时候再查询一次就可以了，数据存在，返回结果。
  token机制，防止页面重复提交
  要求：页面的数据只能被点击提交一次
  发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交
  解决办法：
  集群环境：采用token加redis</description>
    </item>
    
    <item>
      <title>java &gt; thread &gt; 高并发高可用的架构实践</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_thread_java_thread_%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_thread_java_thread_%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/</guid>
      <description>高并发高可用的架构实践#一、 设计理念# 1.空间换时间   1)多级缓存，静态化 客户端页面缓存（http header中包含Expires/Cache of Control，last modified(304，server不返回body，客户端可以继续用cache，减少流量)，ETag） 反向代理缓存 应用端的缓存(memcache) 内存数据库 Buffer、cache机制（数据库，中间件等）
  2)索引 哈希、B树、倒排、bitmap 哈希索引适合综合数组的寻址和链表的插入特性，可以实现数据的快速存取。 B树索引适合于查询为主导的场景，避免多次的IO，提高查询的效率。 倒排索引实现单词到文档映射关系的最佳实现方式和最有效的索引结构，广泛用在搜索领域。 Bitmap是一种非常简洁快速的数据结构，他能同时使存储空间和速度最优化（而不必空间换时间），适合于海量数据的的计算场景。
  2.并行与分布式计算   1)任务切分、分而治之(MR) 在大规模的数据中，数据存在一定的局部性的特征，利用局部性的原理将海量数据计算的问题分而治之。 MR模型是无共享的架构，数据集分布至各个节点。处理时，每个节点就近读取本地存储的数据处理(map)，将处理后的数据进行合并(combine)、排序(shuffle and sort)后再分发(至reduce节点)，避免了大量数据的传输，提高了处理效率。
  2)多进程、多线程并行执行(MPP) 并行计算（Parallel Computing）是指同时使用多种计算资源解决计算问题的过程，是提高计算机系统计算速度和处理能力的一种有效手段。它的基本思想是用多个处理器/进程/线程来协同求解同一问题，即将被求解的问题分解成若干个部分，各部分均由一个独立的处理机来并行计算。 和MR的区别在于，它是基于问题分解的，而不是基于数据分解。
  3.多维度的可用   1)负载均衡、容灾、备份 随着平台并发量的增大，需要扩容节点进行集群，利用负载均衡设备进行请求的分发；负载均衡设备通常在提供负载均衡的同时，也提供失效检测功能；同时为了提高可用性，需要有容灾备份，以防止节点宕机失效带来的不可用问题；备份有在线的和离线备份，可以根据失效性要求的不同，进行选择不同的备份策略。
  2)读写分离 读写分离是对数据库来讲的，随着系统并发量的增大，提高数据访问可用性的一个重要手段就是写数据和读数据进行分离；当然在读写分离的同时，需要关注数据的一致性问题；对于一致性的问题，在分布式的系统CAP定量中，更多的关注于可用性。
  3)依赖关系 平台中各个模块之间的关系尽量是低耦合的，可以通过相关的消息组件进行交互，能异步则异步，分清楚数据流转的主流程和副流程，主副是异步的，比如记录日志可以是异步操作的，增加整个系统的可用性。 当然在异步处理中，为了确保数据得到接收或者处理，往往需要确认机制(confirm、ack)。 但是有些场景中，虽然请求已经得到处理，但是因其他原因(比如网络不稳定)，确认消息没有返回，那么这种情况下需要进行请求的重发，对请求的处理设计因重发因素需要考虑幂等性。
  4)监控 监控也是提高整个平台可用性的一个重要手段，多平台进行多个维度的监控；模块在运行时候是透明的，以达到运行期白盒化。
  4.伸缩   1)拆分 拆分包括对业务的拆分和对数据库的拆分。 系统的资源总是有限的，一段比较长的业务执行如果是一竿子执行的方式，在大量并发的操作下，这种阻塞的方式，无法有效的及时释放资源给其他进程执行，这样系统的吞吐量不高。 需要把业务进行逻辑的分段，采用异步非阻塞的方式，提高系统的吞吐量。 随着数据量和并发量的增加，读写分离不能满足系统并发性能的要求，需要对数据进行切分，包括对数据进行分库和分表。这种分库分表的方式，需要增加对数据的路由逻辑支持。</description>
    </item>
    
    <item>
      <title>java &gt; 多线程 &gt; 线程中断问题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E9%97%AE%E9%A2%98/</guid>
      <description>结束线程的方式# 1:Thread.stop() 不推荐使用了  thread.stop() 2:thread.setDaemon() 设置为守护线程,JVM退出自动终止   Thread thread = new Thread(() -&amp;gt; {},&amp;quot;T-1&amp;quot;) ;thread.setDaemon(true);thread.start(); 3:共享变量 通过一个推出表示开关  public class MyTask implements Runnable {private boolean shouldExit = false;public void setShouldExit(boolean newExit) {this.shouldExit = newExit;}@Overridepublic void run() {while (!shouldExit){//执行线程操作}}} 4:利用中断机制thread.interrupt()  A:void interrupt() 相某个线程发出中断信号,将会设置该线程的中断状态位，即设置为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。它并不像stop方法那样会中断一个正在运行的线程。B:boolean isInterrupted() 查询某个线程是否有获得中断信号C:static boolean interrupted() 查询当前线程是否获得中断信号,查询后会重置中断的信号的状态 也就是说如果你连续两次调用这个方法,那么第一次是true,第二次是false 5:较优雅的退出方式  Thread thread = new Thread(new Runnable() {@Overridepublic void run() {while (!</description>
    </item>
    
    <item>
      <title>java &gt; 多线程 &gt; 线程状态</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</guid>
      <description>线程状态#public enum State {/**尚未启动的线程的线程状态 ,这个时候还没有在堆栈中分配内存等数据*/NEW,/**线程可能等待也可能阻塞*/RUNNABLE,/**阻塞 等待锁的状态*/BLOCKED,/**线程等待状态*/WAITING,/**和WAITING类似但是有时间的等待*/TIMED_WAITING,/**线程终止*/TERMINATED;}</description>
    </item>
    
    <item>
      <title>java &gt; 多线程info</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Binfo/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Binfo/</guid>
      <description>1、在 java 中守护线程和本地线程区别？
java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。
任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(boolon)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在 Thread.start()之前调用，否则运行时会抛出异常。
两者的区别：
唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。
扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。
2、线程与进程的区别？
进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。
一个程序至少有一个进程,一个进程至少有一个线程。
3、什么是多线程中的上下文切换？
多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU发生的切换数据等就是上下文切换。
4、死锁与活锁的区别，死锁与饥饿的区别？
死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
产生死锁的必要条件：
1、互斥条件：所谓互斥就是进程在某一时间内独占资源。
2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3、不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。
4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。
活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。
饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。
Java 中导致饥饿的原因：
1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。
2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。
3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。
5、Java 中用到的线程调度算法是什么？
采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。
6、什么是线程组，为什么在 Java 中不推荐使用？
ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</description>
    </item>
    
    <item>
      <title>java &gt; 多线程synchronized</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized/</guid>
      <description>synchronized# synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性
  用法:  public synchronized void doSomething(){//这里的代码不会同时有几个线程执行}synchronized (this){//这里的代码也不会有几个代码同时执行 } synchronized监视器 synchronized(object) object是监视器 被synchronized修饰的方法 静态方法:监视器是所属类的class对象 非静态方法:监视器是this 同一个监视器内所以代码都是同步的,不论是否在同一函数、同一类内如:   监视器不要使用Long,Integer等基本类型对象做监视器这样不好  public synchronized void methodA(){}public synchronized void methodB(){}public void methodC(){synchronized (this){}}//如果有一个线程已经运行ABC三处中的任意一个代码块，那么其它线程都不能执行这三个代码块的任意一个地方 下面是一些监视器  public class Sync {public void doA(){synchronized (this){//A 监视器Sync.this}}public synchronized void doB1(){//B1 监视器Sync.</description>
    </item>
    
    <item>
      <title>java &gt; 多线程synchronized.answer</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized.answer/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized.answer/</guid>
      <description>1342  首先t1线程最先执行所以输出1没问题
  输出t1后执行了object.wait(),当前执行线程放弃了此监视器上的锁,并且被挂起(等待此监视器上的其它线程来唤醒) 这里最重要的是把此监视器上的锁给放弃了
  t2线程去竞争object上的锁,由于目前只有它一个线程是属于非挂起状态因此t2就获得了object上的锁.因此输出了3没问题
  接着t2线程又执行了object.notify(),这个方法是随机唤醒此监视器上被挂起的线程,并且刚好只有2个线程中的一个被挂起那么t1就被唤醒了,注意仅仅是唤醒而已,并没有使得t2放弃锁或者t1获得锁,因此t1还是不能执行
  接着t2线程执行了sleep(500)这个方法,但是这个方法同样并没有使得t2线程放弃锁,仅仅是暂停了那么一会,这就像打战弱势的一方拿空间换时间做战略撤退，实际上并没有投降依然属于不投降状态
  因此当t2线程执行完之后t1最好才能执行接着打印出2
  </description>
    </item>
    
    <item>
      <title>java内存模型</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>JMM(Java内存模型)# 主要有三个特性:可见性,有序性,原子性
 可见性#  计算机内存模型   Java内存模型简易   </description>
    </item>
    
    <item>
      <title>Java试题经典7</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_java%E8%AF%95%E9%A2%98%E7%BB%8F%E5%85%B87/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_java%E8%AF%95%E9%A2%98%E7%BB%8F%E5%85%B87/</guid>
      <description>{width=&amp;ldquo;5.848421916010499in&amp;rdquo; height=&amp;ldquo;9.791119860017497e-3in&amp;rdquo;}更多请关注微信公众号：Java技术栈
 什么是 Java 虚拟机？为什么 Java 被称作是&amp;quot;平台无关的编程语言&amp;quot;？#参考答案#Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。
Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和 其他特性。
JDK 和 JRE 的区别是什么？#参考答案#Java 运行时环境(JRE)是将要执行 Java 程序的 Java 虚拟机。它同时也包含了执行 applet 需要的浏览器插件。Java 开发工具包(JDK)是完整的 Java 软件开发包，包含了 JRE，编译器和其他的工具(比如：JavaDoc，Java 调试器)，可以让开发者开发、编译、执行 Java 应 用程序。
&amp;ldquo;static&amp;quot;关键字是什么意思？Java 中是否可以覆盖(override)一个 private 或者是# static 的方法？
 参考答案#&amp;ldquo;static&amp;quot;关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。
Java 中static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。</description>
    </item>
    
    <item>
      <title>js &gt; console.log用法</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_js_console.log%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_js_console.log%E7%94%A8%E6%B3%95/</guid>
      <description>Console 对象方法#  常用 Console 调试命令
  console.log(&#39;hello&#39;);console.info(&#39;信息&#39;);console.error(&#39;错误&#39;);console.warn(&#39;警告&#39;);assert()# ssert方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。  // 实例console.assert(true === false, &amp;quot;判断条件不成立&amp;quot;)// Assertion failed: 判断条件不成立clear()# 清除当前控制台的所有输出，将光标回置到第一行。  console.clear()count()# 用于计数，输出它被调用了多少次。  (function() {for (var i = 0; i &amp;lt; 5; i++) { console.count(&#39;count&#39;); }})()error()# 输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈。  console.error(&amp;quot;Error: %s (%i)&amp;quot;, &amp;quot;Server is not responding&amp;quot;,500)group()# 用于将显示的信息分组，可以把信息进行折叠和展开。  console.</description>
    </item>
    
    <item>
      <title>jsoup</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_jsoup/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_jsoup/</guid>
      <description>jsoup学习文档#简介# Jsoup是用于解析HTML，就类似XML解析器用于解析XML。 Jsoup它解析HTML成为真实世界的HTML。 它与jquery选择器的语法非常相似，并且非常灵活容易使用以获得所需的结果
 +jsoup api 6个包提供用于开发jsoup应用程序的类和接口。
org.jsouporg.jsoup.examplesorg.jsoup.helperorg.jsoup.nodesorg.jsoup.parserorg.jsoup.safetyorg.jsoup.salect引入#//大多数情况使用jsouporg.jsoup.nodes.Document document = Jsoup.parse(html);Document doc = Jsoup.parse(new URL(&amp;quot;http://www.funi.com/&amp;quot;),7000);//少数情况使用httpUnitWebClient webClient = new WebClient() ;HtmlPage htmlPage = webClient.getPage(&amp;quot;http://www.89ip.cn/&amp;quot;);htmlPage.asXml()//html使用(maven)#&amp;lt;dependency&amp;gt;&amp;lt;!-- jsoup HTML parser library @ http://jsoup.org/ --&amp;gt;&amp;lt;groupId&amp;gt;org.jsoup&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;jsoup&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;1.10.2&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;!-- httpclient --&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;4.5.6&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;net.</description>
    </item>
    
    <item>
      <title>jsp &gt; 字符串el表达式</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v2/uuid_t_jsp_jsp_%E5%AD%97%E7%AC%A6%E4%B8%B2el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v2/uuid_t_jsp_jsp_%E5%AD%97%E7%AC%A6%E4%B8%B2el%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>字符串el表达式#fn:contains 判断字符串是否包含另外一个字符串 &amp;lt;c:if test=&amp;quot;${fn:contains(name, searchString)}&amp;quot;&amp;gt;fn:containsIgnoreCase 判断字符串是否包含另外一个字符串(大小写无关) &amp;lt;c:if test=&amp;quot;${fn:containsIgnoreCase(name, searchString)}&amp;quot;&amp;gt;fn:endsWith 判断字符串是否以另外字符串结束 &amp;lt;c:if test=&amp;quot;${fn:endsWith(filename, &amp;quot;.txt&amp;quot;)}&amp;quot;&amp;gt;fn:escapeXml 把一些字符转成XML表示，例如 &amp;lt;字符应该转为&amp;lt; ${fn:escapeXml(param:info)}fn:indexOf 子字符串在母字符串中出现的位置 ${fn:indexOf(name, &amp;quot;-&amp;quot;)}fn:join 将数组中的数据联合成一个新字符串，并使用指定字符格开 ${fn:join(array, &amp;quot;;&amp;quot;)}fn:length 获取字符串的长度，或者数组的大小 ${fn:length(shoppingCart.products)}fn:replace 替换字符串中指定的字符 ${fn:replace(text, &amp;quot;-&amp;quot;, &amp;quot;?&amp;quot;)}fn:split 把字符串按照指定字符切分 ${fn:split(customerNames, &amp;quot;;&amp;quot;)}fn:startsWith 判断字符串是否以某个子串开始 &amp;lt;c:if test=&amp;quot;${fn:startsWith(product.id, &amp;quot;100-&amp;quot;)}&amp;quot;&amp;gt;fn:substring 获取子串 ${fn:substring(zip, 6, -1)}fn:substringAfter 获取从某个字符所在位置开始的子串 ${fn:substringAfter(zip, &amp;quot;-&amp;quot;)}fn:substringBefore 获取从开始到某个字符所在位置的子串 ${fn:substringBefore(zip, &amp;quot;-&amp;quot;)}fn:toLowerCase 转为小写 ${fn.toLowerCase(product.name)}fn:toUpperCase 转为大写字符 ${fn.UpperCase(product.name)}fn:trim 去除字符串前后的空格 ${fn.trim(name)}函数 描述fn:contains(string, substring)如果参数string中包含参数substring，返回truefn:containsIgnoreCase(string, substring)如果参数string中包含参数substring（忽略大小写），返回truefn:endsWith(string, suffix)如果参数 string 以参数suffix结尾，返回truefn:escapeXml(string)将有特殊意义的XML (和HTML)转换为对应的XML character entity code，并返回fn:indexOf(string, substring)返回参数substring在参数string中第一次出现的位置fn:join(array, separator)将一个给定的数组array用给定的间隔符separator串在一起，组成一个新的字符串并返回。fn:length(item)返回参数item中包含元素的数量。参数Item类型是数组、collection或者String。如果是String类型,返回值是String中的字符数。fn:replace(string, before, after)返回一个String对象。用参数after字符串替换参数string中所有出现参数before字符串的地方，并返回替换后的结果 fn:split(string, separator)返回一个数组，以参数separator 为分割符分割参数string，分割后的每一部分就是数组的一个元素fn:startsWith(string, prefix)如果参数string以参数prefix开头，返回truefn:substring(string, begin, end)返回参数string部分字符串, 从参数begin开始到参数end位置，包括end位置的字符fn:substringAfter(string, substring)返回参数substring在参数string中后面的那一部分字符串?</description>
    </item>
    
    <item>
      <title>redis</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_redis_redis/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_redis_redis/</guid>
      <description>一.Redis介绍#1.1引言# 1:由于用户量大，请求了随之增大，数据压力过大。 2:多台服务器之间数据不同步 3:多台服务器之间的锁已经不存在互斥性了
 #1.2 NOSQL# redis就是nosql
  非关系数据库 &amp;gt; not only sql
 1:key-value redis 2:文档型 solr,Mongodb,ElasticSearch 3:面向列 Hbase(一般大数据) 4:图形化 Neo4j
  1.3 redis介绍# Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 Redis是一款基于Key-Value的NOSQL，而且Redis是基于内存存储数据的,Redis还提供了多种持久化机制，Redis还提供了主从、哨兵以及集群的搭建方式，可以更方便的横向扩展以及垂直扩展
  操作都是原子的
 所有 Redis 的操作都是原子的，从而确保当两个客户同时访问 Redis 服务器时，得到的是更新后的值（最新值）。在需要高并发的场合可以考虑使用 Redis 的事务，处理一些需要锁的业务。
  二.Redis安装#三.Redis命令# keys * 获取所有的keyclear 清除屏幕quit ,exit 退出set name blake 设置值setex ip 5 192.</description>
    </item>
    
    <item>
      <title>SpringBoot学习笔记完整教程</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/</guid>
      <description>Spring boot 教 程#目录#  Spring boot helloworld# 介绍     自从structs2 出现上次的漏洞以后，对spring 的关注度开始越来越浓。
以前 spring 开发需要配置一大堆的 xml,后台 spring 加入了 annotaion，使得 xml 配置简化了很多，当然还是有些配置需要使用xml,比如申明component scan 等。
Spring 开了一个新的model spring boot,主要思想是降低spring 的入门，使得新手可以以最快的速度让程序在spring 框架下跑起来。
那么如何写Hello world 呢？ Hello 之步骤:
 (1) 新建一个Maven Java 工程
(2) 在pom.xml 文件中添加Spring Boot Maven 依赖(3)编写启动类
 (4)运行程序
  Hello 之New   这个步骤很简单，相比大家都会，小编在此为了文档的完整性，稍作简单说明：
首先使用 IDE（Eclipse,MyEclipse）工具新建一个 Maven 工程，可以是 Maven Java Project,也可以是 Maven Web Project,随便取一个工程名称。我使用的是STS，工程名是spring-boot-hello1。</description>
    </item>
    
    <item>
      <title>spring工具</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_spring%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_spring%E5%B7%A5%E5%85%B7/</guid>
      <description>spring工具类# Spring-core中提供了大量的工具类，常用的有StringUtils、ObjectUtils、NumberUtils、Base64Utils等，Spring工具类在spring-core.jar中的org.springframework.util包下。
  1:StringUtils  方法名	返回值类型	作用	备注isEmpty(Object str)	boolean	判断字符串是否为Null或者空字符串	null和&#39;&#39;都为truehasLength(CharSequence str)	boolean	判断字符串长度是否大于1	null和&#39;&#39;都为falsehasText(CharSequence str)	boolean	判断字符串中是否有字符	null和空字白符都为falsecontainsWhitespace(CharSequence str)	boolean	字符串中是否含有空白字符	trimWhitespace(CharSequence str)	String	去掉字符串中首尾的空白字符	trimAllWhitespace(String str)	String	去 掉字符串中所有的空白字符	trimLeadingWhitespace(String str)	String	去掉字符串左边的空白字符	trimTrailingWhitespace(String str)	String	去掉字符串右边边的空白字符	startsWithIgnoreCase(String str, String prefix)	String	判断字符串是否以xx开头，并且忽略大小写	getFilename(String path)	String	获取文件名	“mypath/myfile.txt” -&amp;gt; “myfile.txt”getFilenameExtension(String path)	String	获取文件扩展名	“mypath/myfile.txt” -&amp;gt; “txt”stripFilenameExtension(String path)	String	去掉文件扩展名	“mypath/myfile.</description>
    </item>
    
    <item>
      <title>spring常用的工具类</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_spring%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_tool_spring%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid>
      <description>spring常用的工具类#内置的resouce类型#UrlResourceClassPathResourceFileSystemResourceServletContextResourceInputStreamResourceByteArrayResourceEncodedResource 也就是Resource加上encoding, 可以认为是有编码的资源VfsResource(在jboss里经常用到, 相应还有 工具类 VfsUtils)org.springframework.util.xml.ResourceUtils 用于处理表达资源字符串前缀描述资源的工具. 如: &amp;amp;quot;classpath:&amp;amp;quot;. 有 getURL, getFile, isFileURL, isJarURL, extractJarFileURL 工具类#org.springframework.core.annotation.AnnotationUtils 处理注解org.springframework.core.io.support.PathMatchingResourcePatternResolver 用 于处理 ant 匹配风格(com/*.jsp, com/**/*.jsp),找出所有的资源, 结合上面的resource的概念一起使用,对于遍历文件很有用. 具体请详细查看javadocorg.springframework.core.io.support.PropertiesLoaderUtils 加载Properties资源工具类,和Resource结合org.springframework.core.BridgeMethodResolver 桥接方法分析器. 关于桥接方法请参考: http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.12.4.5org.springframework.core.GenericTypeResolver 范型分析器, 在用于对范型方法, 参数分析.org.springframework.core.NestedExceptionUtilsxml工具#org.springframework.util.xml.AbstractStaxContentHandlerorg.springframework.util.xml.AbstractStaxXMLReaderorg.springframework.util.xml.AbstractXMLReaderorg.springframework.util.xml.AbstractXMLStreamReaderorg.springframework.util.xml.DomUtilsorg.springframework.util.xml.SimpleNamespaceContextorg.springframework.util.xml.SimpleSaxErrorHandlerorg.springframework.util.xml.SimpleTransformErrorListenerorg.springframework.util.xml.StaxUtilsorg.springframework.util.xml.TransformerUtils其它工具集#org.springframework.util.xml.AntPathMatcherant风格的处理org.</description>
    </item>
    
    <item>
      <title>swing &gt; Introduction</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_swing_swing_introduction/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_swing_swing_introduction/</guid>
      <description>Swing 类库结构#Swing 是新一代的图形界面工具。使用 Swing 来开发图形界面比 AWT 更加优秀，因为 Swing 是一种轻量级组件，它采用纯 Java 实现，不再依赖于本地平台的图形界面，所以可以在所有平台上保持相同的运行效果，对跨平台支持比较出色。除此之外，Swing 提供了比 AWT 更多的图形界面组件，因此可以开发出美观的图形界面程序。  Swing 组件都采用 MVC（Model-View-Controller，即模型-视图-控制器）的设计，实现 GUI 组件的显示逻辑和数据逻辑的分离，从而允许程序员自定义 Render 来改变 GUI 组件的显示外观，以提供更多的灵活性。
  Swing 围绕 JComponent 组件构建，JComponent 则由 AWT 的容器类扩展而来。Swing 组织结构如图 1 所示。
  Swing包#  从图 1 可以看出，Swing 组件除了 AbstmctButton 类之外都以 J 开头。Swing 容器组件直接继承 AWT 类库中的容器组件类，其他大部分组件都是继承 JComponet 组件。组件可以划分为容器组件和非容器组件，容器组件包括 JFmme 和 JDialog。其中 JComponent 定义了非容器类的轻量级组件（JBntton、JPanel、JMenu 等）。
  表1 Swing常用包</description>
    </item>
    
    <item>
      <title>分布式缓存edisMemcached典面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98edismemcached%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98edismemcached%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>{width=&amp;ldquo;6.461388888888889in&amp;rdquo; height=&amp;ldquo;0.5419991251093613in&amp;rdquo;}
(1) memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型
(2) redis 的速度比 memcached 快很多
(3) redis 可以持久化其数据
{width=&amp;ldquo;6.461388888888889in&amp;rdquo; height=&amp;ldquo;0.5419991251093613in&amp;rdquo;}
 String、List、Set、Sorted Set、hashes
 {width=&amp;ldquo;6.461388888888889in&amp;rdquo; height=&amp;ldquo;0.5416655730533684in&amp;rdquo;}
 1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通 redis 无任何区别，设置好它下属的多个 redis 实例后，使用时在本需要连接 redis 的地方改为连接 twemproxy，它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再返回 twemproxy。使用方式简便(相对 redis只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。
 {width=&amp;ldquo;6.461388888888889in&amp;rdquo; height=&amp;ldquo;0.5416666666666666in&amp;rdquo;}
 LRU 算法
 {width=&amp;ldquo;6.461388888888889in&amp;rdquo; height=&amp;ldquo;0.5403324584426946in&amp;rdquo;}
 分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使 Redis 的计算能力通过简单地增加计算机得到成倍提升,Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。
 {width=&amp;ldquo;6.461388888888889in&amp;rdquo; height=&amp;ldquo;0.5416666666666666in&amp;rdquo;}
 给你举个例子： 100 万个键值对（键是 0 到 999999 值是字符串&amp;quot;hello world&amp;quot;）在我的 32 位的 Mac 笔记本上 用了 100MB。同样的数据放到一个 key 里只需要 16MB， 这是因为键值有一个很大的开销。 在 Memcached 上执行也是类似的结果，但是相对 Redis 的开销要小一点点，因为 Redis 会记录类型信息引用计数等等。</description>
    </item>
    
    <item>
      <title>史上最全40道Dubbo面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A840%E9%81%93dubbo%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A840%E9%81%93dubbo%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>想往高处走，怎么能不懂 Dubbo？
Dubbo 是国内最出名的分布式服务框架，也是 Java 程序员必备的必会的框架之一。Dubbo 更是中高级面试过程中经常会问的技术，无论你是否用过，你都必须熟悉。
下面我为大家准备了一些 Dubbo 常见的的面试题，一些是我经常问别人的，一些是我过去面试遇到的一些问题，总结给大家，希望对大家能有所帮助。
 {width=&amp;ldquo;5.768055555555556in&amp;rdquo; height=&amp;ldquo;4.1666666666666664e-2in&amp;rdquo;}
1、Dubbo 是什么？# Dubbo 是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。
面试官问你如果这个都不清楚，那下面的就没必要问了。
官网：http://dubbo.apache.org
 2、为什么要用Dubbo？# 因为是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了Netty、Zookeeper，保证了高性能高可用性。
使用 Dubbo 可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。
{width=&amp;ldquo;7.018332239720035in&amp;rdquo; height=&amp;ldquo;2.165978783902012in&amp;rdquo;}下面这张图可以很清楚的诠释，最重要的一点是，分布式架构可以承受更大规模的并发流量。
{width=&amp;ldquo;7.018332239720035in&amp;rdquo; height=&amp;ldquo;4.163888888888889in&amp;rdquo;}下面是 Dubbo 的服务治理图。
3、Dubbo 和 Spring Cloud 有什么区别？ 两个没关联，如果硬要说区别，有以下几点。1）通信方式不同
Dubbo 使用的是 RPC 通信，而 Spring Cloud 使用的是 HTTP RESTFul 方式。
 组成部分不同  +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+ | &amp;gt; 组件 | &amp;gt; Dubbo | &amp;gt; Spring Cloud | +==============+=================+================================+ | 服务注册中心 | &amp;gt; Zookeeper | &amp;gt; Spring Cloud Netflix Eureka | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+ | 服务监控 | &amp;gt; Dubbo-monitor | &amp;gt; Spring Boot Admin | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+ | 断路器 | &amp;gt; 不完善 | &amp;gt; Spring Cloud Netflix Hystrix | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+ | 服务网关 | &amp;gt; 无 | &amp;gt; Spring Cloud Netflix Gateway | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+ | 分布式配置 | &amp;gt; 无 | &amp;gt; Spring Cloud Config | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+ | 服务跟踪 | &amp;gt; 无 | &amp;gt; Spring Cloud Sleuth | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+</description>
    </item>
    
    <item>
      <title>史上最全50道Redis面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A850%E9%81%93redis%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A850%E9%81%93redis%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>{width=&amp;ldquo;5.773611111111111in&amp;rdquo; height=&amp;ldquo;9.990972222222222in&amp;rdquo;}
 更多关注 Java 大后端公众号
{width=&amp;ldquo;2.3333333333333335in&amp;rdquo; height=&amp;ldquo;2.3645833333333335in&amp;rdquo;}
关注公众号，获取更多面试题及答案。
1、什么是Redis？
Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。 Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能，比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。另外 Redis 也可以对存入的Key-Value 设置expire 时间，因此也可以被当作一 个功能加强版的memcached 来用。Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。
2、Redis 相比 memcached 有哪些优势？
 (1) memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型
(2) redis 的速度比 memcached 快很多
(3) redis 可以持久化其数据
 3、Redis 支持哪几种数据类型？ String、List、Set、Sorted Set、hashes 4、Redis 主要消耗什么物理资源？ 内存。</description>
    </item>
    
    <item>
      <title>史上最全70道Spring面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A870%E9%81%93spring%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A870%E9%81%93spring%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>70 道 Spring 面试题# **什么是 spring? **   Spring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用，但是有些扩展是针对构建 J2EE 平台的 web 应用。Spring 框架目标是简化 Java 企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。
 使用 Spring 框架的好处是什么？#  **轻量：**Spring 是轻量的，基本的版本大约 2MB。
  **控制反转：**Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。
  **面向切面的编程(AOP)：**Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。
  **容器：**Spring 包含并管理应用中对象的生命周期和配置。
  MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。
  **事务管理：**Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。
  **异常处理：**Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，HibernateorJDO抛出的）转化为一致的 unchecked 异常。</description>
    </item>
    
    <item>
      <title>搞定R试的0必备问题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E6%90%9E%E5%AE%9Ar%E8%AF%95%E7%9A%840%E5%BF%85%E5%A4%87%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E6%90%9E%E5%AE%9Ar%E8%AF%95%E7%9A%840%E5%BF%85%E5%A4%87%E9%97%AE%E9%A2%98/</guid>
      <description>1、请你自我介绍一下你自己？#**回答提示：**一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句&amp;quot;谢谢&amp;quot;，企业喜欢有礼貌的求职者。
2、你觉得你个性上最大的优点是什么？#**回答提示：**沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱。
3、说说你最大的缺点？#**回答提示：**这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对不要自作聪明地回答&amp;quot;我最大的缺点是过于追求完美&amp;quot;，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者。
4、你对加班的看法？#**回答提示：**实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。
**回答样本：**如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。
5、你对薪资的要求？#**回答提示：**如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高， 那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算， 因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。如果你自己必须说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。
**回答样本一：**我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。
**回答样本二：**我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。
6、你的职业规划？#**回答提示：**这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是&amp;quot;管理者&amp;quot;。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地位往往被称作&amp;quot;顾问&amp;quot;、&amp;ldquo;参议技师&amp;quot;或&amp;quot;高级软件工程师&amp;quot;等等。当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说&amp;quot;不知道&amp;rdquo;，或许就会使你丧失一个好机会。最普通的回答应该是&amp;quot;我准备在技术领域有所作为&amp;quot;或&amp;quot;我希望能按照公司的管理思路发展&amp;quot;。
7、你还有什么问题要问吗？#**回答提示：**企业的这个问题看上去可有可无，其实很关键，企业不喜欢说&amp;quot;没问题&amp;quot;的人， 因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。
8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位， 你怎么办？#**回答提示：**一段时间发现工作不适合我，有两种情况：①如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的， 你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。
9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？#**回答提示：**①.原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻， 婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。
10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？#**回答提示：**①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。②分清责任，各负其责， 如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸， 作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。
③总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。
11、谈谈你对跳槽的看法？#**回答提示：**①正常的&amp;quot;跳槽&amp;quot;能促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。
12、工作中你难以和同事、上司相处，你该怎么办？#**回答提示：**①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好， 如果是这样的话 我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的。
13、你对于我们公司了解多少？#**回答提示：**在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加强与国外大厂的OEM 合作，自有品牌的部分则透过海外经销商。
14、请说出你选择这份工作的动机？#**回答提示：**这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人， 如果是无经验者，可以强调&amp;quot;就算职种不同，也希望有机会发挥之前的经验&amp;quot;。</description>
    </item>
    
    <item>
      <title>精选17道海量数量处理面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E7%B2%BE%E9%80%8917%E9%81%93%E6%B5%B7%E9%87%8F%E6%95%B0%E9%87%8F%E5%A4%84%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E7%B2%BE%E9%80%8917%E9%81%93%E6%B5%B7%E9%87%8F%E6%95%B0%E9%87%8F%E5%A4%84%E7%90%86%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>给定 a、b 两个文件，各存放 50 亿个 url，每个 url 各占 64 字节，内存限制是 4G，让你找出 a、b 文件共同的 url？   方案 1：可以估计每个文件安的大小为 50G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。
{width=&amp;ldquo;1.0729166666666667in&amp;rdquo; height=&amp;ldquo;0.1358464566929134in&amp;rdquo;}{width=&amp;ldquo;0.8659722222222223in&amp;rdquo; height=&amp;ldquo;0.10449693788276465in&amp;rdquo;}s 遍历文件 a，对每个 url 求取 ，然后根据所取得的值将 url 分别存储到 1000 个小文件（记为 ）中。这样每个小文件的大约为300M。
s 遍历文件 b，采取和 a 相同的方式将 url 分别存储到 1000 各小文件（记为
{width=&amp;ldquo;0.8416655730533683in&amp;rdquo; height=&amp;ldquo;0.1358464566929134in&amp;rdquo;}）。这样处理后，所有可能相同的 url 都在对应的小文件
{width=&amp;ldquo;1.8659722222222221in&amp;rdquo; height=&amp;ldquo;0.1358464566929134in&amp;rdquo;}（ ）中，不对应的小文件不可能有相同的 url。然后我们只要求出 1000 对小文件中相同的 url 即可。
s 求每对小文件中相同的 url 时，可以把其中一个小文件的 url 存储到hash_set 中。然后遍历另一个小文件的每个 url，看其是否在刚才构建的hash_set 中，如果是，那么就是共同的 url，存到文件里面就可以了。
方案 2：如果允许有一定的错误率，可以使用 Bloom filter，4G 内存大概可以表示 340 亿 bit。将其中一个文件中的 url 使用 Bloom filter 映射为这 340 亿</description>
    </item>
    
    <item>
      <title>精选7道Elasticearch面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E7%B2%BE%E9%80%897%E9%81%93elasticearch%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E7%B2%BE%E9%80%897%E9%81%93elasticearch%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>为什么要使用 ES？  虽然 lucene 是性能最先进的、功能完善的搜索引擎，但是它只能有一个库，而且使用它需要集成到 java 项目才能使用，配置还特别复杂,而 ES 语法简单、是基于Resultful api 风格的, 它在 lucene 所有功能基础上还能集成多台服务器进行搜索，也就是集群;
 ES 和 lucene 的区别是什么？  lucene 是现存功能最强大、最先进搜索库，直接基于 lucene 开发，api 非常复杂大量的 java
代码、需要深入了解原理对比处:
只有一个索引库、 传统的遍历搜索方式采用B+树索引;
Es 是基于 lucene 的，隐藏了 lucene 复杂部分的一个分布式全文检索框架对比处:
一个es 的集群包含多个索引库、分布式搜索
Es 是采用倒排式索引
es 没有事物概念,删除不能恢复
es 开源免费
正排索引：id ---&amp;gt; value
倒排索引：value ---&amp;gt; id
 你还了解哪些全文检索工具？ Lucene，Solr，HadoopContrib，Katta 4.Bulk 一次最大处理多少数据量？  bulk 会把将要处理的数据载入内存中，所以数据量是有限制的
最佳的数据量不是一个确定的数值，它取决于你的硬件，你的文档大小以及复杂性，你的索
引以及搜索的负载。
一般建议是 1000-5000 个文档，如果你的文档很大，可以适当减少队列,大小建议是 5-15MB， 默认不能超过 100M，可以在 es 的配置文件中修改这个值 http.max_content_length: 100mb</description>
    </item>
    
    <item>
      <title>精选8道Dubbo面试题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E7%B2%BE%E9%80%898%E9%81%93dubbo%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E9%9D%A2%E8%AF%95_%E7%B2%BE%E9%80%898%E9%81%93dubbo%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>Dubbo 是阿里巴巴 SOA 服务化治理方案的核心框架，每天为 2,000+个服务提供 3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点。
Dubbo[]是一个分布式服务框架，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo 采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这
一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。关于注册中心、协议支持、服务监控
等内容。
  Dubbo 中 zookeeper 做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？   可以通信的，启动 dubbo 时，消费者会从 zk 拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用；
注册中心对等集群，任意一台宕机后，将会切换到另一台；注册中心全部宕机后，服务的提供者和消费者仍能通过本地缓存通讯。服务提供者无状态，任一台 宕机后，不影响使用；服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复；
挂掉是不要紧的，但前提是你没有增加新的服务，如果你要调用新的服务，则是不能办到的。
{width=&amp;ldquo;7.018332239720035in&amp;rdquo; height=&amp;ldquo;1.75in&amp;rdquo;}附文档截图：
  dubbo 服务负载均衡策略？   l Random LoadBalance
随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。(权重可以在 dubbo 管控台配置)
l RoundRobin LoadBalance
轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。
l LeastActive LoadBalance
最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。
l ConsistentHash LoadBalance
一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点， 平摊到其它提供者，不会引起剧烈变动。缺省只对第一个参数Hash，如果要修改，请配置
[AppleScript] 纯文本查看 复制代码
 +&amp;mdash;+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+ | 1 | &amp;lt;dubbo:parameter | | | | | | key=&amp;quot;hash.</description>
    </item>
    
  </channel>
</rss>
