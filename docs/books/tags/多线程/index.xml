<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>多线程 on Hugo Book</title>
    <link>https://huachengzhou.github.io/cycle/books/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
    <description>Recent content in 多线程 on Hugo Book</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 15 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://huachengzhou.github.io/cycle/books/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>java &gt; 多线程 &gt; 线程中断问题</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E9%97%AE%E9%A2%98/</guid>
      <description>结束线程的方式# 1:Thread.stop() 不推荐使用了  thread.stop() 2:thread.setDaemon() 设置为守护线程,JVM退出自动终止   Thread thread = new Thread(() -&amp;gt; {},&amp;quot;T-1&amp;quot;) ;thread.setDaemon(true);thread.start(); 3:共享变量 通过一个推出表示开关  public class MyTask implements Runnable {private boolean shouldExit = false;public void setShouldExit(boolean newExit) {this.shouldExit = newExit;}@Overridepublic void run() {while (!shouldExit){//执行线程操作}}} 4:利用中断机制thread.interrupt()  A:void interrupt() 相某个线程发出中断信号,将会设置该线程的中断状态位，即设置为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。它并不像stop方法那样会中断一个正在运行的线程。B:boolean isInterrupted() 查询某个线程是否有获得中断信号C:static boolean interrupted() 查询当前线程是否获得中断信号,查询后会重置中断的信号的状态 也就是说如果你连续两次调用这个方法,那么第一次是true,第二次是false 5:较优雅的退出方式  Thread thread = new Thread(new Runnable() {@Overridepublic void run() {while (!</description>
    </item>
    
    <item>
      <title>java &gt; 多线程 &gt; 线程状态</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</guid>
      <description>线程状态#public enum State {/**尚未启动的线程的线程状态 ,这个时候还没有在堆栈中分配内存等数据*/NEW,/**线程可能等待也可能阻塞*/RUNNABLE,/**阻塞 等待锁的状态*/BLOCKED,/**线程等待状态*/WAITING,/**和WAITING类似但是有时间的等待*/TIMED_WAITING,/**线程终止*/TERMINATED;}</description>
    </item>
    
    <item>
      <title>java &gt; 多线程info</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Binfo/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Binfo/</guid>
      <description>1、在 java 中守护线程和本地线程区别？
java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。
任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(boolon)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在 Thread.start()之前调用，否则运行时会抛出异常。
两者的区别：
唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。
扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。
2、线程与进程的区别？
进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。
一个程序至少有一个进程,一个进程至少有一个线程。
3、什么是多线程中的上下文切换？
多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU发生的切换数据等就是上下文切换。
4、死锁与活锁的区别，死锁与饥饿的区别？
死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
产生死锁的必要条件：
1、互斥条件：所谓互斥就是进程在某一时间内独占资源。
2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3、不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。
4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。
活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。
饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。
Java 中导致饥饿的原因：
1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。
2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。
3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。
5、Java 中用到的线程调度算法是什么？
采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。
6、什么是线程组，为什么在 Java 中不推荐使用？
ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</description>
    </item>
    
    <item>
      <title>java &gt; 多线程synchronized</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized/</guid>
      <description>synchronized# synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性
  用法:  public synchronized void doSomething(){//这里的代码不会同时有几个线程执行}synchronized (this){//这里的代码也不会有几个代码同时执行 } synchronized监视器 synchronized(object) object是监视器 被synchronized修饰的方法 静态方法:监视器是所属类的class对象 非静态方法:监视器是this 同一个监视器内所以代码都是同步的,不论是否在同一函数、同一类内如:   监视器不要使用Long,Integer等基本类型对象做监视器这样不好  public synchronized void methodA(){}public synchronized void methodB(){}public void methodC(){synchronized (this){}}//如果有一个线程已经运行ABC三处中的任意一个代码块，那么其它线程都不能执行这三个代码块的任意一个地方 下面是一些监视器  public class Sync {public void doA(){synchronized (this){//A 监视器Sync.this}}public synchronized void doB1(){//B1 监视器Sync.</description>
    </item>
    
    <item>
      <title>java &gt; 多线程synchronized.answer</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized.answer/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java_%E5%A4%9A%E7%BA%BF%E7%A8%8Bsynchronized.answer/</guid>
      <description>1342  首先t1线程最先执行所以输出1没问题
  输出t1后执行了object.wait(),当前执行线程放弃了此监视器上的锁,并且被挂起(等待此监视器上的其它线程来唤醒) 这里最重要的是把此监视器上的锁给放弃了
  t2线程去竞争object上的锁,由于目前只有它一个线程是属于非挂起状态因此t2就获得了object上的锁.因此输出了3没问题
  接着t2线程又执行了object.notify(),这个方法是随机唤醒此监视器上被挂起的线程,并且刚好只有2个线程中的一个被挂起那么t1就被唤醒了,注意仅仅是唤醒而已,并没有使得t2放弃锁或者t1获得锁,因此t1还是不能执行
  接着t2线程执行了sleep(500)这个方法,但是这个方法同样并没有使得t2线程放弃锁,仅仅是暂停了那么一会,这就像打战弱势的一方拿空间换时间做战略撤退，实际上并没有投降依然属于不投降状态
  因此当t2线程执行完之后t1最好才能执行接着打印出2
  </description>
    </item>
    
    <item>
      <title>java内存模型</title>
      <link>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://huachengzhou.github.io/cycle/books/docs/java/v4/uuid_t_%E5%A4%9A%E7%BA%BF%E7%A8%8B_java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>JMM(Java内存模型)# 主要有三个特性:可见性,有序性,原子性
 可见性#  计算机内存模型   Java内存模型简易   </description>
    </item>
    
  </channel>
</rss>
